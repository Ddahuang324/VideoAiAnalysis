# FFmpeg 音频编码流程详解

> [!NOTE]
> 本文档详细介绍 FFmpeg 音频编码的完整流程,包括核心函数调用、数据结构以及数据传递关系。所有示例基于 FFmpeg 4.x/5.x API。

## 概述

FFmpeg 音频编码流程是一个多阶段的数据处理管道,将原始音频数据(PCM)转换为压缩的音频格式(如 AAC、MP3、Opus 等)。整个流程分为 **7 个清晰的阶段**:

1. **初始化组件** - 创建格式上下文和编码器
2. **配置编码器** - 设置编码参数并打开编码器
3. **设置输出流** - 创建音频流并复制参数
4. **初始化输出文件** - 打开文件并写入文件头
5. **编码循环** - 处理音频帧并生成压缩数据
6. **刷新编码器** - 获取编码器缓存的剩余数据
7. **清理资源** - 释放所有资源并写入文件尾

---

## 核心架构

```mermaid
graph TB
    A["原始音频数据<br/>PCM Samples"] --> B["AVFrame<br/>音频帧"]
    B --> C["AVCodecContext<br/>编码器上下文"]
    C --> D["AVPacket<br/>压缩数据包"]
    D --> E["AVFormatContext<br/>封装器"]
    E --> F["输出文件<br/>MP4/AAC/MP3"]
    
    style A fill:#e1f5ff
    style B fill:#fff3e0
    style C fill:#f3e5f5
    style D fill:#e8f5e9
    style E fill:#fce4ec
    style F fill:#e1f5ff
```

---

## 主要数据结构

### AVCodecContext - 编码器上下文

编码器的核心配置结构,包含所有编码参数。

| 字段 | 类型 | 说明 |
|------|------|------|
| `codec_id` | `enum AVCodecID` | 编码器ID(如 AV_CODEC_ID_AAC) |
| `sample_rate` | `int` | 采样率(如 44100, 48000) |
| `channels` | `int` | 声道数(1=单声道, 2=立体声) |
| `channel_layout` | `uint64_t` | 声道布局(如 AV_CH_LAYOUT_STEREO) |
| `sample_fmt` | `enum AVSampleFormat` | 采样格式(如 AV_SAMPLE_FMT_FLTP) |
| `bit_rate` | `int64_t` | 目标比特率(如 128000) |
| `time_base` | `AVRational` | 时间基准(如 {1, 48000}) |

### AVFrame - 音频帧

存储未压缩的音频数据。

| 字段 | 类型 | 说明 |
|------|------|------|
| `data[8]` | `uint8_t*` | 音频数据缓冲区指针数组 |
| `linesize[8]` | `int` | 每个数据平面的大小 |
| `nb_samples` | `int` | 样本数量 |
| `format` | `int` | 采样格式 |
| `sample_rate` | `int` | 采样率 |
| `pts` | `int64_t` | 显示时间戳 |

### AVPacket - 压缩数据包

存储编码后的压缩数据。

| 字段 | 类型 | 说明 |
|------|------|------|
| `data` | `uint8_t*` | 压缩数据缓冲区 |
| `size` | `int` | 数据大小(字节) |
| `pts` | `int64_t` | 显示时间戳 |
| `dts` | `int64_t` | 解码时间戳 |
| `stream_index` | `int` | 流索引 |

---

## 完整编码流程 (七阶段)

```mermaid
flowchart TB
    Start([开始音频编码]) --> Stage1
    
    subgraph Stage1["阶段 1: 初始化组件"]
        direction TB
        S1_1["avformat_alloc_output_context2<br/>创建输出格式上下文"]
        S1_2["avcodec_find_encoder<br/>查找 AAC 编码器"]
        S1_3["avcodec_alloc_context3<br/>分配编码器上下文"]
        
        S1_1 --> S1_2
        S1_2 --> S1_3
    end
    
    Stage1 --> Stage2
    
    subgraph Stage2["阶段 2: 配置编码器"]
        direction TB
        S2_1["设置编码参数<br/>sample_rate, channels, bit_rate"]
        S2_2["avcodec_open2<br/>打开编码器"]
        
        S2_1 --> S2_2
    end
    
    Stage2 --> Stage3
    
    subgraph Stage3["阶段 3: 设置输出流"]
        direction TB
        S3_1["avformat_new_stream<br/>创建音频流"]
        S3_2["avcodec_parameters_from_context<br/>复制编码参数到流"]
        
        S3_1 --> S3_2
    end
    
    Stage3 --> Stage4
    
    subgraph Stage4["阶段 4: 初始化输出文件"]
        direction TB
        S4_1["avio_open<br/>打开输出文件"]
        S4_2["avformat_write_header<br/>写入文件头"]
        
        S4_1 --> S4_2
    end
    
    Stage4 --> Stage5
    
    subgraph Stage5["阶段 5: 编码循环"]
        direction TB
        S5_Start{还有音频数据?}
        S5_1["av_frame_alloc<br/>分配音频帧"]
        S5_2["填充 PCM 数据<br/>frame->data[0/1]"]
        S5_3["设置时间戳<br/>frame->pts"]
        S5_4["avcodec_send_frame<br/>发送帧到编码器"]
        S5_5["avcodec_receive_packet<br/>接收压缩数据包"]
        S5_6["av_interleaved_write_frame<br/>写入数据包到文件"]
        S5_7["av_packet_unref<br/>释放数据包引用"]
        
        S5_Start -->|是| S5_1
        S5_1 --> S5_2
        S5_2 --> S5_3
        S5_3 --> S5_4
        S5_4 --> S5_5
        S5_5 --> S5_6
        S5_6 --> S5_7
        S5_7 --> S5_Start
    end
    
    Stage5 --> Stage6
    
    subgraph Stage6["阶段 6: 刷新编码器"]
        direction TB
        S6_1["avcodec_send_frame NULL<br/>通知编码器结束"]
        S6_2["循环调用<br/>avcodec_receive_packet"]
        S6_3["写入所有剩余数据包<br/>av_interleaved_write_frame"]
        
        S6_1 --> S6_2
        S6_2 --> S6_3
    end
    
    Stage6 --> Stage7
    
    subgraph Stage7["阶段 7: 清理资源"]
        direction TB
        S7_1["av_write_trailer<br/>写入文件尾"]
        S7_2["av_frame_free<br/>释放帧"]
        S7_3["av_packet_free<br/>释放数据包"]
        S7_4["avcodec_free_context<br/>释放编码器上下文"]
        S7_5["avio_closep<br/>关闭文件"]
        S7_6["avformat_free_context<br/>释放格式上下文"]
        
        S7_1 --> S7_2
        S7_2 --> S7_3
        S7_3 --> S7_4
        S7_4 --> S7_5
        S7_5 --> S7_6
    end
    
    Stage7 --> End([编码完成])
    
    S5_Start -->|否| Stage6
    
    style Stage1 fill:#e3f2fd,stroke:#1976d2,stroke-width:2px
    style Stage2 fill:#fff3e0,stroke:#f57c00,stroke-width:2px
    style Stage3 fill:#e8f5e9,stroke:#388e3c,stroke-width:2px
    style Stage4 fill:#fce4ec,stroke:#c2185b,stroke-width:2px
    style Stage5 fill:#f3e5f5,stroke:#7b1fa2,stroke-width:2px
    style Stage6 fill:#e0f2f1,stroke:#00796b,stroke-width:2px
    style Stage7 fill:#fbe9e7,stroke:#d84315,stroke-width:2px
    
    style Start fill:#4caf50,color:#fff
    style End fill:#4caf50,color:#fff
```

---

## 七阶段时序图

下图展示了应用程序与 FFmpeg 各组件之间的完整交互过程:

```mermaid
sequenceDiagram
    participant App as 应用程序
    participant Fmt as AVFormatContext<br/>(封装器)
    participant Codec as AVCodecContext<br/>(编码器)
    participant Frame as AVFrame<br/>(音频帧)
    participant Pkt as AVPacket<br/>(数据包)
    participant File as 文件系统
    
    rect rgb(227, 242, 253)
    Note over App,File: 阶段 1: 初始化组件
    App->>Fmt: avformat_alloc_output_context2()
    activate Fmt
    App->>Codec: avcodec_find_encoder(AAC)
    activate Codec
    App->>Codec: avcodec_alloc_context3()
    end
    
    rect rgb(255, 243, 224)
    Note over App,File: 阶段 2: 配置编码器
    App->>Codec: 设置参数 (sample_rate, channels, bit_rate)
    App->>Codec: avcodec_open2()
    Note over Codec: 编码器就绪
    end
    
    rect rgb(232, 245, 233)
    Note over App,File: 阶段 3: 设置输出流
    App->>Fmt: avformat_new_stream()
    App->>Fmt: avcodec_parameters_from_context()
    Note over Fmt: 流配置完成
    end
    
    rect rgb(252, 228, 236)
    Note over App,File: 阶段 4: 初始化输出文件
    App->>File: avio_open(WRITE)
    activate File
    App->>Fmt: avformat_write_header()
    Fmt->>File: 写入文件头
    Note over File: 文件准备就绪
    end
    
    rect rgb(243, 229, 245)
    Note over App,File: 阶段 5: 编码循环
    loop 每个音频帧
        App->>Frame: av_frame_alloc()
        activate Frame
        App->>Frame: 填充 PCM 数据
        App->>Frame: 设置 PTS
        
        App->>Codec: avcodec_send_frame(frame)
        Note over Codec: 编码处理
        
        App->>Codec: avcodec_receive_packet(pkt)
        Codec-->>App: 返回 AVPacket
        activate Pkt
        
        App->>Fmt: av_interleaved_write_frame(pkt)
        Fmt->>File: 写入压缩数据
        
        App->>Pkt: av_packet_unref()
        deactivate Pkt
        deactivate Frame
    end
    end
    
    rect rgb(224, 242, 241)
    Note over App,File: 阶段 6: 刷新编码器
    App->>Codec: avcodec_send_frame(NULL)
    Note over Codec: 进入刷新模式
    
    loop 接收剩余数据包
        App->>Codec: avcodec_receive_packet(pkt)
        Codec-->>App: 返回 AVPacket
        activate Pkt
        App->>Fmt: av_interleaved_write_frame(pkt)
        Fmt->>File: 写入压缩数据
        App->>Pkt: av_packet_unref()
        deactivate Pkt
    end
    end
    
    rect rgb(251, 233, 231)
    Note over App,File: 阶段 7: 清理资源
    App->>Fmt: av_write_trailer()
    Fmt->>File: 写入文件尾
    
    App->>Frame: av_frame_free()
    App->>Pkt: av_packet_free()
    App->>Codec: avcodec_free_context()
    deactivate Codec
    App->>File: avio_closep()
    deactivate File
    App->>Fmt: avformat_free_context()
    deactivate Fmt
    end
    
    Note over App,File: ✅ 编码完成


## 详细函数调用流程

### 阶段 1: 初始化编码器

#### 1.1 分配输出格式上下文

```c
AVFormatContext* avformat_alloc_output_context2(
    AVFormatContext** ctx,
    const AVOutputFormat* oformat,
    const char* format_name,
    const char* filename
);
```

**输入参数:**
- `ctx`: 输出上下文指针的地址
- `oformat`: 输出格式(可为 NULL)
- `format_name`: 格式名称(如 "mp4", "aac")
- `filename`: 输出文件名

**输出:**
- 返回值: 0 表示成功,负值表示错误
- `*ctx`: 分配的 `AVFormatContext` 指针

**数据流:**
```mermaid
graph LR
    A["filename: output.mp4"] --> B[avformat_alloc_output_context2]
    B --> C["AVFormatContext*<br/>格式上下文"]
    C --> D["oformat: mp4_muxer<br/>nb_streams: 0"]
```

---

#### 1.2 查找编码器

```c
const AVCodec* avcodec_find_encoder(enum AVCodecID id);
```

**输入参数:**
- `id`: 编码器 ID(如 `AV_CODEC_ID_AAC`)

**输出:**
- 返回值: `AVCodec` 指针,失败返回 NULL

**示例:**
```c
const AVCodec* codec = avcodec_find_encoder(AV_CODEC_ID_AAC);
if (!codec) {
    fprintf(stderr, "未找到 AAC 编码器\n");
    return -1;
}
```

---

#### 1.3 分配编码器上下文

```c
AVCodecContext* avcodec_alloc_context3(const AVCodec* codec);
```

**输入参数:**
- `codec`: 编码器指针

**输出:**
- 返回值: `AVCodecContext` 指针

**数据流:**
```mermaid
graph LR
    A["AVCodec: AAC Encoder"] --> B[avcodec_alloc_context3]
    B --> C["AVCodecContext*<br/>未初始化的编码器上下文"]
```

---

### 阶段 2: 配置编码器参数

#### 2.1 设置编码参数

```c
// 配置示例
codec_ctx->sample_rate = 48000;              // 采样率
codec_ctx->channel_layout = AV_CH_LAYOUT_STEREO;  // 立体声
codec_ctx->channels = av_get_channel_layout_nb_channels(codec_ctx->channel_layout);
codec_ctx->sample_fmt = codec->sample_fmts[0];  // 使用编码器支持的第一个格式
codec_ctx->bit_rate = 128000;                // 128 kbps
codec_ctx->time_base = (AVRational){1, codec_ctx->sample_rate};
```

**参数说明:**

| 参数 | 值 | 说明 |
|------|-----|------|
| `sample_rate` | 48000 | 48kHz 采样率 |
| `channel_layout` | `AV_CH_LAYOUT_STEREO` | 立体声布局 |
| `channels` | 2 | 双声道 |
| `sample_fmt` | `AV_SAMPLE_FMT_FLTP` | 浮点平面格式 |
| `bit_rate` | 128000 | 128 kbps 比特率 |
| `time_base` | {1, 48000} | 时间基准 |

---

#### 2.2 打开编码器

```c
int avcodec_open2(
    AVCodecContext* avctx,
    const AVCodec* codec,
    AVDictionary** options
);
```

**输入参数:**
- `avctx`: 编码器上下文
- `codec`: 编码器
- `options`: 编码器选项(可为 NULL)

**输出:**
- 返回值: 0 表示成功

**数据流:**
```mermaid
graph TB
    A["AVCodecContext<br/>已配置参数"] --> B[avcodec_open2]
    C["AVCodec: AAC"] --> B
    D["AVDictionary: options"] --> B
    B --> E["已打开的编码器<br/>可以开始编码"]
    
    style E fill:#c8e6c9
```

---

#### 2.3 创建音频流

```c
AVStream* avformat_new_stream(
    AVFormatContext* s,
    const AVCodec* c
);
```

**输入参数:**
- `s`: 格式上下文
- `c`: 编码器(可为 NULL)

**输出:**
- 返回值: 新创建的 `AVStream` 指针

**示例:**
```c
AVStream* audio_stream = avformat_new_stream(format_ctx, NULL);
audio_stream->id = format_ctx->nb_streams - 1;
audio_stream->time_base = codec_ctx->time_base;
```

---

#### 2.4 复制编码器参数到流

```c
int avcodec_parameters_from_context(
    AVCodecParameters* par,
    const AVCodecContext* codec
);
```

**输入参数:**
- `par`: 流的编码参数
- `codec`: 编码器上下文

**输出:**
- 返回值: 0 表示成功

**数据流:**
```mermaid
graph LR
    A["AVCodecContext<br/>编码器配置"] --> B[avcodec_parameters_from_context]
    B --> C["AVStream->codecpar<br/>流参数"]
    C --> D[封装器可识别的参数]
```

---

#### 2.5 打开输出文件

```c
int avio_open(
    AVIOContext** s,
    const char* url,
    int flags
);
```

**输入参数:**
- `s`: IO 上下文指针的地址
- `url`: 文件路径
- `flags`: 打开标志(如 `AVIO_FLAG_WRITE`)

**输出:**
- 返回值: 0 表示成功

---

#### 2.6 写入文件头

```c
int avformat_write_header(
    AVFormatContext* s,
    AVDictionary** options
);
```

**输入参数:**
- `s`: 格式上下文
- `options`: 封装器选项

**输出:**
- 返回值: 0 表示成功
- 副作用: 写入文件头到输出文件

---

### 阶段 3: 编码音频帧

#### 3.1 分配音频帧

```c
AVFrame* av_frame_alloc(void);
```

**输出:**
- 返回值: `AVFrame` 指针

**配置帧参数:**
```c
AVFrame* frame = av_frame_alloc();
frame->nb_samples = codec_ctx->frame_size;  // 每帧样本数
frame->format = codec_ctx->sample_fmt;      // 采样格式
frame->channel_layout = codec_ctx->channel_layout;
frame->sample_rate = codec_ctx->sample_rate;

// 分配缓冲区
av_frame_get_buffer(frame, 0);
```

---

#### 3.2 填充音频数据

```c
// 示例: 生成正弦波测试音频
void fill_audio_frame(AVFrame* frame, int sample_count) {
    float* left = (float*)frame->data[0];   // 左声道
    float* right = (float*)frame->data[1];  // 右声道
    
    for (int i = 0; i < frame->nb_samples; i++) {
        float t = (float)sample_count / frame->sample_rate;
        left[i] = sin(2 * M_PI * 440.0 * t);   // 440Hz 正弦波
        right[i] = sin(2 * M_PI * 440.0 * t);
        sample_count++;
    }
}
```

**数据流:**
```mermaid
graph LR
    A["原始 PCM 数据<br/>float samples"] --> B["填充到 AVFrame"]
    B --> C["frame->data[0]: 左声道<br/>frame->data[1]: 右声道"]
    C --> D["nb_samples: 1024<br/>format: FLTP"]
```

---

#### 3.3 设置时间戳

```c
frame->pts = sample_count;  // 样本计数作为 PTS
```

**PTS 计算:**
- `pts` 以 `time_base` 为单位
- 对于音频,通常使用累积的样本数
- 实际时间 = `pts * time_base` (秒)

---

#### 3.4 发送帧到编码器

```c
int avcodec_send_frame(
    AVCodecContext* avctx,
    const AVFrame* frame
);
```

**输入参数:**
- `avctx`: 编码器上下文
- `frame`: 音频帧(NULL 表示刷新编码器)

**输出:**
- 返回值: 0 表示成功,`AVERROR(EAGAIN)` 表示需要先接收数据包

**数据流:**
```mermaid
graph TB
    A["AVFrame<br/>未压缩音频"] --> B[avcodec_send_frame]
    B --> C[编码器内部缓冲区]
    C --> D[编码处理]
    D --> E[压缩数据准备就绪]
    
    style A fill:#fff3e0
    style E fill:#e8f5e9
```

---

#### 3.5 接收编码后的数据包

```c
int avcodec_receive_packet(
    AVCodecContext* avctx,
    AVPacket* avpkt
);
```

**输入参数:**
- `avctx`: 编码器上下文
- `avpkt`: 数据包缓冲区

**输出:**
- 返回值: 0 表示成功,`AVERROR(EAGAIN)` 表示需要发送更多帧

**示例:**
```c
AVPacket* pkt = av_packet_alloc();

while (avcodec_receive_packet(codec_ctx, pkt) == 0) {
    // 成功接收到数据包
    pkt->stream_index = audio_stream->index;
    
    // 写入文件
    av_interleaved_write_frame(format_ctx, pkt);
    
    // 释放数据包引用
    av_packet_unref(pkt);
}
```

---

#### 3.6 写入数据包到文件

```c
int av_interleaved_write_frame(
    AVFormatContext* s,
    AVPacket* pkt
);
```

**输入参数:**
- `s`: 格式上下文
- `pkt`: 数据包

**输出:**
- 返回值: 0 表示成功
- 副作用: 数据包写入输出文件

**数据流:**
```mermaid
graph LR
    A["AVPacket<br/>压缩音频数据"] --> B[av_interleaved_write_frame]
    B --> C[封装器缓冲区]
    C --> D["输出文件<br/>output.mp4"]
    
    style A fill:#e8f5e9
    style D fill:#e1f5ff
```

---

### 阶段 4: 刷新编码器

编码器可能缓存了一些帧,需要刷新以获取所有数据。

```c
// 发送 NULL 帧表示结束
avcodec_send_frame(codec_ctx, NULL);

// 循环接收所有剩余数据包
AVPacket* pkt = av_packet_alloc();
while (avcodec_receive_packet(codec_ctx, pkt) == 0) {
    pkt->stream_index = audio_stream->index;
    av_interleaved_write_frame(format_ctx, pkt);
    av_packet_unref(pkt);
}
av_packet_free(&pkt);
```

**流程图:**
```mermaid
sequenceDiagram
    participant App as 应用程序
    participant Enc as 编码器
    participant File as 输出文件
    
    App->>Enc: avcodec_send_frame(NULL)
    Note over Enc: 进入刷新模式
    
    loop 直到无数据
        App->>Enc: avcodec_receive_packet()
        Enc-->>App: AVPacket (压缩数据)
        App->>File: av_interleaved_write_frame()
    end
    
    Enc-->>App: AVERROR_EOF
    Note over App: 刷新完成
```

---

### 阶段 5: 写入文件尾并清理

#### 5.1 写入文件尾

```c
int av_write_trailer(AVFormatContext* s);
```

**输入参数:**
- `s`: 格式上下文

**输出:**
- 返回值: 0 表示成功
- 副作用: 写入文件尾信息(如索引)

---

#### 5.2 清理资源

```c
// 释放编码器上下文
avcodec_free_context(&codec_ctx);

// 关闭输出文件
avio_closep(&format_ctx->pb);

// 释放格式上下文
avformat_free_context(format_ctx);

// 释放帧
av_frame_free(&frame);
```

---

## 完整代码示例

```c
#include <libavcodec/avcodec.h>
#include <libavformat/avformat.h>
#include <math.h>

int encode_audio_file(const char* filename) {
    AVFormatContext* fmt_ctx = NULL;
    AVCodecContext* codec_ctx = NULL;
    AVStream* stream = NULL;
    const AVCodec* codec = NULL;
    AVFrame* frame = NULL;
    AVPacket* pkt = NULL;
    int ret, sample_count = 0;
    
    // ========== 初始化阶段 ==========
    
    // 1. 分配输出格式上下文
    ret = avformat_alloc_output_context2(&fmt_ctx, NULL, NULL, filename);
    if (ret < 0) return ret;
    
    // 2. 查找 AAC 编码器
    codec = avcodec_find_encoder(AV_CODEC_ID_AAC);
    if (!codec) {
        fprintf(stderr, "未找到 AAC 编码器\n");
        return -1;
    }
    
    // 3. 分配编码器上下文
    codec_ctx = avcodec_alloc_context3(codec);
    if (!codec_ctx) return AVERROR(ENOMEM);
    
    // ========== 配置阶段 ==========
    
    // 4. 设置编码参数
    codec_ctx->sample_rate = 48000;
    codec_ctx->channel_layout = AV_CH_LAYOUT_STEREO;
    codec_ctx->channels = 2;
    codec_ctx->sample_fmt = AV_SAMPLE_FMT_FLTP;
    codec_ctx->bit_rate = 128000;
    codec_ctx->time_base = (AVRational){1, codec_ctx->sample_rate};
    
    // 5. 打开编码器
    ret = avcodec_open2(codec_ctx, codec, NULL);
    if (ret < 0) return ret;
    
    // 6. 创建音频流
    stream = avformat_new_stream(fmt_ctx, NULL);
    if (!stream) return AVERROR(ENOMEM);
    stream->time_base = codec_ctx->time_base;
    
    // 7. 复制参数到流
    avcodec_parameters_from_context(stream->codecpar, codec_ctx);
    
    // 8. 打开输出文件
    ret = avio_open(&fmt_ctx->pb, filename, AVIO_FLAG_WRITE);
    if (ret < 0) return ret;
    
    // 9. 写入文件头
    ret = avformat_write_header(fmt_ctx, NULL);
    if (ret < 0) return ret;
    
    // ========== 编码循环 ==========
    
    // 10. 分配帧和数据包
    frame = av_frame_alloc();
    pkt = av_packet_alloc();
    
    frame->nb_samples = codec_ctx->frame_size;
    frame->format = codec_ctx->sample_fmt;
    frame->channel_layout = codec_ctx->channel_layout;
    frame->sample_rate = codec_ctx->sample_rate;
    av_frame_get_buffer(frame, 0);
    
    // 11. 编码 5 秒音频 (示例)
    int total_samples = 5 * codec_ctx->sample_rate;
    while (sample_count < total_samples) {
        // 填充音频数据
        av_frame_make_writable(frame);
        float* left = (float*)frame->data[0];
        float* right = (float*)frame->data[1];
        
        for (int i = 0; i < frame->nb_samples; i++) {
            float t = (float)sample_count / codec_ctx->sample_rate;
            left[i] = sin(2 * M_PI * 440.0 * t);
            right[i] = sin(2 * M_PI * 440.0 * t);
            sample_count++;
        }
        
        frame->pts = sample_count;
        
        // 发送帧到编码器
        ret = avcodec_send_frame(codec_ctx, frame);
        if (ret < 0) break;
        
        // 接收编码后的数据包
        while (ret >= 0) {
            ret = avcodec_receive_packet(codec_ctx, pkt);
            if (ret == AVERROR(EAGAIN) || ret == AVERROR_EOF)
                break;
            if (ret < 0) return ret;
            
            pkt->stream_index = stream->index;
            av_interleaved_write_frame(fmt_ctx, pkt);
            av_packet_unref(pkt);
        }
    }
    
    // ========== 刷新编码器 ==========
    
    // 12. 发送 NULL 帧刷新编码器
    avcodec_send_frame(codec_ctx, NULL);
    while (avcodec_receive_packet(codec_ctx, pkt) == 0) {
        pkt->stream_index = stream->index;
        av_interleaved_write_frame(fmt_ctx, pkt);
        av_packet_unref(pkt);
    }
    
    // ========== 清理阶段 ==========
    
    // 13. 写入文件尾
    av_write_trailer(fmt_ctx);
    
    // 14. 释放资源
    av_frame_free(&frame);
    av_packet_free(&pkt);
    avcodec_free_context(&codec_ctx);
    avio_closep(&fmt_ctx->pb);
    avformat_free_context(fmt_ctx);
    
    return 0;
}
```

---

## 七阶段重构代码示例

将上述代码按照7个阶段重构为独立函数,提高可读性和可维护性:

```c
#include <libavcodec/avcodec.h>
#include <libavformat/avformat.h>
#include <math.h>

// 编码器上下文结构
typedef struct {
    AVFormatContext* fmt_ctx;
    AVCodecContext* codec_ctx;
    AVStream* stream;
    const AVCodec* codec;
    AVFrame* frame;
    AVPacket* pkt;
    int sample_count;
} EncoderContext;

// ========== 阶段 1: 初始化组件 ==========
int Step1_InitializeComponents(EncoderContext* ctx, const char* filename) {
    int ret;
    
    // 1. 分配输出格式上下文
    ret = avformat_alloc_output_context2(&ctx->fmt_ctx, NULL, NULL, filename);
    if (ret < 0) {
        fprintf(stderr, "无法创建输出上下文\n");
        return ret;
    }
    
    // 2. 查找 AAC 编码器
    ctx->codec = avcodec_find_encoder(AV_CODEC_ID_AAC);
    if (!ctx->codec) {
        fprintf(stderr, "未找到 AAC 编码器\n");
        return -1;
    }
    
    // 3. 分配编码器上下文
    ctx->codec_ctx = avcodec_alloc_context3(ctx->codec);
    if (!ctx->codec_ctx) {
        fprintf(stderr, "无法分配编码器上下文\n");
        return AVERROR(ENOMEM);
    }
    
    printf("✓ 阶段 1: 组件初始化完成\n");
    return 0;
}

// ========== 阶段 2: 配置编码器 ==========
int Step2_ConfigureEncoder(EncoderContext* ctx) {
    int ret;
    
    // 设置编码参数
    ctx->codec_ctx->sample_rate = 48000;
    ctx->codec_ctx->channel_layout = AV_CH_LAYOUT_STEREO;
    ctx->codec_ctx->channels = 2;
    ctx->codec_ctx->sample_fmt = AV_SAMPLE_FMT_FLTP;
    ctx->codec_ctx->bit_rate = 128000;
    ctx->codec_ctx->time_base = (AVRational){1, ctx->codec_ctx->sample_rate};
    
    // 打开编码器
    ret = avcodec_open2(ctx->codec_ctx, ctx->codec, NULL);
    if (ret < 0) {
        fprintf(stderr, "无法打开编码器\n");
        return ret;
    }
    
    printf("✓ 阶段 2: 编码器配置完成 (48kHz, 立体声, 128kbps)\n");
    return 0;
}

// ========== 阶段 3: 设置输出流 ==========
int Step3_SetupOutputStream(EncoderContext* ctx) {
    // 创建音频流
    ctx->stream = avformat_new_stream(ctx->fmt_ctx, NULL);
    if (!ctx->stream) {
        fprintf(stderr, "无法创建音频流\n");
        return AVERROR(ENOMEM);
    }
    ctx->stream->time_base = ctx->codec_ctx->time_base;
    
    // 复制编码参数到流
    avcodec_parameters_from_context(ctx->stream->codecpar, ctx->codec_ctx);
    
    printf("✓ 阶段 3: 输出流设置完成\n");
    return 0;
}

// ========== 阶段 4: 初始化输出文件 ==========
int Step4_InitializeOutputFile(EncoderContext* ctx, const char* filename) {
    int ret;
    
    // 打开输出文件
    ret = avio_open(&ctx->fmt_ctx->pb, filename, AVIO_FLAG_WRITE);
    if (ret < 0) {
        fprintf(stderr, "无法打开输出文件: %s\n", filename);
        return ret;
    }
    
    // 写入文件头
    ret = avformat_write_header(ctx->fmt_ctx, NULL);
    if (ret < 0) {
        fprintf(stderr, "无法写入文件头\n");
        return ret;
    }
    
    printf("✓ 阶段 4: 输出文件初始化完成\n");
    return 0;
}

// ========== 阶段 5: 编码循环 ==========
int Step5_EncodeLoop(EncoderContext* ctx, int duration_seconds) {
    int ret;
    
    // 分配帧和数据包
    ctx->frame = av_frame_alloc();
    ctx->pkt = av_packet_alloc();
    if (!ctx->frame || !ctx->pkt) {
        fprintf(stderr, "无法分配帧或数据包\n");
        return AVERROR(ENOMEM);
    }
    
    // 配置帧参数
    ctx->frame->nb_samples = ctx->codec_ctx->frame_size;
    ctx->frame->format = ctx->codec_ctx->sample_fmt;
    ctx->frame->channel_layout = ctx->codec_ctx->channel_layout;
    ctx->frame->sample_rate = ctx->codec_ctx->sample_rate;
    av_frame_get_buffer(ctx->frame, 0);
    
    // 编码循环
    int total_samples = duration_seconds * ctx->codec_ctx->sample_rate;
    int frames_encoded = 0;
    
    while (ctx->sample_count < total_samples) {
        // 填充音频数据 (440Hz 正弦波)
        av_frame_make_writable(ctx->frame);
        float* left = (float*)ctx->frame->data[0];
        float* right = (float*)ctx->frame->data[1];
        
        for (int i = 0; i < ctx->frame->nb_samples; i++) {
            float t = (float)ctx->sample_count / ctx->codec_ctx->sample_rate;
            left[i] = sin(2 * M_PI * 440.0 * t);
            right[i] = sin(2 * M_PI * 440.0 * t);
            ctx->sample_count++;
        }
        
        ctx->frame->pts = ctx->sample_count;
        
        // 发送帧到编码器
        ret = avcodec_send_frame(ctx->codec_ctx, ctx->frame);
        if (ret < 0) {
            fprintf(stderr, "发送帧失败\n");
            return ret;
        }
        
        // 接收编码后的数据包
        while (ret >= 0) {
            ret = avcodec_receive_packet(ctx->codec_ctx, ctx->pkt);
            if (ret == AVERROR(EAGAIN) || ret == AVERROR_EOF)
                break;
            if (ret < 0) {
                fprintf(stderr, "接收数据包失败\n");
                return ret;
            }
            
            ctx->pkt->stream_index = ctx->stream->index;
            av_interleaved_write_frame(ctx->fmt_ctx, ctx->pkt);
            av_packet_unref(ctx->pkt);
            frames_encoded++;
        }
    }
    
    printf("✓ 阶段 5: 编码循环完成 (%d 帧)\n", frames_encoded);
    return 0;
}

// ========== 阶段 6: 刷新编码器 ==========
int Step6_FlushEncoder(EncoderContext* ctx) {
    int ret;
    int flushed_frames = 0;
    
    // 发送 NULL 帧刷新编码器
    avcodec_send_frame(ctx->codec_ctx, NULL);
    
    // 接收所有剩余数据包
    while (1) {
        ret = avcodec_receive_packet(ctx->codec_ctx, ctx->pkt);
        if (ret == AVERROR_EOF || ret == AVERROR(EAGAIN))
            break;
        if (ret < 0) {
            fprintf(stderr, "刷新编码器失败\n");
            return ret;
        }
        
        ctx->pkt->stream_index = ctx->stream->index;
        av_interleaved_write_frame(ctx->fmt_ctx, ctx->pkt);
        av_packet_unref(ctx->pkt);
        flushed_frames++;
    }
    
    printf("✓ 阶段 6: 编码器刷新完成 (%d 帧)\n", flushed_frames);
    return 0;
}

// ========== 阶段 7: 清理资源 ==========
void Step7_Cleanup(EncoderContext* ctx) {
    // 写入文件尾
    if (ctx->fmt_ctx) {
        av_write_trailer(ctx->fmt_ctx);
    }
    
    // 释放资源
    if (ctx->frame) av_frame_free(&ctx->frame);
    if (ctx->pkt) av_packet_free(&ctx->pkt);
    if (ctx->codec_ctx) avcodec_free_context(&ctx->codec_ctx);
    if (ctx->fmt_ctx) {
        avio_closep(&ctx->fmt_ctx->pb);
        avformat_free_context(ctx->fmt_ctx);
    }
    
    printf("✓ 阶段 7: 资源清理完成\n");
}

// ========== 主函数 ==========
int encode_audio_file_7stages(const char* filename, int duration_seconds) {
    EncoderContext ctx = {0};
    int ret;
    
    printf("开始 FFmpeg 音频编码 (7 阶段流程)\n");
    printf("========================================\n");
    
    // 阶段 1: 初始化组件
    ret = Step1_InitializeComponents(&ctx, filename);
    if (ret < 0) goto cleanup;
    
    // 阶段 2: 配置编码器
    ret = Step2_ConfigureEncoder(&ctx);
    if (ret < 0) goto cleanup;
    
    // 阶段 3: 设置输出流
    ret = Step3_SetupOutputStream(&ctx);
    if (ret < 0) goto cleanup;
    
    // 阶段 4: 初始化输出文件
    ret = Step4_InitializeOutputFile(&ctx, filename);
    if (ret < 0) goto cleanup;
    
    // 阶段 5: 编码循环
    ret = Step5_EncodeLoop(&ctx, duration_seconds);
    if (ret < 0) goto cleanup;
    
    // 阶段 6: 刷新编码器
    ret = Step6_FlushEncoder(&ctx);
    if (ret < 0) goto cleanup;
    
    printf("========================================\n");
    printf("✅ 编码完成: %s\n", filename);
    
cleanup:
    // 阶段 7: 清理资源
    Step7_Cleanup(&ctx);
    return ret;
}

// 使用示例
int main(void) {
    return encode_audio_file_7stages("output.aac", 5);
}
```

### 七阶段重构的优势

| 优势 | 说明 |
|------|------|
| **模块化** | 每个阶段独立封装,职责清晰 |
| **可读性** | 函数名直接对应流程图阶段 |
| **可维护性** | 修改某个阶段不影响其他阶段 |
| **可测试性** | 每个阶段可以单独测试 |
| **错误处理** | 统一的错误处理和资源清理 |
| **可扩展性** | 易于添加新功能或修改参数 |

### 函数命名规范

```
Step1_InitializeComponents    - 初始化组件
Step2_ConfigureEncoder         - 配置编码器
Step3_SetupOutputStream        - 设置输出流
Step4_InitializeOutputFile     - 初始化输出文件
Step5_EncodeLoop               - 编码循环
Step6_FlushEncoder             - 刷新编码器
Step7_Cleanup                  - 清理资源
```

---

## 数据传递关系总览

```mermaid
graph TB
    subgraph Input["输入数据"]
        PCM["原始 PCM 音频<br/>float/int16 samples"]
    end
    
    subgraph Frame["帧处理"]
        AF[AVFrame 分配]
        Fill[填充音频数据]
        PTS[设置时间戳]
    end
    
    subgraph Encoder["编码器"]
        Send[avcodec_send_frame]
        EncBuf[编码器内部缓冲]
        Receive[avcodec_receive_packet]
    end
    
    subgraph Packet["数据包处理"]
        PKT[AVPacket]
        SetIdx[设置流索引]
    end
    
    subgraph Muxer["封装器"]
        Write[av_interleaved_write_frame]
        MuxBuf[封装器缓冲区]
    end
    
    subgraph Output["输出"]
        File["输出文件<br/>MP4/AAC/MP3"]
    end
    
    PCM --> AF
    AF --> Fill
    Fill --> PTS
    PTS --> Send
    Send --> EncBuf
    EncBuf --> Receive
    Receive --> PKT
    PKT --> SetIdx
    SetIdx --> Write
    Write --> MuxBuf
    MuxBuf --> File
    
    style Input fill:#e1f5ff
    style Frame fill:#fff3e0
    style Encoder fill:#f3e5f5
    style Packet fill:#e8f5e9
    style Muxer fill:#fce4ec
    style Output fill:#e1f5ff
```

---

## 关键函数输入输出汇总

| 函数 | 输入 | 输出 | 作用 |
|------|------|------|------|
| `avformat_alloc_output_context2` | 文件名、格式名 | `AVFormatContext*` | 创建输出格式上下文 |
| `avcodec_find_encoder` | 编码器 ID | `AVCodec*` | 查找编码器 |
| `avcodec_alloc_context3` | `AVCodec*` | `AVCodecContext*` | 分配编码器上下文 |
| `avcodec_open2` | `AVCodecContext*`, `AVCodec*` | 状态码 | 打开编码器 |
| `avformat_new_stream` | `AVFormatContext*` | `AVStream*` | 创建新流 |
| `avcodec_parameters_from_context` | `AVCodecContext*` | `AVCodecParameters` | 复制编码参数 |
| `avio_open` | 文件路径、标志 | `AVIOContext*` | 打开输出文件 |
| `avformat_write_header` | `AVFormatContext*` | 状态码 | 写入文件头 |
| `av_frame_alloc` | 无 | `AVFrame*` | 分配音频帧 |
| `avcodec_send_frame` | `AVFrame*` | 状态码 | 发送帧到编码器 |
| `avcodec_receive_packet` | `AVPacket*` | 状态码 | 从编码器接收数据包 |
| `av_interleaved_write_frame` | `AVPacket*` | 状态码 | 写入数据包到文件 |
| `av_write_trailer` | `AVFormatContext*` | 状态码 | 写入文件尾 |

---

## 时序图: 完整编码流程

```mermaid
sequenceDiagram
    participant App as 应用程序
    participant Codec as 编码器
    participant Muxer as 封装器
    participant File as 文件系统
    
    Note over App,File: 初始化阶段
    App->>Muxer: avformat_alloc_output_context2()
    App->>Codec: avcodec_find_encoder(AAC)
    App->>Codec: avcodec_alloc_context3()
    
    Note over App,File: 配置阶段
    App->>Codec: 设置参数 (采样率、声道等)
    App->>Codec: avcodec_open2()
    App->>Muxer: avformat_new_stream()
    App->>Muxer: avcodec_parameters_from_context()
    App->>File: avio_open()
    App->>Muxer: avformat_write_header()
    Muxer->>File: 写入文件头
    
    Note over App,File: 编码循环
    loop 每个音频帧
        App->>App: av_frame_alloc()
        App->>App: 填充 PCM 数据
        App->>App: 设置 PTS
        App->>Codec: avcodec_send_frame(frame)
        
        loop 接收所有可用数据包
            App->>Codec: avcodec_receive_packet(pkt)
            Codec-->>App: AVPacket (压缩数据)
            App->>Muxer: av_interleaved_write_frame(pkt)
            Muxer->>File: 写入数据包
            App->>App: av_packet_unref()
        end
    end
    
    Note over App,File: 刷新阶段
    App->>Codec: avcodec_send_frame(NULL)
    loop 接收剩余数据包
        App->>Codec: avcodec_receive_packet(pkt)
        Codec-->>App: AVPacket
        App->>Muxer: av_interleaved_write_frame(pkt)
        Muxer->>File: 写入数据包
    end
    
    Note over App,File: 清理阶段
    App->>Muxer: av_write_trailer()
    Muxer->>File: 写入文件尾
    App->>Codec: avcodec_free_context()
    App->>Muxer: avformat_free_context()
    App->>File: avio_closep()
```

---

## 常见编码器参数对比

| 编码器 | Codec ID | 典型采样格式 | 典型比特率 | 应用场景 |
|--------|----------|--------------|------------|----------|
| **AAC** | `AV_CODEC_ID_AAC` | `AV_SAMPLE_FMT_FLTP` | 128-256 kbps | 通用音频、流媒体 |
| **MP3** | `AV_CODEC_ID_MP3` | `AV_SAMPLE_FMT_S16P` | 128-320 kbps | 音乐、兼容性 |
| **Opus** | `AV_CODEC_ID_OPUS` | `AV_SAMPLE_FMT_S16` | 64-128 kbps | VoIP、低延迟 |
| **FLAC** | `AV_CODEC_ID_FLAC` | `AV_SAMPLE_FMT_S16` | 无损 | 无损音频存档 |
| **Vorbis** | `AV_CODEC_ID_VORBIS` | `AV_SAMPLE_FMT_FLTP` | 128-192 kbps | OGG 容器 |

---

## 采样格式说明

```mermaid
graph TB
    subgraph Planar["平面格式 (Planar)"]
        FLTP["AV_SAMPLE_FMT_FLTP<br/>float, planar"]
        S16P["AV_SAMPLE_FMT_S16P<br/>int16, planar"]
        
        FLTP --> L1["data[0]: 左声道<br/>LLLLLLLL"]
        FLTP --> R1["data[1]: 右声道<br/>RRRRRRRR"]
    end
    
    subgraph Interleaved["交错格式 (Interleaved)"]
        FLT["AV_SAMPLE_FMT_FLT<br/>float, interleaved"]
        S16["AV_SAMPLE_FMT_S16<br/>int16, interleaved"]
        
        FLT --> LR["data[0]: 交错数据<br/>LRLRLRLR"]
    end
    
    style Planar fill:#e3f2fd
    style Interleaved fill:#fff3e0
```

**格式说明:**
- **Planar (平面)**: 每个声道的数据分别存储在不同的缓冲区
- **Interleaved (交错)**: 所有声道的数据交错存储在同一缓冲区
- **FLTP**: 32位浮点平面格式,AAC 常用
- **S16P**: 16位整数平面格式,MP3 常用

---

## 错误处理最佳实践

```c
int ret;

// 检查返回值
ret = avcodec_send_frame(codec_ctx, frame);
if (ret < 0) {
    char errbuf[128];
    av_strerror(ret, errbuf, sizeof(errbuf));
    fprintf(stderr, "发送帧失败: %s\n", errbuf);
    return ret;
}

// 处理 EAGAIN
ret = avcodec_receive_packet(codec_ctx, pkt);
if (ret == AVERROR(EAGAIN)) {
    // 需要发送更多帧
    continue;
} else if (ret == AVERROR_EOF) {
    // 编码器已刷新完毕
    break;
} else if (ret < 0) {
    // 其他错误
    return ret;
}
```

> [!TIP]
> 使用 `av_strerror()` 将错误码转换为可读的错误信息,便于调试。

---

## 性能优化建议

> [!IMPORTANT]
> 以下优化可显著提升编码性能:

1. **帧大小优化**
   - 使用编码器推荐的 `frame_size`
   - AAC 通常为 1024 样本
   - 避免过小的帧导致频繁调用

2. **缓冲区重用**
   ```c
   // 重用帧和数据包,避免频繁分配
   AVFrame* frame = av_frame_alloc();
   AVPacket* pkt = av_packet_alloc();
   
   // 编码循环中重用
   for (...) {
       av_frame_make_writable(frame);  // 确保可写
       // ... 填充数据 ...
       avcodec_send_frame(codec_ctx, frame);
       
       while (avcodec_receive_packet(codec_ctx, pkt) == 0) {
           // ... 处理数据包 ...
           av_packet_unref(pkt);  // 释放引用而非释放对象
       }
   }
   
   av_frame_free(&frame);
   av_packet_free(&pkt);
   ```

3. **多线程编码**
   ```c
   codec_ctx->thread_count = 4;  // 使用 4 个线程
   codec_ctx->thread_type = FF_THREAD_FRAME;
   ```

4. **比特率控制**
   - VBR (可变比特率): 更好的质量
   - CBR (恒定比特率): 可预测的文件大小

---

## 总结

FFmpeg 音频编码流程遵循清晰的五阶段模式:

1. **初始化**: 创建格式上下文、查找编码器、分配编码器上下文
2. **配置**: 设置编码参数、打开编码器、创建流、写入文件头
3. **编码**: 循环发送帧、接收数据包、写入文件
4. **刷新**: 发送 NULL 帧、接收剩余数据包
5. **清理**: 写入文件尾、释放所有资源

**关键数据流:**
```
PCM 数据 → AVFrame → 编码器 → AVPacket → 封装器 → 输出文件
```

**核心函数对:**
- `avcodec_send_frame()` + `avcodec_receive_packet()`: 编码器交互
- `av_frame_alloc()` + `av_frame_free()`: 帧管理
- `av_packet_alloc()` + `av_packet_free()`: 数据包管理

> [!CAUTION]
> 务必正确处理资源释放,避免内存泄漏。每个 `alloc` 函数都应有对应的 `free` 调用。

---

## 参考资源

- [FFmpeg 官方文档](https://ffmpeg.org/documentation.html)
- [libavcodec API 参考](https://ffmpeg.org/doxygen/trunk/group__lavc__encoding.html)
- [音频编码示例](https://github.com/FFmpeg/FFmpeg/blob/master/doc/examples/encode_audio.c)
