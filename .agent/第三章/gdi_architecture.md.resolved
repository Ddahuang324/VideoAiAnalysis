# 3.1.2 ç‰¹å®šå¹³å°å®ç°ï¼šGDI å±å¹•é‡‡é›†æ¶æ„è®¾è®¡

> [!NOTE]
> æœ¬æ–‡æ¡£è¯¦ç»†é˜è¿°äº† Windows å¹³å°ä¸‹åŸºäº GDI (Graphics Device Interface) çš„å±å¹•é‡‡é›†å®ç°æ–¹æ¡ˆï¼Œæ˜¯ 3.1 é‡‡é›†å™¨æ¶æ„çš„é‡è¦ç»„æˆéƒ¨åˆ†ã€‚

---

## ä¸€ã€GDI æŠ€æœ¯èƒŒæ™¯ä¸æ ¸å¿ƒæ¦‚å¿µ

### 1.1 ä»€ä¹ˆæ˜¯ GDIï¼Ÿ

**GDI (Graphics Device Interface)** æ˜¯ Windows æ“ä½œç³»ç»Ÿæä¾›çš„å›¾å½¢è®¾å¤‡æ¥å£ï¼Œè‡ª Windows 1.0 ä»¥æ¥å°±æ˜¯ Windows å›¾å½¢å­ç³»ç»Ÿçš„æ ¸å¿ƒç»„ä»¶ã€‚å®ƒæä¾›äº†ä¸€å¥—ç»Ÿä¸€çš„ APIï¼Œç”¨äºåœ¨å±å¹•ã€æ‰“å°æœºç­‰è®¾å¤‡ä¸Šç»˜åˆ¶å›¾å½¢å’Œæ–‡æœ¬ã€‚

#### æ ¸å¿ƒç‰¹æ€§

| ç‰¹æ€§ | è¯´æ˜ |
|------|------|
| **å…¼å®¹æ€§** | æ”¯æŒæ‰€æœ‰ Windows ç‰ˆæœ¬ï¼ˆXP è‡³ Windows 11ï¼‰ |
| **ç¨³å®šæ€§** | ç»è¿‡æ•°åå¹´éªŒè¯ï¼ŒAPI ç¨³å®šä¸å˜ |
| **ç®€å•æ€§** | API è®¾è®¡ç›´è§‚ï¼Œå­¦ä¹ æ›²çº¿å¹³ç¼“ |
| **é€šç”¨æ€§** | é€‚ç”¨äºæ‰€æœ‰æ˜¾ç¤ºè®¾å¤‡å’Œæ˜¾å¡ |

#### æŠ€æœ¯å±€é™

| å±€é™ | å½±å“ |
|------|------|
| **æ€§èƒ½å¼€é”€** | åŸºäº CPU æ¸²æŸ“ï¼Œé«˜åˆ†è¾¨ç‡ä¸‹æ€§èƒ½ä¸è¶³ |
| **DWM å…¼å®¹æ€§** | Windows 8+ çš„ DWM åˆæˆå™¨å¯èƒ½å¯¼è‡´é¢å¤–å»¶è¿Ÿ |
| **æ— ç¡¬ä»¶åŠ é€Ÿ** | æ— æ³•åˆ©ç”¨ GPU åŠ é€Ÿï¼Œä¸æ”¯æŒé›¶æ‹·è´ |
| **é¼ æ ‡å…‰æ ‡** | éœ€è¦é¢å¤– API æ•è·å…‰æ ‡ï¼ˆ`GetCursorInfo`ï¼‰ |

---

### 1.2 GDI åœ¨é¡¹ç›®ä¸­çš„å®šä½

```mermaid
graph TB
    subgraph "3.1 é‡‡é›†å™¨æ¶æ„"
        A[IScreenGrabber æ¥å£]
        B[GrabberFactory å·¥å‚]
    end
    
    subgraph "3.1.2 ç‰¹å®šå¹³å°å®ç°"
        C[GDI_Grabber<br/>Windows å…¼å®¹æ–¹æ¡ˆ]
        D[DXGI_Grabber<br/>Windows é«˜æ€§èƒ½æ–¹æ¡ˆ]
        E[X11_Grabber<br/>Linux ä¼ ç»Ÿæ–¹æ¡ˆ]
        F[PipeWire_Grabber<br/>Linux ç°ä»£æ–¹æ¡ˆ]
    end
    
    A --> B
    B --> C
    B --> D
    B --> E
    B --> F
    
    style C fill:#4CAF50,stroke:#2E7D32,color:#fff
    style A fill:#2196F3,stroke:#1565C0,color:#fff
```

**è®¾è®¡ç†å¿µ**ï¼š
- **å…œåº•æ–¹æ¡ˆ**ï¼šå½“ DXGI ä¸å¯ç”¨æ—¶ï¼ˆå¦‚ Windows 7ã€è™šæ‹Ÿæœºç¯å¢ƒï¼‰ï¼ŒGDI ä½œä¸ºå¯é çš„å¤‡é€‰æ–¹æ¡ˆ
- **æµ‹è¯•åŸºå‡†**ï¼šä½œä¸ºæ€§èƒ½å¯¹æ¯”çš„åŸºå‡†å®ç°
- **å­¦ä¹ æ ·æœ¬**ï¼šç®€å•çš„å®ç°é€»è¾‘ä¾¿äºç†è§£å±å¹•é‡‡é›†çš„åŸºæœ¬åŸç†

---

## äºŒã€GDI å±å¹•é‡‡é›†åŸç†

### 2.1 æ ¸å¿ƒ API è°ƒç”¨æµç¨‹

```mermaid
sequenceDiagram
    participant App as GDI_Grabber
    participant GDI as Windows GDI API
    participant Screen as å±å¹•è®¾å¤‡
    
    App->>GDI: GetDC(NULL)<br/>è·å–å±å¹•è®¾å¤‡ä¸Šä¸‹æ–‡
    GDI-->>App: HDC hScreenDC
    
    App->>GDI: CreateCompatibleDC(hScreenDC)<br/>åˆ›å»ºå†…å­˜è®¾å¤‡ä¸Šä¸‹æ–‡
    GDI-->>App: HDC hMemoryDC
    
    App->>GDI: CreateCompatibleBitmap(hScreenDC, width, height)<br/>åˆ›å»ºä½å›¾
    GDI-->>App: HBITMAP hBitmap
    
    App->>GDI: SelectObject(hMemoryDC, hBitmap)<br/>é€‰æ‹©ä½å›¾åˆ°å†…å­˜DC
    
    loop æ¯å¸§é‡‡é›†
        App->>GDI: BitBlt(hMemoryDC, 0, 0, width, height,<br/>hScreenDC, x, y, SRCCOPY)
        GDI->>Screen: è¯»å–å±å¹•åƒç´ æ•°æ®
        Screen-->>GDI: åƒç´ æ•°æ®
        GDI-->>App: å¤åˆ¶å®Œæˆ
        
        App->>GDI: GetDIBits(hMemoryDC, hBitmap, ...)<br/>è·å–ä½å›¾æ•°æ®
        GDI-->>App: BGRA åƒç´ æ•°ç»„
        
        App->>App: å°è£…ä¸º FrameData
    end
    
    App->>GDI: DeleteObject(hBitmap)
    App->>GDI: DeleteDC(hMemoryDC)
    App->>GDI: ReleaseDC(NULL, hScreenDC)
```

---

### 2.2 å…³é”®æ•°æ®ç»“æ„

#### BITMAPINFOHEADER

```cpp
typedef struct tagBITMAPINFOHEADER {
    DWORD biSize;           // ç»“æ„ä½“å¤§å° (40 å­—èŠ‚)
    LONG  biWidth;          // ä½å›¾å®½åº¦ï¼ˆåƒç´ ï¼‰
    LONG  biHeight;         // ä½å›¾é«˜åº¦ï¼ˆæ­£å€¼ï¼šè‡ªä¸‹è€Œä¸Šï¼Œè´Ÿå€¼ï¼šè‡ªä¸Šè€Œä¸‹ï¼‰
    WORD  biPlanes;         // é¢œè‰²å¹³é¢æ•°ï¼ˆå¿…é¡»ä¸º 1ï¼‰
    WORD  biBitCount;       // æ¯åƒç´ ä½æ•°ï¼ˆ32 for BGRAï¼‰
    DWORD biCompression;    // å‹ç¼©ç±»å‹ï¼ˆBI_RGB = æ— å‹ç¼©ï¼‰
    DWORD biSizeImage;      // å›¾åƒå¤§å°ï¼ˆå­—èŠ‚ï¼‰
    // ... å…¶ä»–å­—æ®µ
} BITMAPINFOHEADER;
```

> [!IMPORTANT]
> **biHeight ç¬¦å·çš„å«ä¹‰**ï¼š
> - **æ­£å€¼**ï¼šä½å›¾æ•°æ®ä»åº•éƒ¨åˆ°é¡¶éƒ¨å­˜å‚¨ï¼ˆBMP æ ‡å‡†æ ¼å¼ï¼‰
> - **è´Ÿå€¼**ï¼šä½å›¾æ•°æ®ä»é¡¶éƒ¨åˆ°åº•éƒ¨å­˜å‚¨ï¼ˆæ¨èç”¨äºè§†é¢‘ç¼–ç ï¼‰

#### FrameData æ˜ å°„

```cpp
struct FrameData {
    uint8_t* data;              // æŒ‡å‘ BGRA åƒç´ æ•°ç»„
    int width;                  // = GetSystemMetrics(SM_CXSCREEN)
    int height;                 // = GetSystemMetrics(SM_CYSCREEN)
    PixelFormat format;         // = PixelFormat::BGRA
    int64_t timestamp_ms;       // = GetTickCount64()
    std::shared_ptr<uint8_t> data_holder;  // RAII ç®¡ç†å†…å­˜
};
```

---

## ä¸‰ã€GDI_Grabber æ¶æ„è®¾è®¡

### 3.1 ç±»è®¾è®¡å›¾

```mermaid
classDiagram
    class IScreenGrabber {
        <<interface>>
        +start() bool
        +stop() void
        +pause() void
        +resume() void
        +getWidth() int
        +getHeight() int
        +getFps() int
        +getPixelFormat() PixelFormat
        +isRunning() bool
        +isPaused() bool
        +CaptureFrame(timeout_ms) FrameData
    }
    
    class GDI_Grabber {
        -HDC m_hScreenDC
        -HDC m_hMemoryDC
        -HBITMAP m_hBitmap
        -HBITMAP m_hOldBitmap
        -int m_width
        -int m_height
        -int m_fps
        -bool m_isRunning
        -bool m_isPaused
        -BITMAPINFO m_bitmapInfo
        -std::vector~uint8_t~ m_frameBuffer
        
        +GDI_Grabber()
        +~GDI_Grabber()
        +start() bool
        +stop() void
        +pause() void
        +resume() void
        +CaptureFrame(timeout_ms) FrameData
        -initializeGDI() bool
        -cleanupGDI() void
        -captureScreen() bool
        -drawCursor(HDC hdc) void
    }
    
    class GrabberFactory {
        +createGrabber(type) unique_ptr~IScreenGrabber~
        +getAvailableGrabbers() vector~GrabberType~
        -detectBestGrabber() GrabberType
    }
    
    IScreenGrabber <|.. GDI_Grabber : implements
    GrabberFactory ..> GDI_Grabber : creates
```

---

### 3.2 çŠ¶æ€æœºè®¾è®¡

```mermaid
stateDiagram-v2
    [*] --> Idle : æ„é€ å‡½æ•°
    
    Idle --> Initializing : start()
    Initializing --> Running : GDI èµ„æºåˆå§‹åŒ–æˆåŠŸ
    Initializing --> Idle : åˆå§‹åŒ–å¤±è´¥
    
    Running --> Paused : pause()
    Paused --> Running : resume()
    
    Running --> Stopped : stop()
    Paused --> Stopped : stop()
    Stopped --> Idle : æ¸…ç† GDI èµ„æº
    
    Idle --> [*] : ææ„å‡½æ•°
    
    note right of Running
        CaptureFrame() å¯è°ƒç”¨
        æ‰§è¡Œ BitBlt + GetDIBits
    end note
    
    note right of Paused
        CaptureFrame() è¿”å›ç©ºå¸§
        ä¿æŒ GDI èµ„æºä¸é‡Šæ”¾
    end note
```

---

### 3.3 æ ¸å¿ƒå®ç°ç»†èŠ‚

#### 3.3.1 åˆå§‹åŒ–æµç¨‹ï¼ˆstart()ï¼‰

```cpp
bool GDI_Grabber::start() {
    if (m_isRunning) return true;
    
    // 1. è·å–å±å¹•å°ºå¯¸
    m_width = GetSystemMetrics(SM_CXSCREEN);
    m_height = GetSystemMetrics(SM_CYSCREEN);
    
    // 2. è·å–å±å¹•è®¾å¤‡ä¸Šä¸‹æ–‡
    m_hScreenDC = GetDC(NULL);
    if (!m_hScreenDC) {
        // é”™è¯¯å¤„ç†ï¼šè®°å½•æ—¥å¿—
        return false;
    }
    
    // 3. åˆ›å»ºå…¼å®¹çš„å†…å­˜è®¾å¤‡ä¸Šä¸‹æ–‡
    m_hMemoryDC = CreateCompatibleDC(m_hScreenDC);
    if (!m_hMemoryDC) {
        ReleaseDC(NULL, m_hScreenDC);
        return false;
    }
    
    // 4. åˆ›å»ºä½å›¾
    m_hBitmap = CreateCompatibleBitmap(m_hScreenDC, m_width, m_height);
    if (!m_hBitmap) {
        DeleteDC(m_hMemoryDC);
        ReleaseDC(NULL, m_hScreenDC);
        return false;
    }
    
    // 5. é€‰æ‹©ä½å›¾åˆ°å†…å­˜ DC
    m_hOldBitmap = (HBITMAP)SelectObject(m_hMemoryDC, m_hBitmap);
    
    // 6. é…ç½® BITMAPINFOï¼ˆç”¨äº GetDIBitsï¼‰
    ZeroMemory(&m_bitmapInfo, sizeof(BITMAPINFO));
    m_bitmapInfo.bmiHeader.biSize = sizeof(BITMAPINFOHEADER);
    m_bitmapInfo.bmiHeader.biWidth = m_width;
    m_bitmapInfo.bmiHeader.biHeight = -m_height;  // è´Ÿå€¼ï¼šè‡ªä¸Šè€Œä¸‹
    m_bitmapInfo.bmiHeader.biPlanes = 1;
    m_bitmapInfo.bmiHeader.biBitCount = 32;       // BGRA
    m_bitmapInfo.bmiHeader.biCompression = BI_RGB;
    
    // 7. é¢„åˆ†é…å¸§ç¼“å†²åŒº
    m_frameBuffer.resize(m_width * m_height * 4);  // 4 bytes per pixel
    
    m_isRunning = true;
    return true;
}
```

> [!TIP]
> **æ€§èƒ½ä¼˜åŒ–**ï¼šé¢„åˆ†é… `m_frameBuffer` é¿å…æ¯å¸§åŠ¨æ€åˆ†é…å†…å­˜ï¼Œå‡å°‘å†…å­˜ç¢ç‰‡ã€‚

---

#### 3.3.2 å¸§æ•è·æµç¨‹ï¼ˆCaptureFrame()ï¼‰

```cpp
FrameData GDI_Grabber::CaptureFrame(int timeout_ms) {
    FrameData frame;
    
    if (!m_isRunning || m_isPaused) {
        return frame;  // è¿”å›ç©ºå¸§
    }
    
    // 1. ä½¿ç”¨ BitBlt å¤åˆ¶å±å¹•å†…å®¹åˆ°å†…å­˜ DC
    BOOL success = BitBlt(
        m_hMemoryDC,        // ç›®æ ‡ DC
        0, 0,               // ç›®æ ‡èµ·å§‹åæ ‡
        m_width, m_height,  // å¤åˆ¶åŒºåŸŸå¤§å°
        m_hScreenDC,        // æº DCï¼ˆå±å¹•ï¼‰
        0, 0,               // æºèµ·å§‹åæ ‡
        SRCCOPY             // å…‰æ …æ“ä½œï¼šç›´æ¥å¤åˆ¶
    );
    
    if (!success) {
        // é”™è¯¯å¤„ç†ï¼šè®°å½•æ—¥å¿—
        return frame;
    }
    
    // 2. å¯é€‰ï¼šç»˜åˆ¶é¼ æ ‡å…‰æ ‡
    drawCursor(m_hMemoryDC);
    
    // 3. ä»ä½å›¾æå–åƒç´ æ•°æ®
    int scanLines = GetDIBits(
        m_hMemoryDC,
        m_hBitmap,
        0,                      // èµ·å§‹æ‰«æçº¿
        m_height,               // æ‰«æçº¿æ•°é‡
        m_frameBuffer.data(),   // è¾“å‡ºç¼“å†²åŒº
        &m_bitmapInfo,
        DIB_RGB_COLORS
    );
    
    if (scanLines != m_height) {
        // é”™è¯¯å¤„ç†
        return frame;
    }
    
    // 4. å°è£…ä¸º FrameData
    frame.width = m_width;
    frame.height = m_height;
    frame.format = PixelFormat::BGRA;
    frame.timestamp_ms = GetTickCount64();
    
    // 5. æ·±æ‹·è´åƒç´ æ•°æ®ï¼ˆä½¿ç”¨ shared_ptr ç®¡ç†ç”Ÿå‘½å‘¨æœŸï¼‰
    frame.data_holder = std::shared_ptr<uint8_t>(
        new uint8_t[m_frameBuffer.size()],
        std::default_delete<uint8_t[]>()
    );
    std::memcpy(frame.data_holder.get(), m_frameBuffer.data(), m_frameBuffer.size());
    frame.data = frame.data_holder.get();
    
    return frame;
}
```

> [!WARNING]
> **å†…å­˜ç®¡ç†é™·é˜±**ï¼šå¿…é¡»ä½¿ç”¨ `shared_ptr` ç®¡ç† `frame.data` çš„ç”Ÿå‘½å‘¨æœŸï¼Œå¦åˆ™åœ¨ [FrameData](file:///d:/%E7%BC%96%E7%A8%8B/%E9%A1%B9%E7%9B%AE/AiVideoAnalsysSystem/cpp/include/core/ScreenRecorder/CaptureLayer/IScreenGrabber.h#13-25) ç¦»å¼€ä½œç”¨åŸŸåä¼šå¯¼è‡´æ‚¬ç©ºæŒ‡é’ˆã€‚

---

#### 3.3.3 é¼ æ ‡å…‰æ ‡ç»˜åˆ¶ï¼ˆdrawCursor()ï¼‰

```cpp
void GDI_Grabber::drawCursor(HDC hdc) {
    CURSORINFO cursorInfo = { sizeof(CURSORINFO) };
    
    if (!GetCursorInfo(&cursorInfo)) {
        return;  // è·å–å…‰æ ‡ä¿¡æ¯å¤±è´¥
    }
    
    if (cursorInfo.flags != CURSOR_SHOWING) {
        return;  // å…‰æ ‡æœªæ˜¾ç¤º
    }
    
    // è·å–å…‰æ ‡å›¾æ ‡ä¿¡æ¯
    ICONINFO iconInfo;
    if (!GetIconInfo(cursorInfo.hCursor, &iconInfo)) {
        return;
    }
    
    // è®¡ç®—å…‰æ ‡ç»˜åˆ¶ä½ç½®ï¼ˆè€ƒè™‘çƒ­ç‚¹åç§»ï¼‰
    int x = cursorInfo.ptScreenPos.x - iconInfo.xHotspot;
    int y = cursorInfo.ptScreenPos.y - iconInfo.yHotspot;
    
    // ç»˜åˆ¶å…‰æ ‡
    DrawIconEx(
        hdc,
        x, y,
        cursorInfo.hCursor,
        0, 0,               // ä½¿ç”¨é»˜è®¤å…‰æ ‡å¤§å°
        0,
        NULL,
        DI_NORMAL | DI_DEFAULTSIZE
    );
    
    // æ¸…ç†èµ„æº
    DeleteObject(iconInfo.hbmColor);
    DeleteObject(iconInfo.hbmMask);
}
```

---

#### 3.3.4 èµ„æºæ¸…ç†ï¼ˆstop()ï¼‰

```cpp
void GDI_Grabber::stop() {
    if (!m_isRunning) return;
    
    m_isRunning = false;
    m_isPaused = false;
    
    // RAII åå‘æ¸…ç†é¡ºåº
    if (m_hOldBitmap) {
        SelectObject(m_hMemoryDC, m_hOldBitmap);
        m_hOldBitmap = NULL;
    }
    
    if (m_hBitmap) {
        DeleteObject(m_hBitmap);
        m_hBitmap = NULL;
    }
    
    if (m_hMemoryDC) {
        DeleteDC(m_hMemoryDC);
        m_hMemoryDC = NULL;
    }
    
    if (m_hScreenDC) {
        ReleaseDC(NULL, m_hScreenDC);
        m_hScreenDC = NULL;
    }
    
    m_frameBuffer.clear();
    m_frameBuffer.shrink_to_fit();  // é‡Šæ”¾å†…å­˜
}
```

> [!CAUTION]
> **èµ„æºæ³„æ¼é£é™©**ï¼šå¿…é¡»ä¸¥æ ¼æŒ‰ç…§ `SelectObject â†’ DeleteObject â†’ DeleteDC â†’ ReleaseDC` çš„é¡ºåºæ¸…ç†ï¼Œå¦åˆ™ä¼šå¯¼è‡´ GDI å¯¹è±¡æ³„æ¼ã€‚

---

## å››ã€å·¥å‚æ¨¡å¼é›†æˆ

### 4.1 GrabberFactory ä¸­çš„ GDI åˆ›å»ºé€»è¾‘

```cpp
std::unique_ptr<IScreenGrabber> GrabberFactory::createGrabber(GrabberType type) {
    if (type == GrabberType::AUTO) {
        type = detectBestGrabber();
    }
    
    switch (type) {
#ifdef _WIN32
        case GrabberType::GDI:
            return std::make_unique<GDI_Grabber>();
        case GrabberType::DXGI:
            return std::make_unique<DXGI_Grabber>();
#endif
        // ... å…¶ä»–å¹³å°
        default:
            return nullptr;
    }
}
```

### 4.2 è‡ªåŠ¨æ£€æµ‹é€»è¾‘

```cpp
GrabberType GrabberFactory::detectBestGrabber() {
#ifdef _WIN32
    // ä¼˜å…ˆä½¿ç”¨ DXGIï¼ˆWindows 8+ï¼‰
    OSVERSIONINFOEX osvi = { sizeof(OSVERSIONINFOEX) };
    if (GetVersionEx((OSVERSIONINFO*)&osvi)) {
        if (osvi.dwMajorVersion >= 6 && osvi.dwMinorVersion >= 2) {
            // Windows 8 åŠä»¥ä¸Šï¼Œå°è¯• DXGI
            auto dxgiGrabber = std::make_unique<DXGI_Grabber>();
            if (dxgiGrabber->start()) {
                dxgiGrabber->stop();
                return GrabberType::DXGI;
            }
        }
    }
    
    // é™çº§åˆ° GDI
    return GrabberType::GDI;
#endif
}
```

> [!NOTE]
> **é™çº§ç­–ç•¥**ï¼šåœ¨è™šæ‹Ÿæœºã€è¿œç¨‹æ¡Œé¢æˆ–æ—§ç³»ç»Ÿä¸­ï¼ŒDXGI å¯èƒ½ä¸å¯ç”¨ï¼Œæ­¤æ—¶è‡ªåŠ¨é™çº§åˆ° GDIã€‚

---

## äº”ã€æ€§èƒ½åˆ†æä¸ä¼˜åŒ–

### 5.1 æ€§èƒ½ç“¶é¢ˆåˆ†æ

```mermaid
graph LR
    A[BitBlt è°ƒç”¨] -->|CPU å¯†é›†| B[å†…å­˜å¤åˆ¶]
    B --> C[GetDIBits è°ƒç”¨]
    C -->|æ ¼å¼è½¬æ¢| D[BGRA æ•°æ®]
    D -->|æ·±æ‹·è´| E[FrameData]
    
    style A fill:#FF5722,stroke:#D32F2F,color:#fff
    style C fill:#FF9800,stroke:#F57C00,color:#fff
    style D fill:#FFC107,stroke:#FFA000,color:#000
```

| æ“ä½œ | è€—æ—¶å æ¯” | ä¼˜åŒ–ç©ºé—´ |
|------|---------|---------|
| **BitBlt** | 40-50% | âŒ æ— æ³•ä¼˜åŒ–ï¼ˆç³»ç»Ÿè°ƒç”¨ï¼‰ |
| **GetDIBits** | 30-40% | âš ï¸ å¯å‡å°‘è°ƒç”¨é¢‘ç‡ |
| **å†…å­˜æ‹·è´** | 10-20% | âœ… å¯ä½¿ç”¨ç§»åŠ¨è¯­ä¹‰ |

---

### 5.2 ä¼˜åŒ–ç­–ç•¥

#### ç­–ç•¥ 1ï¼šå‡å°‘å†…å­˜åˆ†é…

```cpp
// âŒ é”™è¯¯ï¼šæ¯å¸§åˆ†é…
FrameData GDI_Grabber::CaptureFrame(int timeout_ms) {
    std::vector<uint8_t> buffer(m_width * m_height * 4);  // æ¯æ¬¡åˆ†é…
    GetDIBits(..., buffer.data(), ...);
    // ...
}

// âœ… æ­£ç¡®ï¼šå¤ç”¨ç¼“å†²åŒº
class GDI_Grabber {
private:
    std::vector<uint8_t> m_frameBuffer;  // æˆå‘˜å˜é‡
};

bool GDI_Grabber::start() {
    m_frameBuffer.resize(m_width * m_height * 4);  // ä»…åˆå§‹åŒ–æ—¶åˆ†é…
}
```

---

#### ç­–ç•¥ 2ï¼šä½¿ç”¨ç§»åŠ¨è¯­ä¹‰ï¼ˆC++11ï¼‰

```cpp
// é¿å…æ·±æ‹·è´ï¼Œç›´æ¥è½¬ç§»æ‰€æœ‰æƒ
FrameData GDI_Grabber::CaptureFrame(int timeout_ms) {
    FrameData frame;
    
    // ä½¿ç”¨ shared_ptr ç®¡ç†ï¼Œæ”¯æŒæµ…æ‹·è´
    frame.data_holder = std::make_shared<uint8_t[]>(m_frameBuffer.size());
    std::memcpy(frame.data_holder.get(), m_frameBuffer.data(), m_frameBuffer.size());
    frame.data = frame.data_holder.get();
    
    return frame;  // ç¼–è¯‘å™¨è‡ªåŠ¨ä¼˜åŒ–ä¸ºç§»åŠ¨æ„é€ 
}
```

---

#### ç­–ç•¥ 3ï¼šé™ä½é‡‡é›†åˆ†è¾¨ç‡

```cpp
// å¯¹äº AI åˆ†æåœºæ™¯ï¼Œ720p è¶³å¤Ÿ
bool GDI_Grabber::start() {
    int screenWidth = GetSystemMetrics(SM_CXSCREEN);
    int screenHeight = GetSystemMetrics(SM_CYSCREEN);
    
    // é™é‡‡æ ·åˆ° 720p
    if (screenHeight > 720) {
        float scale = 720.0f / screenHeight;
        m_width = static_cast<int>(screenWidth * scale);
        m_height = 720;
    } else {
        m_width = screenWidth;
        m_height = screenHeight;
    }
    
    // ä½¿ç”¨ StretchBlt ä»£æ›¿ BitBlt
    StretchBlt(
        m_hMemoryDC, 0, 0, m_width, m_height,
        m_hScreenDC, 0, 0, screenWidth, screenHeight,
        SRCCOPY
    );
}
```

---

#### ç­–ç•¥ 4ï¼šè·³å¸§ç­–ç•¥

```cpp
class GDI_Grabber {
private:
    int m_targetFps = 30;
    int64_t m_lastCaptureTime = 0;
};

FrameData GDI_Grabber::CaptureFrame(int timeout_ms) {
    int64_t now = GetTickCount64();
    int64_t frameInterval = 1000 / m_targetFps;
    
    if (now - m_lastCaptureTime < frameInterval) {
        // è·³è¿‡æ­¤å¸§ï¼Œè¿”å›ç©ºå¸§
        return FrameData();
    }
    
    m_lastCaptureTime = now;
    // ... æ­£å¸¸é‡‡é›†é€»è¾‘
}
```

---

### 5.3 æ€§èƒ½å¯¹æ¯”ï¼ˆ1920x1080@30fpsï¼‰

| å®ç°æ–¹æ¡ˆ | CPU å ç”¨ | å†…å­˜å ç”¨ | å»¶è¿Ÿ | å…¼å®¹æ€§ |
|---------|---------|---------|------|--------|
| **GDIï¼ˆåŸå§‹ï¼‰** | 25-35% | 32 MB | 50-80ms | â­â­â­â­â­ |
| **GDIï¼ˆä¼˜åŒ–åï¼‰** | 15-20% | 24 MB | 40-60ms | â­â­â­â­â­ |
| **DXGI** | 5-10% | 16 MB | 10-20ms | â­â­â­ |

---

## å…­ã€é”™è¯¯å¤„ç†ä¸å¼‚å¸¸å®‰å…¨

### 6.1 é”™è¯¯åˆ†ç±»

```mermaid
graph TD
    A[GDI é”™è¯¯] --> B[åˆå§‹åŒ–å¤±è´¥]
    A --> C[è¿è¡Œæ—¶é”™è¯¯]
    
    B --> B1[GetDC è¿”å› NULL]
    B --> B2[CreateCompatibleDC å¤±è´¥]
    B --> B3[CreateCompatibleBitmap å¤±è´¥]
    
    C --> C1[BitBlt è¿”å› FALSE]
    C --> C2[GetDIBits è¿”å› 0]
    C --> C3[å†…å­˜ä¸è¶³]
    
    style A fill:#F44336,stroke:#C62828,color:#fff
    style B fill:#FF9800,stroke:#F57C00,color:#fff
    style C fill:#FFC107,stroke:#FFA000,color:#000
```

---

### 6.2 RAII èµ„æºç®¡ç†

```cpp
class GDIResourceGuard {
public:
    GDIResourceGuard(HDC& screenDC, HDC& memoryDC, HBITMAP& bitmap)
        : m_screenDC(screenDC), m_memoryDC(memoryDC), m_bitmap(bitmap) {}
    
    ~GDIResourceGuard() {
        if (m_bitmap) DeleteObject(m_bitmap);
        if (m_memoryDC) DeleteDC(m_memoryDC);
        if (m_screenDC) ReleaseDC(NULL, m_screenDC);
    }
    
    // ç¦æ­¢æ‹·è´
    GDIResourceGuard(const GDIResourceGuard&) = delete;
    GDIResourceGuard& operator=(const GDIResourceGuard&) = delete;
    
private:
    HDC& m_screenDC;
    HDC& m_memoryDC;
    HBITMAP& m_bitmap;
};

// ä½¿ç”¨ç¤ºä¾‹
bool GDI_Grabber::start() {
    GDIResourceGuard guard(m_hScreenDC, m_hMemoryDC, m_hBitmap);
    
    m_hScreenDC = GetDC(NULL);
    if (!m_hScreenDC) return false;
    
    // ... å…¶ä»–åˆå§‹åŒ–
    // å¦‚æœä¸­é€”å¤±è´¥ï¼Œææ„å‡½æ•°è‡ªåŠ¨æ¸…ç†å·²åˆ†é…çš„èµ„æº
}
```

---

### 6.3 æ—¥å¿—è®°å½•ç­–ç•¥

```cpp
#include <spdlog/spdlog.h>

FrameData GDI_Grabber::CaptureFrame(int timeout_ms) {
    FrameData frame;
    
    BOOL success = BitBlt(...);
    if (!success) {
        DWORD error = GetLastError();
        spdlog::error("BitBlt failed: error code = {}", error);
        
        // æ ¹æ®é”™è¯¯ç å†³å®šæ˜¯å¦é‡è¯•
        if (error == ERROR_INVALID_HANDLE) {
            spdlog::warn("Invalid handle detected, reinitializing GDI...");
            stop();
            start();
        }
        return frame;
    }
    
    // ...
}
```

---

## ä¸ƒã€æµ‹è¯•ä¸éªŒè¯

### 7.1 å•å…ƒæµ‹è¯•

```cpp
#include <gtest/gtest.h>

TEST(GDI_GrabberTest, InitializationSuccess) {
    GDI_Grabber grabber;
    EXPECT_TRUE(grabber.start());
    EXPECT_TRUE(grabber.isRunning());
    EXPECT_FALSE(grabber.isPaused());
    
    grabber.stop();
    EXPECT_FALSE(grabber.isRunning());
}

TEST(GDI_GrabberTest, CaptureFrameValid) {
    GDI_Grabber grabber;
    grabber.start();
    
    FrameData frame = grabber.CaptureFrame();
    
    EXPECT_NE(frame.data, nullptr);
    EXPECT_GT(frame.width, 0);
    EXPECT_GT(frame.height, 0);
    EXPECT_EQ(frame.format, PixelFormat::BGRA);
    EXPECT_GT(frame.timestamp_ms, 0);
    
    grabber.stop();
}

TEST(GDI_GrabberTest, PauseResumeLogic) {
    GDI_Grabber grabber;
    grabber.start();
    
    grabber.pause();
    EXPECT_TRUE(grabber.isPaused());
    
    FrameData pausedFrame = grabber.CaptureFrame();
    EXPECT_EQ(pausedFrame.data, nullptr);  // æš‚åœæ—¶è¿”å›ç©ºå¸§
    
    grabber.resume();
    EXPECT_FALSE(grabber.isPaused());
    
    FrameData resumedFrame = grabber.CaptureFrame();
    EXPECT_NE(resumedFrame.data, nullptr);
    
    grabber.stop();
}
```

---

### 7.2 é›†æˆæµ‹è¯•

```cpp
TEST(GrabberFactoryTest, CreateGDIGrabber) {
    auto grabber = GrabberFactory::createGrabber(GrabberType::GDI);
    
    ASSERT_NE(grabber, nullptr);
    EXPECT_TRUE(grabber->start());
    
    FrameData frame = grabber->CaptureFrame();
    EXPECT_NE(frame.data, nullptr);
    
    grabber->stop();
}

TEST(GrabberFactoryTest, AutoDetection) {
    auto grabber = GrabberFactory::createGrabber(GrabberType::AUTO);
    ASSERT_NE(grabber, nullptr);
    
    // åœ¨ Windows ä¸Šåº”è¯¥åˆ›å»º DXGI æˆ– GDI
    EXPECT_TRUE(grabber->start());
    grabber->stop();
}
```

---

### 7.3 æ€§èƒ½åŸºå‡†æµ‹è¯•

```cpp
#include <benchmark/benchmark.h>

static void BM_GDI_CaptureFrame(benchmark::State& state) {
    GDI_Grabber grabber;
    grabber.start();
    
    for (auto _ : state) {
        FrameData frame = grabber.CaptureFrame();
        benchmark::DoNotOptimize(frame);  // é˜²æ­¢ç¼–è¯‘å™¨ä¼˜åŒ–
    }
    
    grabber.stop();
}
BENCHMARK(BM_GDI_CaptureFrame);

// è¿è¡Œç»“æœç¤ºä¾‹ï¼š
// BM_GDI_CaptureFrame    45.2 ms    45.3 ms    15
// ï¼ˆè¡¨ç¤ºå¹³å‡æ¯å¸§è€—æ—¶ 45msï¼Œçº¦ 22 fpsï¼‰
```

---

## å…«ã€ç”Ÿäº§ç¯å¢ƒæœ€ä½³å®è·µ

### 8.1 ä½•æ—¶ä½¿ç”¨ GDIï¼Ÿ

âœ… **æ¨èåœºæ™¯**ï¼š
- Windows 7 åŠä»¥ä¸‹ç³»ç»Ÿ
- è™šæ‹Ÿæœºç¯å¢ƒï¼ˆVMwareã€VirtualBoxï¼‰
- è¿œç¨‹æ¡Œé¢ä¼šè¯ï¼ˆRDPï¼‰
- ä½œä¸º DXGI çš„é™çº§å¤‡é€‰æ–¹æ¡ˆ
- ä½å¸§ç‡å½•åˆ¶ï¼ˆâ‰¤15 fpsï¼‰

âŒ **ä¸æ¨èåœºæ™¯**ï¼š
- é«˜åˆ†è¾¨ç‡é«˜å¸§ç‡å½•åˆ¶ï¼ˆ4K@60fpsï¼‰
- æ¸¸æˆå½•åˆ¶ï¼ˆéœ€è¦ç¡¬ä»¶åŠ é€Ÿï¼‰
- å®æ—¶æµåª’ä½“ä¼ è¾“

---

### 8.2 é…ç½®å»ºè®®

```json
{
  "capture": {
    "preferredGrabber": "AUTO",
    "fallbackGrabber": "GDI",
    "gdi": {
      "targetFps": 15,
      "maxResolution": {
        "width": 1920,
        "height": 1080
      },
      "enableCursor": true,
      "bufferPoolSize": 3
    }
  }
}
```

---

### 8.3 ç›‘æ§æŒ‡æ ‡

```cpp
struct GDIMetrics {
    int64_t totalFramesCaptured;
    int64_t failedCaptures;
    double avgCaptureTime_ms;
    double avgMemoryUsage_mb;
    int currentFps;
};

class GDI_Grabber {
public:
    GDIMetrics getMetrics() const {
        return m_metrics;
    }
    
private:
    GDIMetrics m_metrics;
    
    void updateMetrics(int64_t captureTime_ms) {
        m_metrics.totalFramesCaptured++;
        m_metrics.avgCaptureTime_ms = 
            (m_metrics.avgCaptureTime_ms * (m_metrics.totalFramesCaptured - 1) + captureTime_ms) 
            / m_metrics.totalFramesCaptured;
    }
};
```

---

## ä¹ã€æœªæ¥æ¼”è¿›æ–¹å‘

### 9.1 æŠ€æœ¯è·¯çº¿å›¾

```mermaid
timeline
    title GDI_Grabber æ¼”è¿›è·¯çº¿
    2024 Q1 : åŸºç¡€å®ç°
            : æ¥å£é€‚é…
            : å•å…ƒæµ‹è¯•
    2024 Q2 : æ€§èƒ½ä¼˜åŒ–
            : å†…å­˜æ± 
            : è·³å¸§ç­–ç•¥
    2024 Q3 : å¢å¼ºåŠŸèƒ½
            : åŒºåŸŸæ•è·
            : å¤šæ˜¾ç¤ºå™¨æ”¯æŒ
    2024 Q4 : ç»´æŠ¤æ¨¡å¼
            : Bug ä¿®å¤
            : æ–‡æ¡£å®Œå–„
```

---

### 9.2 æ½œåœ¨æ”¹è¿›

| æ”¹è¿›é¡¹ | æŠ€æœ¯æ–¹æ¡ˆ | ä¼˜å…ˆçº§ |
|--------|---------|--------|
| **åŒºåŸŸæ•è·** | æ”¯æŒæŒ‡å®šçŸ©å½¢åŒºåŸŸï¼ˆçª—å£æ•è·ï¼‰ | ğŸ”´ é«˜ |
| **å¤šæ˜¾ç¤ºå™¨** | æšä¸¾æ‰€æœ‰æ˜¾ç¤ºå™¨ï¼Œæ”¯æŒé€‰æ‹© | ğŸŸ¡ ä¸­ |
| **é¢œè‰²ç©ºé—´è½¬æ¢** | æ”¯æŒè¾“å‡º RGB24/YUV420 | ğŸŸ¢ ä½ |
| **ç¡¬ä»¶å…‰æ ‡** | ä½¿ç”¨ DWM API è·å–ç¡¬ä»¶å…‰æ ‡ | ğŸŸ¢ ä½ |

---

## åã€æ€»ç»“

### æ ¸å¿ƒè¦ç‚¹

1. **GDI æ˜¯å¯é çš„å…œåº•æ–¹æ¡ˆ**ï¼šè™½ç„¶æ€§èƒ½ä¸å¦‚ DXGIï¼Œä½†å…¼å®¹æ€§æ— å¯åŒ¹æ•Œ
2. **RAII æ˜¯èµ„æºç®¡ç†çš„å…³é”®**ï¼šé¿å… GDI å¯¹è±¡æ³„æ¼
3. **æ€§èƒ½ä¼˜åŒ–ç©ºé—´æœ‰é™**ï¼šä¸»è¦ç“¶é¢ˆåœ¨ç³»ç»Ÿè°ƒç”¨ï¼Œåº”ä»æ¶æ„å±‚é¢ä¼˜åŒ–ï¼ˆé™é‡‡æ ·ã€è·³å¸§ï¼‰
4. **å·¥å‚æ¨¡å¼å®ç°å¹³å°è§£è€¦**ï¼šä¸Šå±‚ä»£ç æ— éœ€å…³å¿ƒå…·ä½“å®ç°

### ä¸å…¶ä»–æ¨¡å—çš„åä½œ

```mermaid
graph LR
    A[GDI_Grabber] -->|FrameData| B[FrameEncoder]
    B -->|H.264 Packets| C[MediaWriter]
    C -->|MP4 Files| D[AI Analysis Pipeline]
    
    E[RecorderController] -->|start/stop| A
    F[SettingsManager] -->|FPS/Resolution| A
    
    style A fill:#4CAF50,stroke:#2E7D32,color:#fff
    style D fill:#2196F3,stroke:#1565C0,color:#fff
```

---

## å‚è€ƒèµ„æ–™

- [Microsoft GDI Documentation](https://docs.microsoft.com/en-us/windows/win32/gdi/windows-gdi)
- [BitBlt Function Reference](https://docs.microsoft.com/en-us/windows/win32/api/wingdi/nf-wingdi-bitblt)
- [BITMAPINFO Structure](https://docs.microsoft.com/en-us/windows/win32/api/wingdi/ns-wingdi-bitmapinfo)
- [Screen Capture Best Practices](https://docs.microsoft.com/en-us/windows/win32/gdi/capturing-an-image)

---

**æ–‡æ¡£ç‰ˆæœ¬**ï¼šv1.0  
**æœ€åæ›´æ–°**ï¼š2025-12-12  
**ä½œè€…**ï¼šAI Video Analysis System Team
