# 3.2.1 çº¿ç¨‹å®‰å…¨é˜Ÿåˆ—è®¾è®¡

> **æ ¸å¿ƒåŸºç¡€è®¾æ–½**  
> `ThreadSafeQueue<T>` æ˜¯è§†é¢‘æµå¤„ç†æ¨¡å—çš„åŸºçŸ³,å®ç°é‡‡é›†çº¿ç¨‹å’Œç¼–ç çº¿ç¨‹ä¹‹é—´çš„é«˜æ•ˆã€å®‰å…¨æ•°æ®ä¼ é€’ã€‚æœ¬æ–‡æ¡£æ·±å…¥è®²è§£å…¶è®¾è®¡åŸç†ã€å®ç°ç»†èŠ‚å’Œæœ€ä½³å®è·µã€‚

---

## ğŸ“‹ ç›®å½•

1. [æ¨¡å—æ¦‚è¿°ä¸å®šä½](#æ¨¡å—æ¦‚è¿°ä¸å®šä½)
2. [è®¾è®¡ç›®æ ‡ä¸åŸåˆ™](#è®¾è®¡ç›®æ ‡ä¸åŸåˆ™)
3. [æ ¸å¿ƒæ¶æ„è®¾è®¡](#æ ¸å¿ƒæ¶æ„è®¾è®¡)
4. [è¯¦ç»†å®ç°è§£æ](#è¯¦ç»†å®ç°è§£æ)
5. [å…³é”®æŠ€æœ¯æ·±åº¦è§£æ](#å…³é”®æŠ€æœ¯æ·±åº¦è§£æ)
6. [æ€§èƒ½ä¼˜åŒ–ç­–ç•¥](#æ€§èƒ½ä¼˜åŒ–ç­–ç•¥)
7. [å®æˆ˜ä½¿ç”¨æŒ‡å—](#å®æˆ˜ä½¿ç”¨æŒ‡å—)
8. [æµ‹è¯•ä¸éªŒè¯](#æµ‹è¯•ä¸éªŒè¯)

---

## æ¨¡å—æ¦‚è¿°ä¸å®šä½

### åœ¨ç³»ç»Ÿä¸­çš„ä½ç½®

```mermaid
graph TB
    subgraph "é‡‡é›†å±‚"
        Grabber[FrameGrabberThread<br/>å±å¹•é‡‡é›†çº¿ç¨‹]
    end
    
    subgraph "æ ¸å¿ƒåŸºç¡€è®¾æ–½"
        Queue[ThreadSafeQueue<br/>çº¿ç¨‹å®‰å…¨é˜Ÿåˆ—<br/>å®¹é‡: 30å¸§]
    end
    
    subgraph "ç¼–ç å±‚"
        Encoder[FrameEncoder<br/>å¸§ç¼–ç çº¿ç¨‹]
    end
    
    Grabber -->|push<br/>ç”Ÿäº§å¸§æ•°æ®| Queue
    Queue -->|pop<br/>æ¶ˆè´¹å¸§æ•°æ®| Encoder
    
    style Queue fill:#FFA500,stroke:#333,stroke-width:3px
    style Grabber fill:#87CEEB
    style Encoder fill:#90EE90
```

### æ ¸å¿ƒèŒè´£

| èŒè´£ | è¯´æ˜ | é‡è¦æ€§ |
|------|------|--------|
| **çº¿ç¨‹åŒæ­¥** | åè°ƒç”Ÿäº§è€…å’Œæ¶ˆè´¹è€…çº¿ç¨‹ | â­â­â­â­â­ |
| **æ•°æ®ç¼“å†²** | ç¼“å†²30å¸§æ•°æ®,å¹³æ»‘é€Ÿåº¦å·®å¼‚ | â­â­â­â­â­ |
| **æµé‡æ§åˆ¶** | é˜²æ­¢å†…å­˜æº¢å‡º,æ”¯æŒèƒŒå‹ | â­â­â­â­ |
| **ä¼˜é›…åœæ­¢** | å®‰å…¨å…³é—­,é¿å…æ­»é” | â­â­â­â­â­ |

---

## è®¾è®¡ç›®æ ‡ä¸åŸåˆ™

### æ ¸å¿ƒè®¾è®¡ç›®æ ‡

```mermaid
mindmap
  root((ThreadSafeQueue))
    çº¿ç¨‹å®‰å…¨
      æ— æ•°æ®ç«äº‰
      æ— æ­»é”
      æ— å†…å­˜æ³„æ¼
    é«˜æ€§èƒ½
      ä½å»¶è¿Ÿ < 1ms
      é«˜åå 60fps
      é›¶æ‹·è´ä¼˜åŒ–
    å¯é æ€§
      ä¼˜é›…åœæ­¢
      å¼‚å¸¸å®‰å…¨
      è¶…æ—¶æœºåˆ¶
    æ˜“ç”¨æ€§
      ç®€æ´API
      æ¨¡æ¿åŒ–è®¾è®¡
      RAIIç®¡ç†
```

### æŠ€æœ¯é€‰å‹

| æŠ€æœ¯ | é€‰æ‹© | åŸå›  |
|------|------|------|
| **åŒæ­¥åŸè¯­** | `std::mutex` + `std::condition_variable` | C++11æ ‡å‡†,è·¨å¹³å°,æ€§èƒ½ä¼˜ç§€ |
| **åº•å±‚å®¹å™¨** | `std::queue` | FIFOè¯­ä¹‰,æ¥å£ç®€æ´ |
| **å†…å­˜ç®¡ç†** | ç§»åŠ¨è¯­ä¹‰ (`std::move`) | é¿å…æ‹·è´,æå‡æ€§èƒ½ |
| **è¶…æ—¶æ§åˆ¶** | `wait_for()` | é¿å…æ°¸ä¹…é˜»å¡ |

---

## æ ¸å¿ƒæ¶æ„è®¾è®¡

### ç±»å®šä¹‰æ¦‚è§ˆ

```cpp
template<typename T>
class ThreadSafeQueue {
public:
    // æ„é€ ä¸ææ„
    explicit ThreadSafeQueue(size_t max_size = 0);
    ~ThreadSafeQueue() = default;
    
    // ç¦æ­¢æ‹·è´,å…è®¸ç§»åŠ¨
    ThreadSafeQueue(const ThreadSafeQueue&) = delete;
    ThreadSafeQueue& operator=(const ThreadSafeQueue&) = delete;
    
    // æ ¸å¿ƒæ“ä½œ
    bool push(T value, std::chrono::milliseconds timeout);
    bool pop(T& value, std::chrono::milliseconds timeout);
    std::optional<T> tryPop();
    
    // çŠ¶æ€æŸ¥è¯¢
    size_t size() const;
    bool empty() const;
    
    // æ§åˆ¶æ“ä½œ
    void clear();
    void stop();
    void reset();
    
private:
    std::queue<T> queue_;                // åº•å±‚é˜Ÿåˆ—
    mutable std::mutex mutex_;           // äº’æ–¥é”
    std::condition_variable not_empty_;  // éç©ºæ¡ä»¶
    std::condition_variable not_full_;   // æœªæ»¡æ¡ä»¶
    size_t max_size_;                    // æœ€å¤§å®¹é‡
    bool stopped_;                       // åœæ­¢æ ‡å¿—
};
```

### ç”Ÿäº§è€…-æ¶ˆè´¹è€…æ¨¡å¼

```mermaid
sequenceDiagram
    participant P as ç”Ÿäº§è€…<br/>(é‡‡é›†çº¿ç¨‹)
    participant Q as ThreadSafeQueue
    participant C as æ¶ˆè´¹è€…<br/>(ç¼–ç çº¿ç¨‹)
    
    Note over P,C: åˆå§‹åŒ–é˜¶æ®µ
    P->>Q: åˆ›å»ºé˜Ÿåˆ—(å®¹é‡=30)
    C->>Q: å…±äº«é˜Ÿåˆ—å¼•ç”¨
    
    Note over P,C: è¿è¡Œé˜¶æ®µ
    par ç”Ÿäº§è€…å¾ªç¯
        loop æ¯16.67ms (60fps)
            P->>P: captureFrame()
            P->>Q: push(frame, 100ms)
            alt é˜Ÿåˆ—æœªæ»¡
                Q-->>P: true (æˆåŠŸ)
            else é˜Ÿåˆ—å·²æ»¡
                Note over P,Q: é˜»å¡ç­‰å¾…100ms
                alt è¶…æ—¶å‰æœ‰ç©ºé—´
                    Q-->>P: true
                else è¶…æ—¶
                    Q-->>P: false (ä¸¢å¸§)
                end
            end
        end
    and æ¶ˆè´¹è€…å¾ªç¯
        loop æŒç»­è¿è¡Œ
            C->>Q: pop(frame, 100ms)
            alt é˜Ÿåˆ—éç©º
                Q-->>C: true + frame
                C->>C: encodeFrame()
            else é˜Ÿåˆ—ä¸ºç©º
                Note over Q,C: é˜»å¡ç­‰å¾…100ms
                Q-->>C: false (è¶…æ—¶)
            end
        end
    end
    
    Note over P,C: åœæ­¢é˜¶æ®µ
    P->>Q: stop()
    Q->>P: å”¤é†’ç”Ÿäº§è€…
    Q->>C: å”¤é†’æ¶ˆè´¹è€…
```

---

## è¯¦ç»†å®ç°è§£æ

### push() æ–¹æ³•æ·±åº¦è§£æ

```cpp
template<typename T>
bool ThreadSafeQueue<T>::push(T value, std::chrono::milliseconds timeout) {
    // 1ï¸âƒ£ è·å–ç‹¬å é”
    std::unique_lock<std::mutex> lock(mutex_);
    
    // 2ï¸âƒ£ å¦‚æœæœ‰å®¹é‡é™åˆ¶,ç­‰å¾…é˜Ÿåˆ—æœ‰ç©ºé—´
    if (max_size_ > 0) {
        // ä½¿ç”¨æ¡ä»¶å˜é‡ç­‰å¾…,å¸¦è¶…æ—¶å’Œè°“è¯
        if (!not_full_.wait_for(lock, timeout, [this] { 
            return queue_.size() < max_size_ || stopped_; 
        })) {
            return false;  // â° è¶…æ—¶,è¿”å›å¤±è´¥
        }
    }
    
    // 3ï¸âƒ£ æ£€æŸ¥åœæ­¢æ ‡å¿—
    if (stopped_) {
        return false;  // ğŸ›‘ é˜Ÿåˆ—å·²åœæ­¢
    }
    
    // 4ï¸âƒ£ æ·»åŠ å…ƒç´  (ä½¿ç”¨ç§»åŠ¨è¯­ä¹‰,é¿å…æ‹·è´)
    queue_.push(std::move(value));
    
    // 5ï¸âƒ£ é€šçŸ¥ä¸€ä¸ªç­‰å¾…çš„æ¶ˆè´¹è€…
    not_empty_.notify_one();
    
    return true;  // âœ… æˆåŠŸ
}
```

#### å…³é”®ç‚¹è§£æ

**ä¸ºä»€ä¹ˆä½¿ç”¨ `wait_for()` è€Œä¸æ˜¯ `wait()`?**

```cpp
// âŒ é”™è¯¯: å¯èƒ½æ°¸ä¹…é˜»å¡
not_full_.wait(lock, [this] { return queue_.size() < max_size_; });

// âœ… æ­£ç¡®: è¶…æ—¶åè¿”å›,é¿å…æ­»é”
not_full_.wait_for(lock, timeout, [this] { 
    return queue_.size() < max_size_ || stopped_; 
});
```

**ä¸ºä»€ä¹ˆè°“è¯ä¸­æ£€æŸ¥ `stopped_`?**

å½“é˜Ÿåˆ—åœæ­¢æ—¶,å³ä½¿é˜Ÿåˆ—å·²æ»¡,ä¹Ÿè¦å”¤é†’ç­‰å¾…çš„çº¿ç¨‹,è®©å®ƒä»¬æ£€æŸ¥åœæ­¢æ ‡å¿—å¹¶é€€å‡ºã€‚

**ä¸ºä»€ä¹ˆä½¿ç”¨ `std::move()`?**

````carousel
**åœºæ™¯**: æ¨é€1080p BGRAå¸§ (~8MB)

```cpp
// âŒ æ‹·è´æ–¹å¼: è€—æ—¶çº¦10ms
FrameData frame = captureFrame();
queue.push(frame);  // æ‹·è´8MBæ•°æ®
```

**æ€§èƒ½**: 
- å†…å­˜æ‹·è´: 8MB
- è€—æ—¶: ~10ms
- CPUå ç”¨: é«˜

<!-- slide -->

**åœºæ™¯**: æ¨é€1080p BGRAå¸§ (~8MB)

```cpp
// âœ… ç§»åŠ¨æ–¹å¼: è€—æ—¶çº¦0.001ms
FrameData frame = captureFrame();
queue.push(std::move(frame));  // åªç§»åŠ¨æŒ‡é’ˆ
```

**æ€§èƒ½**:
- å†…å­˜æ‹·è´: 0å­—èŠ‚
- è€—æ—¶: ~0.001ms
- CPUå ç”¨: æä½

**æ€§èƒ½æå‡**: 10,000å€! ğŸš€
````

### pop() æ–¹æ³•æ·±åº¦è§£æ

```cpp
template<typename T>
bool ThreadSafeQueue<T>::pop(T& value, std::chrono::milliseconds timeout) {
    // 1ï¸âƒ£ è·å–ç‹¬å é”
    std::unique_lock<std::mutex> lock(mutex_);
    
    // 2ï¸âƒ£ ç­‰å¾…é˜Ÿåˆ—éç©º
    if (!not_empty_.wait_for(lock, timeout, [this] { 
        return !queue_.empty() || stopped_; 
    })) {
        return false;  // â° è¶…æ—¶
    }
    
    // 3ï¸âƒ£ å¦‚æœé˜Ÿåˆ—å·²åœæ­¢ä¸”ä¸ºç©º,è¿”å›å¤±è´¥
    if (stopped_ && queue_.empty()) {
        return false;  // ğŸ›‘ é˜Ÿåˆ—å·²åœæ­¢ä¸”æ— æ•°æ®
    }
    
    // 4ï¸âƒ£ å–å‡ºå…ƒç´  (ä½¿ç”¨ç§»åŠ¨è¯­ä¹‰)
    value = std::move(queue_.front());
    queue_.pop();
    
    // 5ï¸âƒ£ é€šçŸ¥ä¸€ä¸ªç­‰å¾…çš„ç”Ÿäº§è€…
    not_full_.notify_one();
    
    return true;  // âœ… æˆåŠŸ
}
```

### stop() æ–¹æ³• - ä¼˜é›…åœæ­¢çš„å…³é”®

```cpp
template<typename T>
void ThreadSafeQueue<T>::stop() {
    std::lock_guard<std::mutex> lock(mutex_);
    stopped_ = true;
    
    // ğŸ”” å”¤é†’æ‰€æœ‰ç­‰å¾…çš„çº¿ç¨‹
    not_empty_.notify_all();  // å”¤é†’æ‰€æœ‰æ¶ˆè´¹è€…
    not_full_.notify_all();   // å”¤é†’æ‰€æœ‰ç”Ÿäº§è€…
}
```

#### ä¼˜é›…åœæ­¢æµç¨‹

```mermaid
sequenceDiagram
    participant Main as ä¸»çº¿ç¨‹
    participant P as ç”Ÿäº§è€…çº¿ç¨‹<br/>(é˜»å¡åœ¨push)
    participant Q as ThreadSafeQueue
    participant C as æ¶ˆè´¹è€…çº¿ç¨‹<br/>(é˜»å¡åœ¨pop)
    
    Note over Main: å†³å®šåœæ­¢å½•åˆ¶
    Main->>Q: stop()
    
    activate Q
    Q->>Q: stopped_ = true
    Q->>P: notify_all() on not_full_
    Q->>C: notify_all() on not_empty_
    deactivate Q
    
    Note over P: è¢«å”¤é†’
    P->>P: æ£€æŸ¥stopped_ == true
    P->>P: é€€å‡ºå¾ªç¯
    
    Note over C: è¢«å”¤é†’
    C->>C: æ£€æŸ¥stopped_ == true
    C->>C: é€€å‡ºå¾ªç¯
    
    Note over Main: ç­‰å¾…çº¿ç¨‹ç»“æŸ
    Main->>P: join()
    Main->>C: join()
```

---

## å…³é”®æŠ€æœ¯æ·±åº¦è§£æ

### æ¡ä»¶å˜é‡çš„æ­£ç¡®ä½¿ç”¨

#### ä¸ºä»€ä¹ˆéœ€è¦ä¸¤ä¸ªæ¡ä»¶å˜é‡?

```mermaid
graph TB
    subgraph "ThreadSafeQueueå†…éƒ¨"
        Q[queue_<br/>åº•å±‚é˜Ÿåˆ—]
        M[mutex_<br/>äº’æ–¥é”]
        NE[not_empty_<br/>é˜Ÿåˆ—éç©ºæ¡ä»¶]
        NF[not_full_<br/>é˜Ÿåˆ—æœªæ»¡æ¡ä»¶]
    end
    
    subgraph "ç”Ÿäº§è€…"
        P[ç­‰å¾…é˜Ÿåˆ—æœ‰ç©ºé—´]
    end
    
    subgraph "æ¶ˆè´¹è€…"
        C[ç­‰å¾…é˜Ÿåˆ—æœ‰æ•°æ®]
    end
    
    P -.ç­‰å¾….-> NF
    NF -.æ£€æŸ¥.-> Q
    Q -.é€šçŸ¥.-> NE
    NE -.å”¤é†’.-> C
    
    style NE fill:#87CEEB
    style NF fill:#90EE90
```

**åŸå› **: ç”Ÿäº§è€…å’Œæ¶ˆè´¹è€…ç­‰å¾…ä¸åŒçš„æ¡ä»¶
- ç”Ÿäº§è€…ç­‰å¾…: é˜Ÿåˆ—æœªæ»¡ (`not_full_`)
- æ¶ˆè´¹è€…ç­‰å¾…: é˜Ÿåˆ—éç©º (`not_empty_`)

#### è™šå‡å”¤é†’é—®é¢˜

> [!WARNING]
> **è™šå‡å”¤é†’ (Spurious Wakeup)**
> 
> æ¡ä»¶å˜é‡å¯èƒ½åœ¨æ²¡æœ‰ `notify()` çš„æƒ…å†µä¸‹è¢«å”¤é†’!è¿™æ˜¯æ“ä½œç³»ç»Ÿçš„æ­£å¸¸è¡Œä¸ºã€‚

**è§£å†³æ–¹æ¡ˆ**: ä½¿ç”¨è°“è¯

```cpp
// âŒ é”™è¯¯: æ²¡æœ‰è°“è¯,è™šå‡å”¤é†’åæ¡ä»¶å¯èƒ½ä¸æ»¡è¶³
not_empty_.wait_for(lock, timeout);
if (queue_.empty()) {
    // ğŸ’¥ è™šå‡å”¤é†’,é˜Ÿåˆ—ä»ä¸ºç©º!
}

// âœ… æ­£ç¡®: ä½¿ç”¨è°“è¯,è‡ªåŠ¨é‡æ–°æ£€æŸ¥æ¡ä»¶
not_empty_.wait_for(lock, timeout, [this] { 
    return !queue_.empty() || stopped_; 
});
// ä¿è¯: è¿”å›æ—¶é˜Ÿåˆ—éç©º OR å·²åœæ­¢
```

### é”ç²’åº¦ä¼˜åŒ–

#### æœ€å°åŒ–é”æŒæœ‰æ—¶é—´

```cpp
// âŒ é”ç²’åº¦è¿‡å¤§
void badExample() {
    std::lock_guard<std::mutex> lock(mutex_);
    
    // åœ¨é”å†…è¿›è¡Œè€—æ—¶æ“ä½œ
    FrameData frame = expensiveOperation();  // 10ms
    queue_.push(std::move(frame));
    
    // é”æŒæœ‰æ—¶é—´: 10ms+ (å¤ªé•¿!)
}

// âœ… é”ç²’åº¦æœ€å°åŒ–
void goodExample() {
    // åœ¨é”å¤–è¿›è¡Œè€—æ—¶æ“ä½œ
    FrameData frame = expensiveOperation();  // 10ms
    
    {
        std::lock_guard<std::mutex> lock(mutex_);
        queue_.push(std::move(frame));
        // é”æŒæœ‰æ—¶é—´: < 0.001ms (æçŸ­!)
    }
}
```

---

## æ€§èƒ½ä¼˜åŒ–ç­–ç•¥

### é˜Ÿåˆ—å®¹é‡è®¾è®¡

#### å®¹é‡è®¡ç®—å…¬å¼

```
é˜Ÿåˆ—å®¹é‡ = ç¼“å†²æ—¶é•¿ (ç§’) Ã— å¸§ç‡ (fps)
å†…å­˜å ç”¨ = é˜Ÿåˆ—å®¹é‡ Ã— å•å¸§å¤§å°
```

#### ä¸åŒåœºæ™¯çš„æ¨èé…ç½®

````carousel
**åœºæ™¯: ä½å»¶è¿Ÿç›´æ’­**

```
å¸§ç‡: 60fps
ç¼“å†²æ—¶é•¿: 0.2ç§’
é˜Ÿåˆ—å®¹é‡: 12å¸§
```

**å†…å­˜å ç”¨** (1080p BGRA):
- å•å¸§: 1920Ã—1080Ã—4 = 8,294,400å­—èŠ‚ â‰ˆ 8MB
- æ€»è®¡: 12 Ã— 8MB = 96MB

**ä¼˜ç‚¹**: âœ… å»¶è¿Ÿä½ (200ms)  
**ç¼ºç‚¹**: âš ï¸ æ˜“ä¸¢å¸§ (ç¼–ç æŠ–åŠ¨æ—¶)

<!-- slide -->

**åœºæ™¯: å¹³è¡¡æ¨¡å¼ (æ¨è)**

```
å¸§ç‡: 60fps
ç¼“å†²æ—¶é•¿: 0.5ç§’
é˜Ÿåˆ—å®¹é‡: 30å¸§
```

**å†…å­˜å ç”¨** (1080p BGRA):
- å•å¸§: 8MB
- æ€»è®¡: 30 Ã— 8MB = 240MB

**ä¼˜ç‚¹**: âœ… å»¶è¿Ÿé€‚ä¸­ (500ms)  
**ä¼˜ç‚¹**: âœ… ä¸æ˜“ä¸¢å¸§  
**æ¨è**: â­â­â­â­â­

<!-- slide -->

**åœºæ™¯: é«˜å¯é å½•åˆ¶**

```
å¸§ç‡: 60fps
ç¼“å†²æ—¶é•¿: 1.0ç§’
é˜Ÿåˆ—å®¹é‡: 60å¸§
```

**å†…å­˜å ç”¨** (1080p BGRA):
- å•å¸§: 8MB
- æ€»è®¡: 60 Ã— 8MB = 480MB

**ä¼˜ç‚¹**: âœ… æå°‘ä¸¢å¸§  
**ç¼ºç‚¹**: âš ï¸ å»¶è¿Ÿé«˜ (1ç§’)  
**ç¼ºç‚¹**: âš ï¸ å†…å­˜å ç”¨å¤§
````

### æ€§èƒ½åŸºå‡†æµ‹è¯•

```cpp
#include <chrono>
#include <iostream>
#include "ThreadSafeQueue.h"

void benchmarkPushPop() {
    ThreadSafeQueue<std::vector<uint8_t>> queue(30);
    
    // æ¨¡æ‹Ÿ1080p BGRAå¸§
    std::vector<uint8_t> frame(1920 * 1080 * 4);
    
    const int iterations = 1000;
    auto start = std::chrono::high_resolution_clock::now();
    
    // æµ‹è¯•push
    for (int i = 0; i < iterations; ++i) {
        queue.push(frame, std::chrono::milliseconds(1000));
    }
    
    auto end = std::chrono::high_resolution_clock::now();
    auto duration = std::chrono::duration_cast<std::chrono::microseconds>(end - start);
    
    std::cout << "å¹³å‡pushæ—¶é—´: " << duration.count() / iterations 
              << " Î¼s/å¸§" << std::endl;
}
```

**é¢„æœŸç»“æœ**:
- æ— ç«äº‰: < 1 Î¼s/å¸§
- æœ‰ç«äº‰: < 100 Î¼s/å¸§

---

## å®æˆ˜ä½¿ç”¨æŒ‡å—

### åŸºæœ¬ä½¿ç”¨ç¤ºä¾‹

```cpp
#include "ThreadSafeQueue.h"
#include "FrameData.h"
#include <thread>
#include <memory>

int main() {
    // 1ï¸âƒ£ åˆ›å»ºå…±äº«é˜Ÿåˆ— (å®¹é‡30å¸§)
    auto queue = std::make_shared<ThreadSafeQueue<FrameData>>(30);
    
    // 2ï¸âƒ£ å¯åŠ¨ç”Ÿäº§è€…çº¿ç¨‹
    std::thread producer([queue]() {
        while (running) {
            FrameData frame = captureFrame();
            
            if (!queue->push(std::move(frame), std::chrono::milliseconds(100))) {
                std::cerr << "âš ï¸ ä¸¢å¸§: é˜Ÿåˆ—å·²æ»¡" << std::endl;
            }
        }
    });
    
    // 3ï¸âƒ£ å¯åŠ¨æ¶ˆè´¹è€…çº¿ç¨‹
    std::thread consumer([queue]() {
        while (running) {
            FrameData frame;
            
            if (queue->pop(frame, std::chrono::milliseconds(100))) {
                encodeFrame(frame);
            }
        }
    });
    
    // 4ï¸âƒ£ ç­‰å¾…ç”¨æˆ·åœæ­¢
    waitForStopSignal();
    
    // 5ï¸âƒ£ ä¼˜é›…åœæ­¢
    queue->stop();
    producer.join();
    consumer.join();
    
    return 0;
}
```

### ä¸å®é™…æ¨¡å—é›†æˆ

```cpp
class FrameGrabberThread {
public:
    FrameGrabberThread(
        std::shared_ptr<IScreenGrabber> grabber,
        std::shared_ptr<ThreadSafeQueue<FrameData>> queue
    ) : grabber_(grabber), queue_(queue) {}
    
    void run() {
        while (running_) {
            // é‡‡é›†å¸§
            FrameData frame = grabber_->captureFrame(100);
            if (!frame.data) continue;
            
            // æ¨é€åˆ°é˜Ÿåˆ—
            if (!queue_->push(std::move(frame), std::chrono::milliseconds(100))) {
                dropped_count_++;
                // é€šè¿‡Pybind11å›è°ƒé€šçŸ¥Pythonå±‚
                if (on_frame_dropped_) {
                    on_frame_dropped_(dropped_count_);
                }
            } else {
                frame_count_++;
            }
        }
    }
    
private:
    std::shared_ptr<IScreenGrabber> grabber_;
    std::shared_ptr<ThreadSafeQueue<FrameData>> queue_;
    int frame_count_ = 0;
    int dropped_count_ = 0;
    std::function<void(int)> on_frame_dropped_;  // Pybind11å›è°ƒ
};
```

---

## æµ‹è¯•ä¸éªŒè¯

### å•å…ƒæµ‹è¯•ç¤ºä¾‹

```cpp
#include <gtest/gtest.h>
#include "ThreadSafeQueue.h"

TEST(ThreadSafeQueueTest, BasicPushPop) {
    ThreadSafeQueue<int> queue(10);
    
    // æµ‹è¯•push
    EXPECT_TRUE(queue.push(42));
    EXPECT_EQ(queue.size(), 1);
    
    // æµ‹è¯•pop
    int value;
    EXPECT_TRUE(queue.pop(value));
    EXPECT_EQ(value, 42);
    EXPECT_TRUE(queue.empty());
}

TEST(ThreadSafeQueueTest, BlockingBehavior) {
    ThreadSafeQueue<int> queue(1);
    
    // å¡«æ»¡é˜Ÿåˆ—
    EXPECT_TRUE(queue.push(1));
    
    // æµ‹è¯•è¶…æ—¶
    auto start = std::chrono::steady_clock::now();
    EXPECT_FALSE(queue.push(2, std::chrono::milliseconds(100)));
    auto duration = std::chrono::steady_clock::now() - start;
    
    EXPECT_GE(duration, std::chrono::milliseconds(100));
}

TEST(ThreadSafeQueueTest, MultiThreaded) {
    ThreadSafeQueue<int> queue(100);
    std::atomic<int> produced{0};
    std::atomic<int> consumed{0};
    
    // ç”Ÿäº§è€…
    std::thread producer([&]() {
        for (int i = 0; i < 1000; ++i) {
            queue.push(i);
            produced++;
        }
    });
    
    // æ¶ˆè´¹è€…
    std::thread consumer([&]() {
        int value;
        while (consumed < 1000) {
            if (queue.pop(value, std::chrono::milliseconds(10))) {
                consumed++;
            }
        }
    });
    
    producer.join();
    consumer.join();
    
    EXPECT_EQ(produced, 1000);
    EXPECT_EQ(consumed, 1000);
}
```

### æµ‹è¯•æ£€æŸ¥æ¸…å•

- [ ] **åŸºæœ¬åŠŸèƒ½**: push/pop/size/empty/clear
- [ ] **é˜»å¡è¡Œä¸º**: é˜Ÿåˆ—æ»¡æ—¶é˜»å¡,é˜Ÿåˆ—ç©ºæ—¶é˜»å¡
- [ ] **è¶…æ—¶æœºåˆ¶**: è¶…æ—¶æ­£ç¡®è¿”å›
- [ ] **åœæ­¢æœºåˆ¶**: stop()å”¤é†’æ‰€æœ‰çº¿ç¨‹
- [ ] **å¹¶å‘å®‰å…¨**: å¤šçº¿ç¨‹æ— æ•°æ®ç«äº‰
- [ ] **æ€§èƒ½æµ‹è¯•**: æ»¡è¶³60fpsè¦æ±‚
- [ ] **å†…å­˜æµ‹è¯•**: æ— å†…å­˜æ³„æ¼

---

## æ€»ç»“

`ThreadSafeQueue<T>` æ˜¯è§†é¢‘æµå¤„ç†çš„æ ¸å¿ƒåŸºç¡€è®¾æ–½,å…³é”®ç‰¹æ€§:

âœ… **çº¿ç¨‹å®‰å…¨**: é€šè¿‡äº’æ–¥é”å’Œæ¡ä»¶å˜é‡ä¿è¯  
âœ… **é«˜æ€§èƒ½**: ç§»åŠ¨è¯­ä¹‰ + æœ€å°é”ç²’åº¦  
âœ… **çµæ´»é…ç½®**: æ”¯æŒæœ‰ç•Œ/æ— ç•Œé˜Ÿåˆ—  
âœ… **ä¼˜é›…åœæ­¢**: é¿å…æ­»é”,å®‰å…¨é€€å‡º

**ä¸‹ä¸€æ­¥**: åŸºäºæ­¤é˜Ÿåˆ—å®ç° [3.2.2 å¸§é‡‡é›†çº¿ç¨‹è®¾è®¡](file:///d:/ç¼–ç¨‹/é¡¹ç›®/AiVideoAnalsysSystem/.agent/ç¬¬ä¸‰ç« /3.2.2_å¸§é‡‡é›†çº¿ç¨‹è®¾è®¡.md)
