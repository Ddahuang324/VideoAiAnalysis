 
	## 3.3 写入控制架构设计
	> 本文档详细设计写入控制模块,包括 MediaWriter 类和视频分片策略的完整架构。___
	### 目录
	1. 架构概览
	2. MediaWriter 类设计
	3. 视频分片策略
	4. 文件管理系统
	5. 元数据管理
	6. 性能优化
	7. 错误处理
	### 一、架构概览
	#### 1.1 设计目标
	写入控制模块的核心目标:
	1. 可靠写入: 确保视频数据完整写入磁盘,防止数据丢失
	2. 分片管理: 支持视频分片,便于后续 AI 分析
	3. 元数据记录: 记录录制时间、分辨率、帧率等元信息
	4. 磁盘空间管理: 监控磁盘空间,防止写满
	5. 临时文件清理: 自动清理临时文件和失败的录制
	#### 1.2 整体架构图
	
	#### 1.3 写入流程
	### 二、MediaWriter 类设计
	#### 2.1 类定义
	```
#pragma once

#include <memory>

#include <string>

#include <vector>

#include <atomic>

#include <chrono>

extern "C" {

#include <libavformat/avformat.h>

}

/**

 * @brief 写入配置

 */

struct WriterConfig {

    std::string output_path;          // 最终输出文件路径

    std::string temp_dir = "temp";    // 临时目录



    // 分片配置

    bool enable_chunking = false;     // 是否启用分片

    int64_t chunk_duration_sec = 300; // 分片时长(秒),默认 5 分钟

    int64_t chunk_size_mb = 500;      // 分片大小(MB),默认 500MB



    // 磁盘空间配置

    int64_t min_free_space_mb = 1024; // 最小剩余空间(MB),默认 1GB

    bool auto_stop_on_low_space = true; // 空间不足时自动停止

};

/**

 * @brief 媒体写入器

 *

 * 负责将编码后的数据包写入文件,支持分片和元数据管理

 */

class MediaWriter {

public:

    MediaWriter();

    ~MediaWriter();



    /**

     * @brief 初始化写入器

     * @param config 写入配置

     * @return 成功返回 true

     */

    bool initialize(const WriterConfig& config);



    /**

     * @brief 写入数据包

     * @param packet 编码后的数据包

     * @return 成功返回 true

     */

    bool writePacket(AVPacket* packet);



    /**

     * @brief 完成写入

     * @return 最终输出文件路径

     */

    std::string finalize();



    /**

     * @brief 获取当前写入的字节数

     */

    int64_t getBytesWritten() const { return bytes_written_; }



    /**

     * @brief 获取当前分片索引

     */

    int getCurrentChunkIndex() const { return current_chunk_index_; }



    /**

     * @brief 获取剩余磁盘空间(MB)

     */

    int64_t getFreeDiskSpace() const;



    /**

     * @brief 获取最后一次错误

     */

    std::string getLastError() const { return last_error_; }



private:

    /**

     * @brief 检查是否需要创建新分片

     */

    bool shouldCreateNewChunk();



    /**

     * @brief 创建新分片

     */

    bool createNewChunk();



    /**

     * @brief 完成当前分片

     */

    bool finalizeCurrentChunk();



    /**

     * @brief 合并所有分片

     */

    bool mergeChunks();



    /**

     * @brief 检查磁盘空间

     */

    bool checkDiskSpace();



    /**

     * @brief 保存元数据

     */

    void saveMetadata();



    /**

     * @brief 清理临时文件

     */

    void cleanupTempFiles();



    WriterConfig config_;



    // FFmpeg 资源

    AVFormatContext* format_ctx_ = nullptr;

    AVStream* video_stream_ = nullptr;



    // 分片管理

    int current_chunk_index_ = 0;

    std::vector<std::string> chunk_paths_;

    std::chrono::steady_clock::time_point chunk_start_time_;

    int64_t chunk_bytes_written_ = 0;



    // 统计信息

    int64_t bytes_written_ = 0;

    int64_t packets_written_ = 0;

    std::chrono::steady_clock::time_point recording_start_time_;



    std::string last_error_;

    bool initialized_ = false;

};
```
	#### 2.2 核心实现
	#### 初始化
	```
bool MediaWriter::initialize(const WriterConfig& config) {

    config_ = config;



    // 创建临时目录

    if (config_.enable_chunking) {

        std::filesystem::create_directories(config_.temp_dir);

    }



    // 检查磁盘空间

    if (!checkDiskSpace()) {

        last_error_ = "磁盘空间不足";

        return false;

    }



    // 创建第一个分片或最终文件

    if (!createNewChunk()) {

        return false;

    }



    recording_start_time_ = std::chrono::steady_clock::now();

    initialized_ = true;



    return true;

}
```
	#### 写入数据包
	```
bool MediaWriter::writePacket(AVPacket* packet) {

    if (!initialized_) {

        last_error_ = "写入器未初始化";

        return false;

    }



    // 检查磁盘空间

    if (!checkDiskSpace()) {

        last_error_ = "磁盘空间不足";

        return false;

    }



    // 检查是否需要分片

    if (config_.enable_chunking && shouldCreateNewChunk()) {

        if (!finalizeCurrentChunk()) {

            return false;

        }

        if (!createNewChunk()) {

            return false;

        }

    }



    // 写入数据包

    int ret = av_interleaved_write_frame(format_ctx_, packet);

    if (ret < 0) {

        char errbuf[AV_ERROR_MAX_STRING_SIZE];

        av_strerror(ret, errbuf, sizeof(errbuf));

        last_error_ = std::string("写入数据包失败: ") + errbuf;

        return false;

    }



    // 更新统计

    bytes_written_ += packet->size;

    chunk_bytes_written_ += packet->size;

    packets_written_++;



    return true;

}
```
	#### 分片判断
	```
bool MediaWriter::shouldCreateNewChunk() {

    // 按时长分片

    auto now = std::chrono::steady_clock::now();

    auto duration = std::chrono::duration_cast<std::chrono::seconds>(

        now - chunk_start_time_

    ).count();



    if (duration >= config_.chunk_duration_sec) {

        return true;

    }



    // 按大小分片

    int64_t chunk_size_bytes = config_.chunk_size_mb * 1024 * 1024;

    if (chunk_bytes_written_ >= chunk_size_bytes) {

        return true;

    }



    return false;

}
```
	#### 创建新分片
	```
bool MediaWriter::createNewChunk() {

    // 生成分片文件名

    std::string chunk_path;

    if (config_.enable_chunking) {

        chunk_path = config_.temp_dir + "/chunk_" +

                     std::to_string(current_chunk_index_) + ".mp4";

    } else {

        chunk_path = config_.output_path;

    }



    // 分配格式上下文

    int ret = avformat_alloc_output_context2(&format_ctx_, nullptr, "mp4",

                                             chunk_path.c_str());

    if (ret < 0) {

        last_error_ = "分配格式上下文失败";

        return false;

    }



    // 创建视频流

    video_stream_ = avformat_new_stream(format_ctx_, nullptr);

    if (!video_stream_) {

        last_error_ = "创建视频流失败";

        return false;

    }



    // 打开输出文件

    ret = avio_open(&format_ctx_->pb, chunk_path.c_str(), AVIO_FLAG_WRITE);

    if (ret < 0) {

        last_error_ = "打开输出文件失败: " + chunk_path;

        return false;

    }



    // 写入文件头

    ret = avformat_write_header(format_ctx_, nullptr);

    if (ret < 0) {

        last_error_ = "写入文件头失败";

        return false;

    }



    // 记录分片信息

    chunk_paths_.push_back(chunk_path);

    chunk_start_time_ = std::chrono::steady_clock::now();

    chunk_bytes_written_ = 0;



    return true;

}
```
	#### 完成分片
	```
bool MediaWriter::finalizeCurrentChunk() {

    if (!format_ctx_) {

        return true;

    }



    // 写入文件尾

    av_write_trailer(format_ctx_);



    // 关闭文件

    if (format_ctx_->pb) {

        avio_closep(&format_ctx_->pb);

    }



    // 释放上下文

    avformat_free_context(format_ctx_);

    format_ctx_ = nullptr;

    video_stream_ = nullptr;



    current_chunk_index_++;



    return true;

}
```
	### 三、视频分片策略
	#### 3.1 分片方案对比
				方案
				优点
				缺点
				适用场景
				不分片
				简单,一个文件
				大文件难处理,失败全丢
				短时录制(< 10 分钟)
				按时长分片
				固定时长,易管理
				文件大小不均
				长时录制,AI 分析
				按大小分片
				文件大小均匀
				时长不固定
				存储管理优先
				混合分片
				兼顾时长和大小
				逻辑复杂
				生产环境
	TIP
	推荐方案: 按时长分片,每 5 分钟一个分片
	理由:
	1. AI 分析通常按时间段进行
	2. 5 分钟 @ 1080p60fps ≈ 300-500MB,大小适中
	3. 失败时只丢失最后一个分片
	#### 3.2 分片合并策略
	#### 合并实现
	```
bool MediaWriter::mergeChunks() {

    if (chunk_paths_.size() == 1) {

        // 只有一个分片,直接移动

        std::filesystem::rename(chunk_paths_[0], config_.output_path);

        return true;

    }



    // 生成 concat 列表文件

    std::string concat_file = config_.temp_dir + "/concat_list.txt";

    std::ofstream ofs(concat_file);



    for (const auto& path : chunk_paths_) {

        ofs << "file '" << std::filesystem::absolute(path).string() << "'\n";

    }

    ofs.close();



    // 使用 FFmpeg concat demuxer 合并

    std::string cmd = "ffmpeg -f concat -safe 0 -i " + concat_file +

                      " -c copy " + config_.output_path;



    int ret = std::system(cmd.c_str());

    if (ret != 0) {

        last_error_ = "合并分片失败";

        return false;

    }



    // 验证输出文件

    if (!std::filesystem::exists(config_.output_path)) {

        last_error_ = "输出文件不存在";

        return false;

    }



    return true;

}
```
	### 四、文件管理系统
	#### 4.1 目录结构
	```
project_root/

├── temp/                      # 临时目录

│   ├── chunk_0.mp4           # 分片 0

│   ├── chunk_1.mp4           # 分片 1

│   ├── chunk_N.mp4           # 分片 N

│   └── concat_list.txt       # 合并列表

├── records/                   # 输出目录

│   ├── 2024-12-11_20-30-00.mp4

│   ├── 2024-12-11_21-00-00.mp4

│   └── metadata/             # 元数据目录

│       ├── 2024-12-11_20-30-00.json

│       └── 2024-12-11_21-00-00.json

└── logs/                      # 日志目录

    └── recording.log
```
	#### 4.2 PathManager 类
	```
class PathManager {

public:

    static PathManager& instance() {

        static PathManager instance;

        return instance;

    }



    /**

     * @brief 初始化目录结构

     */

    bool initialize(const std::string& base_dir) {

        base_dir_ = base_dir;



        // 创建必要目录

        std::filesystem::create_directories(getTempDir());

        std::filesystem::create_directories(getRecordsDir());

        std::filesystem::create_directories(getMetadataDir());

        std::filesystem::create_directories(getLogsDir());



        return true;

    }



    /**

     * @brief 生成带时间戳的输出文件名

     */

    std::string generateOutputPath() {

        auto now = std::chrono::system_clock::now();

        auto time_t = std::chrono::system_clock::to_time_t(now);



        std::stringstream ss;

        ss << std::put_time(std::localtime(&time_t), "%Y-%m-%d_%H-%M-%S");



        return getRecordsDir() + "/" + ss.str() + ".mp4";

    }



    /**

     * @brief 获取对应的元数据文件路径

     */

    std::string getMetadataPath(const std::string& video_path) {

        std::filesystem::path p(video_path);

        std::string basename = p.stem().string();

        return getMetadataDir() + "/" + basename + ".json";

    }



    /**

     * @brief 清理过期的临时文件

     */

    void cleanupOldTempFiles(int max_age_hours = 24) {

        auto now = std::chrono::system_clock::now();



        for (const auto& entry : std::filesystem::directory_iterator(getTempDir())) {

            auto ftime = std::filesystem::last_write_time(entry);

            auto sctp = std::chrono::time_point_cast<std::chrono::system_clock::duration>(

                ftime - std::filesystem::file_time_type::clock::now() + now

            );



            auto age = std::chrono::duration_cast<std::chrono::hours>(now - sctp);



            if (age.count() > max_age_hours) {

                std::filesystem::remove(entry);

            }

        }

    }



    std::string getTempDir() const { return base_dir_ + "/temp"; }

    std::string getRecordsDir() const { return base_dir_ + "/records"; }

    std::string getMetadataDir() const { return base_dir_ + "/records/metadata"; }

    std::string getLogsDir() const { return base_dir_ + "/logs"; }



private:

    PathManager() = default;

    std::string base_dir_;

};
```
	### 五、元数据管理
	#### 5.1 元数据结构
	```
/**

 * @brief 录制元数据

 */

struct RecordingMetadata {

    // 基本信息

    std::string video_path;           // 视频文件路径

    std::string recording_id;         // 录制 ID (UUID)



    // 时间信息

    std::string start_time;           // 开始时间 (ISO 8601)

    std::string end_time;             // 结束时间

    int64_t duration_ms;              // 时长(毫秒)



    // 视频参数

    int width;                        // 宽度

    int height;                       // 高度

    int fps;                          // 帧率

    std::string codec;                // 编码器

    int64_t bitrate;                  // 码率



    // 统计信息

    int64_t total_frames;             // 总帧数

    int64_t file_size_bytes;          // 文件大小

    int chunk_count;                  // 分片数量



    // 分片信息

    struct ChunkInfo {

        int index;

        std::string path;

        int64_t size_bytes;

        int64_t duration_ms;

    };

    std::vector<ChunkInfo> chunks;



    /**

     * @brief 转换为 JSON

     */

    std::string toJson() const {

        nlohmann::json j;



        j["video_path"] = video_path;

        j["recording_id"] = recording_id;

        j["start_time"] = start_time;

        j["end_time"] = end_time;

        j["duration_ms"] = duration_ms;



        j["video"]["width"] = width;

        j["video"]["height"] = height;

        j["video"]["fps"] = fps;

        j["video"]["codec"] = codec;

        j["video"]["bitrate"] = bitrate;



        j["stats"]["total_frames"] = total_frames;

        j["stats"]["file_size_bytes"] = file_size_bytes;

        j["stats"]["chunk_count"] = chunk_count;



        j["chunks"] = nlohmann::json::array();

        for (const auto& chunk : chunks) {

            nlohmann::json chunk_json;

            chunk_json["index"] = chunk.index;

            chunk_json["path"] = chunk.path;

            chunk_json["size_bytes"] = chunk.size_bytes;

            chunk_json["duration_ms"] = chunk.duration_ms;

            j["chunks"].push_back(chunk_json);

        }



        return j.dump(4);  // 格式化输出

    }



    /**

     * @brief 从 JSON 加载

     */

    static RecordingMetadata fromJson(const std::string& json_str) {

        nlohmann::json j = nlohmann::json::parse(json_str);



        RecordingMetadata meta;

        meta.video_path = j["video_path"];

        meta.recording_id = j["recording_id"];

        // ... 解析其他字段



        return meta;

    }

};
```
	#### 5.2 元数据示例
	```
{

    "video_path": "/records/2024-12-11_20-30-00.mp4",

    "recording_id": "550e8400-e29b-41d4-a716-446655440000",

    "start_time": "2024-12-11T20:30:00+08:00",

    "end_time": "2024-12-11T20:45:30+08:00",

    "duration_ms": 930000,

    "video": {

        "width": 1920,

        "height": 1080,

        "fps": 60,

        "codec": "h264",

        "bitrate": 5000000

    },

    "stats": {

        "total_frames": 55800,

        "file_size_bytes": 581250000,

        "chunk_count": 3

    },

    "chunks": [

        {

            "index": 0,

            "path": "/temp/chunk_0.mp4",

            "size_bytes": 187500000,

            "duration_ms": 300000

        },

        {

            "index": 1,

            "path": "/temp/chunk_1.mp4",

            "size_bytes": 187500000,

            "duration_ms": 300000

        },

        {

            "index": 2,

            "path": "/temp/chunk_2.mp4",

            "size_bytes": 206250000,

            "duration_ms": 330000

        }

    ]

}
```
	### 六、性能优化
	#### 6.1 I/O 缓冲优化
	```
bool MediaWriter::createNewChunk() {

    // ... 前面的代码



    // 设置 I/O 缓冲区大小 (默认 32KB,增加到 1MB)

    const int buffer_size = 1024 * 1024;

    format_ctx_->pb->buffer_size = buffer_size;



    // 启用直接 I/O (跳过操作系统缓存)

    format_ctx_->pb->direct = 1;



    return true;

}
```
	#### 6.2 异步写入
	```
class AsyncMediaWriter {

public:

    AsyncMediaWriter() {

        write_thread_ = std::thread(&AsyncMediaWriter::writeLoop, this);

    }



    ~AsyncMediaWriter() {

        stop();

        if (write_thread_.joinable()) {

            write_thread_.join();

        }

    }



    void writePacketAsync(AVPacket* packet) {

        // 复制数据包

        AVPacket* pkt_copy = av_packet_clone(packet);



        // 推送到队列

        packet_queue_.push(pkt_copy, std::chrono::milliseconds(100));

    }



private:

    void writeLoop() {

        while (running_) {

            AVPacket* packet = nullptr;



            if (packet_queue_.pop(packet, std::chrono::milliseconds(100))) {

                writer_.writePacket(packet);

                av_packet_free(&packet);

            }

        }

    }



    MediaWriter writer_;

    ThreadSafeQueue<AVPacket*> packet_queue_;

    std::thread write_thread_;

    std::atomic<bool> running_{true};

};
```
	### 七、错误处理
	#### 7.1 磁盘空间检查
	```
bool MediaWriter::checkDiskSpace() {

    auto space_info = std::filesystem::space(config_.output_path);

    int64_t free_mb = space_info.available / (1024 * 1024);



    if (free_mb < config_.min_free_space_mb) {

        if (config_.auto_stop_on_low_space) {

            last_error_ = "磁盘空间不足,自动停止录制";

            return false;

        }

    }



    return true;

}
```
	#### 7.2 写入失败恢复
	```
bool MediaWriter::writePacket(AVPacket* packet) {

    int retry_count = 0;

    const int MAX_RETRIES = 3;



    while (retry_count < MAX_RETRIES) {

        int ret = av_interleaved_write_frame(format_ctx_, packet);



        if (ret >= 0) {

            return true;  // 成功

        }



        // 检查错误类型

        if (ret == AVERROR(ENOSPC)) {

            // 磁盘空间不足,无法恢复

            last_error_ = "磁盘空间不足";

            return false;

        }



        // 其他错误,重试

        retry_count++;

        std::this_thread::sleep_for(std::chrono::milliseconds(100));

    }



    last_error_ = "写入失败,已重试 " + std::to_string(MAX_RETRIES) + " 次";

    return false;

}
```
	### 八、总结
	#### 8.1 设计要点
	1. 可靠写入: I/O 缓冲优化 + 错误重试机制
	2. 分片管理: 按时长分片,FFmpeg concat 合并
	3. 元数据记录: JSON 格式,包含完整录制信息
	4. 磁盘管理: 空间检查 + 自动清理临时文件
	5. 性能优化: 异步写入 + 直接 I/O
	#### 8.2 关键指标
				指标
				目标值
				实现方式
				写入延迟
				< 10ms
				I/O 缓冲 1MB
				分片时长
				5 分钟
				时长检查
				磁盘占用
				自动清理
				定期清理 24 小时前的临时文件
				数据可靠性
				99.9%
				错误重试 + 分片备份
	### 附录: 完整类图
	
	
	
	
	