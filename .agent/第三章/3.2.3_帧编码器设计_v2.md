# 3.2.3 å¸§ç¼–ç å™¨è®¾è®¡ (ä¼˜åŒ–ç‰ˆ)

> **æ¶ˆè´¹è€…æ ¸å¿ƒä¸FFmpegæ·±åº¦é›†æˆ**  
> `FrameEncoder` æ˜¯è§†é¢‘æµå¤„ç†çš„æ¶ˆè´¹è€…ï¼Œè´Ÿè´£ä»é˜Ÿåˆ—ä¸­å–å‡ºåŸå§‹å¸§æ•°æ®ï¼Œé€šè¿‡ `FFmpegWrapper` è¿›è¡Œåƒç´ æ ¼å¼è½¬æ¢å’ŒH.264ç¼–ç ï¼Œæœ€ç»ˆå†™å…¥è§†é¢‘æ–‡ä»¶ã€‚æœ¬æ–‡æ¡£è¯¦è§£å…¶è®¾è®¡åŸç†ã€**FFmpegWrapper RAIIå°è£…è®¾è®¡**ã€FFmpegé›†æˆå’Œæ€§èƒ½ä¼˜åŒ–ç­–ç•¥ã€‚

---

## ğŸ“‹ ç›®å½•

1. [æ¨¡å—æ¦‚è¿°ä¸å®šä½](#æ¨¡å—æ¦‚è¿°ä¸å®šä½)
2. [è®¾è®¡ç›®æ ‡ä¸æŒ‘æˆ˜](#è®¾è®¡ç›®æ ‡ä¸æŒ‘æˆ˜)
3. [æ ¸å¿ƒæ¶æ„è®¾è®¡](#æ ¸å¿ƒæ¶æ„è®¾è®¡)
4. [FFmpegWrapper è¯¦ç»†è®¾è®¡](#ffmpegwrapper-è¯¦ç»†è®¾è®¡) â­ **æ–°å¢**
5. [è¯¦ç»†å®ç°è§£æ](#è¯¦ç»†å®ç°è§£æ)
6. [åƒç´ æ ¼å¼è½¬æ¢](#åƒç´ æ ¼å¼è½¬æ¢)
7. [FFmpegç¼–ç æµç¨‹](#ffmpegç¼–ç æµç¨‹)
8. [Pybind11å›è°ƒæœºåˆ¶](#pybind11å›è°ƒæœºåˆ¶)
9. [æ€§èƒ½ä¼˜åŒ–ç­–ç•¥](#æ€§èƒ½ä¼˜åŒ–ç­–ç•¥)
10. [å®æˆ˜ä½¿ç”¨æŒ‡å—](#å®æˆ˜ä½¿ç”¨æŒ‡å—)

---

## æ¨¡å—æ¦‚è¿°ä¸å®šä½

### åœ¨ç³»ç»Ÿä¸­çš„ä½ç½®

```mermaid
graph TB
    subgraph "C++æ ¸å¿ƒå±‚"
        Queue[ThreadSafeQueue<br/>å¸§é˜Ÿåˆ—]
        Encoder[FrameEncoder<br/>ç¼–ç çº¿ç¨‹]
        FFmpeg[FFmpegWrapper<br/>ç¼–ç å™¨å°è£…]
        Sws[SwsContext<br/>åƒç´ è½¬æ¢]
    end
    
    subgraph "Pythonä¸šåŠ¡å±‚"
        Service[VideoService<br/>è§†é¢‘æœåŠ¡]
        Callback[å›è°ƒå‡½æ•°<br/>è¿›åº¦/å®Œæˆé€šçŸ¥]
    end
    
    subgraph "æ–‡ä»¶ç³»ç»Ÿ"
        File[è¾“å‡ºè§†é¢‘<br/>output.mp4]
    end
    
    Queue -->|pop| Encoder
    Encoder -->|FrameData| FFmpeg
    FFmpeg -->|BGRAâ†’YUV| Sws
    Sws -->|YUV420P| FFmpeg
    FFmpeg -->|AVPacket| File
    Encoder -.Pybind11å›è°ƒ.-> Callback
    Callback --> Service
    
    style Encoder fill:#90EE90,stroke:#333,stroke-width:3px
    style FFmpeg fill:#FFB6C1,stroke:#333,stroke-width:2px
    style Callback fill:#FFA500
```

### æ ¸å¿ƒèŒè´£

| èŒè´£ | è¯´æ˜ | æŠ€æœ¯å®ç° |
|------|------|---------|
| **é˜Ÿåˆ—æ¶ˆè´¹** | ä»ThreadSafeQueueå–å¸§ | é˜»å¡å¼pop,è¶…æ—¶100ms |
| **æ ¼å¼è½¬æ¢** | BGRA â†’ YUV420P | libswscale (`sws_scale`) |
| **è§†é¢‘ç¼–ç ** | H.264ç¼–ç  | libavcodec (x264) |
| **æ–‡ä»¶å†™å…¥** | å†™å…¥MP4å®¹å™¨ | libavformat |
| **è¿›åº¦é€šçŸ¥** | é€šçŸ¥Pythonå±‚ | Pybind11å›è°ƒ + GIL |
| **èµ„æºç®¡ç†** | RAIIèµ„æºå°è£… | FFmpegWrapper æ™ºèƒ½æŒ‡é’ˆ |

### æ¨¡å—ä¾èµ–å…³ç³»

```mermaid
graph LR
    subgraph "FrameEncoder æ¨¡å—"
        FE[FrameEncoder]
    end
    
    subgraph "ä¾èµ–ç»„ä»¶"
        TSQ[ThreadSafetyQueue]
        FFW[FFmpegWrapper]
        FD[FrameData]
        EC[EncoderConfig]
    end
    
    subgraph "FFmpegWrapper å†…éƒ¨ä¾èµ–"
        AFC[AVFormatContext]
        ACC[AVCodecContext]
        AVF[AVFrame]
        SWS[SwsContext]
    end
    
    FE --> TSQ
    FE --> FFW
    FE --> FD
    FE --> EC
    
    FFW --> AFC
    FFW --> ACC
    FFW --> AVF
    FFW --> SWS
    
    style FFW fill:#FFB6C1,stroke:#333,stroke-width:2px
```

---

## è®¾è®¡ç›®æ ‡ä¸æŒ‘æˆ˜

### æ ¸å¿ƒè®¾è®¡ç›®æ ‡

```mermaid
mindmap
  root((FrameEncoder))
    é«˜æ€§èƒ½ç¼–ç 
      æ”¯æŒ60fpså®æ—¶ç¼–ç 
      CPUå ç”¨ < 30%
      ç¡¬ä»¶åŠ é€Ÿæ”¯æŒ
    é«˜è´¨é‡è¾“å‡º
      H.264ç¼–ç 
      CRFè´¨é‡æ§åˆ¶
      ç ç‡è‡ªé€‚åº”
    å¯é æ€§
      ç¼–ç é”™è¯¯æ¢å¤
      æ–‡ä»¶å®Œæ•´æ€§ä¿è¯
      ä¼˜é›…åœæ­¢
    å¯è§‚æµ‹æ€§
      ç¼–ç è¿›åº¦é€šçŸ¥
      æ–‡ä»¶å¤§å°ç»Ÿè®¡
      æ€§èƒ½æŒ‡æ ‡ç›‘æ§
    èµ„æºå®‰å…¨
      RAIIå†…å­˜ç®¡ç†
      å¼‚å¸¸å®‰å…¨ä¿è¯
      é›¶å†…å­˜æ³„æ¼
```

### æŠ€æœ¯æŒ‘æˆ˜

| æŒ‘æˆ˜ | é—®é¢˜ | è§£å†³æ–¹æ¡ˆ |
|------|------|---------|
| **æ ¼å¼è½¬æ¢** | BGRAâ†’YUV420Pè€—æ—¶ | `sws_scale` ç¡¬ä»¶åŠ é€Ÿ + SIMD |
| **ç¼–ç å»¶è¿Ÿ** | H.264ç¼–ç æ…¢äºé‡‡é›† | é˜Ÿåˆ—ç¼“å†² + ç¼–ç å‚æ•°ä¼˜åŒ– |
| **å†…å­˜ç®¡ç†** | AVFrame/AVPacketæ³„æ¼ | **FFmpegWrapper RAIIå°è£…** |
| **GILé˜»å¡** | Pythonå›è°ƒå½±å“æ€§èƒ½ | å¼‚æ­¥é€šçŸ¥ + æ‰¹é‡å›è°ƒ |
| **èµ„æºé‡Šæ”¾é¡ºåº** | FFmpegèµ„æºä¾èµ–å…³ç³»å¤æ‚ | è‡ªå®šä¹‰åˆ é™¤å™¨ + æ­£ç¡®é‡Šæ”¾é¡ºåº |

---

## æ ¸å¿ƒæ¶æ„è®¾è®¡

### ç±»ç»“æ„æ€»è§ˆ

```mermaid
classDiagram
    class FrameEncoder {
        -shared_ptr~ThreadSafeQueue~ queue_
        -unique_ptr~FFmpegWrapper~ encoder_
        -unique_ptr~thread~ thread_
        -EncoderConfig config_
        -atomic~bool~ running_
        -atomic~int64_t~ encoded_count_
        +start() void
        +stop() void
        +getEncodedCount() int64_t
        +getOutputFileSize() int64_t
        +isRunning() bool
        +setProgressCallback(callback) void
        +setFinishedCallback(callback) void
        +setErrorCallback(callback) void
        -encodeLoop() void
        -processFrame(frame) bool
        -notifyProgress() void
        -notifyFinished() void
        -notifyError(error) void
    }
    
    class FFmpegWrapper {
        -AVFormatContextPtr format_ctx_
        -AVCodecContextPtr codec_ctx_
        -AVFramePtr yuv_frame_
        -SwsContextPtr sws_ctx_
        -AVStreamPtr video_stream_
        -string last_error_
        -int64_t frame_count_
        +initialize(config) bool
        +encodeFrame(frame_data) bool
        +finalize() void
        +getOutputFileSize() int64_t
        +getLastError() string
        -createOutputFile(path) bool
        -configureEncoder() bool
        -convertPixelFormat(src, dst) bool
        -writePacket(pkt) bool
    }
    
    class EncoderConfig {
        +string output_path
        +int width
        +int height
        +int fps
        +int bitrate
        +int crf
        +string preset
        +string codec
        +defaultConfig()$ EncoderConfig
    }
    
    class ThreadSafetyQueue~T~ {
        +push(value, timeout) bool
        +pop(value, timeout) bool
        +size() size_t
        +stop() void
    }
    
    FrameEncoder --> FFmpegWrapper : ç»„åˆ
    FrameEncoder --> ThreadSafetyQueue : å…³è”
    FrameEncoder --> EncoderConfig : ä¾èµ–
    FFmpegWrapper --> EncoderConfig : ä¾èµ–
```

### FrameEncoder ç±»å®šä¹‰

```cpp
#pragma once

#include <thread>
#include <atomic>
#include <memory>
#include <functional>

#include "ThreadSafetyQueue.h"
#include "IScreenGrabber.h"  // FrameDataå®šä¹‰
#include "FFmpegWrapper.h"

/**
 * @brief å¸§ç¼–ç å™¨
 * 
 * ä»é˜Ÿåˆ—ä¸­å–å‡ºå¸§,è¿›è¡Œåƒç´ æ ¼å¼è½¬æ¢å’ŒH.264ç¼–ç 
 */
class FrameEncoder {
public:
    /**
     * @brief æ„é€ å‡½æ•°
     * @param queue å¸§é˜Ÿåˆ—
     * @param config ç¼–ç å™¨é…ç½®
     */
    FrameEncoder(
        std::shared_ptr<ThreadSafetyQueue<FrameData>> queue,
        const EncoderConfig& config
    );
    
    ~FrameEncoder();
    
    // ç¦æ­¢æ‹·è´
    FrameEncoder(const FrameEncoder&) = delete;
    FrameEncoder& operator=(const FrameEncoder&) = delete;
    
    /**
     * @brief å¯åŠ¨ç¼–ç çº¿ç¨‹
     */
    void start();
    
    /**
     * @brief åœæ­¢ç¼–ç çº¿ç¨‹
     */
    void stop();
    
    /**
     * @brief è·å–ç»Ÿè®¡ä¿¡æ¯
     */
    int64_t getEncodedCount() const { return encoded_count_; }
    int64_t getOutputFileSize() const;
    bool isRunning() const { return running_; }
    
    // Pybind11å›è°ƒå‡½æ•°ç±»å‹
    using ProgressCallback = std::function<void(int64_t, int64_t)>;
    using FinishedCallback = std::function<void(int64_t, const std::string&)>;
    using ErrorCallback = std::function<void(const std::string&)>;
    
    /**
     * @brief è®¾ç½®å›è°ƒå‡½æ•°
     */
    void setProgressCallback(ProgressCallback callback) {
        on_progress_ = callback;
    }
    void setFinishedCallback(FinishedCallback callback) {
        on_finished_ = callback;
    }
    void setErrorCallback(ErrorCallback callback) {
        on_error_ = callback;
    }
    
private:
    /**
     * @brief ç¼–ç å¾ªç¯ (åœ¨ç‹¬ç«‹çº¿ç¨‹ä¸­è¿è¡Œ)
     */
    void encodeLoop();
    
    /**
     * @brief å¤„ç†ä¸€å¸§
     */
    bool processFrame(const FrameData& frame);
    
    /**
     * @brief è°ƒç”¨Pythonå›è°ƒ
     */
    void notifyProgress();
    void notifyFinished();
    void notifyError(const std::string& error);
    
    // æ ¸å¿ƒç»„ä»¶
    std::shared_ptr<ThreadSafetyQueue<FrameData>> queue_;
    std::unique_ptr<FFmpegWrapper> encoder_;  // FFmpeg RAIIå°è£…
    std::unique_ptr<std::thread> thread_;
    EncoderConfig config_;
    
    // çŠ¶æ€æ ‡å¿—
    std::atomic<bool> running_{false};
    
    // ç»Ÿè®¡ä¿¡æ¯
    std::atomic<int64_t> encoded_count_{0};
    
    // Pythonå›è°ƒ
    ProgressCallback on_progress_;
    FinishedCallback on_finished_;
    ErrorCallback on_error_;
};
```

### ç¼–ç å™¨é…ç½®

```cpp
struct EncoderConfig {
    std::string output_path;        // è¾“å‡ºæ–‡ä»¶è·¯å¾„
    int width;                       // è§†é¢‘å®½åº¦
    int height;                      // è§†é¢‘é«˜åº¦
    int fps;                         // å¸§ç‡
    int bitrate;                     // ç ç‡ (bps)
    int crf;                         // è´¨é‡å‚æ•° (0-51, é»˜è®¤23)
    std::string preset;              // ç¼–ç é¢„è®¾ (ultrafast/fast/medium/slow)
    std::string codec;               // ç¼–ç å™¨ (libx264/h264_nvenc)
    
    // é»˜è®¤é…ç½®
    static EncoderConfig defaultConfig() {
        return {
            .output_path = "output.mp4",
            .width = 1920,
            .height = 1080,
            .fps = 60,
            .bitrate = 8000000,  // 8Mbps
            .crf = 23,
            .preset = "fast",
            .codec = "libx264"
        };
    }
};
```

---

## FFmpegWrapper è¯¦ç»†è®¾è®¡

> [!IMPORTANT]
> **æ ¸å¿ƒè®¾è®¡ç†å¿µ**  
> `FFmpegWrapper` æ˜¯å¯¹FFmpegç¼–ç åŠŸèƒ½çš„RAIIå°è£…ï¼Œè§£å†³äº†FFmpeg C APIèµ„æºç®¡ç†çš„ç—›ç‚¹ï¼Œç¡®ä¿å¼‚å¸¸å®‰å…¨å’Œé›¶å†…å­˜æ³„æ¼ã€‚

### è®¾è®¡ç›®æ ‡

```mermaid
graph TB
    subgraph "FFmpegWrapper è®¾è®¡ç›®æ ‡"
        A[èµ„æºå®‰å…¨] --> A1[RAIIè‡ªåŠ¨é‡Šæ”¾]
        A --> A2[å¼‚å¸¸å®‰å…¨ä¿è¯]
        A --> A3[æ­£ç¡®é‡Šæ”¾é¡ºåº]
        
        B[æ¥å£ç®€åŒ–] --> B1[éšè—FFmpegå¤æ‚æ€§]
        B --> B2[ç»Ÿä¸€é”™è¯¯å¤„ç†]
        B --> B3[ç®€æ´APIè®¾è®¡]
        
        C[é«˜æ€§èƒ½] --> C1[é›¶æ‹·è´ä¼˜åŒ–]
        C --> C2[ç¼“å†²åŒºå¤ç”¨]
        C --> C3[ç¼–ç å‚æ•°è°ƒä¼˜]
        
        D[å¯æ‰©å±•æ€§] --> D1[æ”¯æŒå¤šç§ç¼–ç å™¨]
        D --> D2[ç¡¬ä»¶åŠ é€ŸæŠ½è±¡]
        D --> D3[é…ç½®çµæ´»æ€§]
    end
    
    style A fill:#90EE90
    style B fill:#87CEEB
    style C fill:#FFB6C1
    style D fill:#DDA0DD
```

### ç±»å®šä¹‰

```cpp
#pragma once

extern "C" {
#include <libavformat/avformat.h>
#include <libavcodec/avcodec.h>
#include <libswscale/swscale.h>
#include <libavutil/opt.h>
#include <libavutil/imgutils.h>
}

#include <memory>
#include <string>
#include <functional>
#include "IScreenGrabber.h"  // FrameData

// å‰å‘å£°æ˜
struct EncoderConfig;

/**
 * @brief FFmpeg RAIIå°è£…ç±»
 * 
 * å°è£…FFmpegç¼–ç æµç¨‹ï¼Œæä¾›å®‰å…¨çš„èµ„æºç®¡ç†å’Œç®€æ´çš„æ¥å£
 * 
 * @design è®¾è®¡åŸåˆ™ï¼š
 *   1. RAIIï¼šæ‰€æœ‰FFmpegèµ„æºä½¿ç”¨æ™ºèƒ½æŒ‡é’ˆç®¡ç†
 *   2. å•ä¸€èŒè´£ï¼šåªè´Ÿè´£ç¼–ç ï¼Œä¸å¤„ç†é‡‡é›†æˆ–ä¸šåŠ¡é€»è¾‘
 *   3. å¼‚å¸¸å®‰å…¨ï¼šæ‰€æœ‰æ“ä½œä¿è¯å¼ºå¼‚å¸¸å®‰å…¨
 */
class FFmpegWrapper {
public:
    FFmpegWrapper();
    ~FFmpegWrapper();
    
    // ç¦æ­¢æ‹·è´ï¼ˆèµ„æºéå¯å¤åˆ¶ï¼‰
    FFmpegWrapper(const FFmpegWrapper&) = delete;
    FFmpegWrapper& operator=(const FFmpegWrapper&) = delete;
    
    // å…è®¸ç§»åŠ¨
    FFmpegWrapper(FFmpegWrapper&&) noexcept;
    FFmpegWrapper& operator=(FFmpegWrapper&&) noexcept;
    
    /**
     * @brief åˆå§‹åŒ–ç¼–ç å™¨
     * @param config ç¼–ç é…ç½®
     * @return æˆåŠŸè¿”å›true
     */
    bool initialize(const EncoderConfig& config);
    
    /**
     * @brief ç¼–ç ä¸€å¸§
     * @param frame_data åŸå§‹å¸§æ•°æ® (BGRAæ ¼å¼)
     * @return æˆåŠŸè¿”å›true
     */
    bool encodeFrame(const FrameData& frame_data);
    
    /**
     * @brief å®Œæˆç¼–ç å¹¶å…³é—­æ–‡ä»¶
     */
    void finalize();
    
    /**
     * @brief è·å–è¾“å‡ºæ–‡ä»¶å¤§å°
     */
    int64_t getOutputFileSize() const;
    
    /**
     * @brief è·å–æœ€åçš„é”™è¯¯ä¿¡æ¯
     */
    std::string getLastError() const { return last_error_; }
    
    /**
     * @brief æ£€æŸ¥æ˜¯å¦å·²åˆå§‹åŒ–
     */
    bool isInitialized() const { return initialized_; }
    
private:
    // ========== è‡ªå®šä¹‰åˆ é™¤å™¨ ==========
    
    /**
     * @brief AVFormatContext åˆ é™¤å™¨
     * @note å¿…é¡»å…ˆå…³é—­I/Oï¼Œå†é‡Šæ”¾ä¸Šä¸‹æ–‡
     */
    struct AVFormatContextDeleter {
        void operator()(AVFormatContext* ctx) {
            if (ctx) {
                if (ctx->pb) {
                    avio_closep(&ctx->pb);
                }
                avformat_free_context(ctx);
            }
        }
    };
    
    /**
     * @brief AVCodecContext åˆ é™¤å™¨
     */
    struct AVCodecContextDeleter {
        void operator()(AVCodecContext* ctx) {
            if (ctx) {
                avcodec_free_context(&ctx);
            }
        }
    };
    
    /**
     * @brief AVFrame åˆ é™¤å™¨
     */
    struct AVFrameDeleter {
        void operator()(AVFrame* frame) {
            if (frame) {
                av_frame_free(&frame);
            }
        }
    };
    
    /**
     * @brief SwsContext åˆ é™¤å™¨
     */
    struct SwsContextDeleter {
        void operator()(SwsContext* ctx) {
            if (ctx) {
                sws_freeContext(ctx);
            }
        }
    };
    
    /**
     * @brief AVPacket åˆ é™¤å™¨
     */
    struct AVPacketDeleter {
        void operator()(AVPacket* pkt) {
            if (pkt) {
                av_packet_free(&pkt);
            }
        }
    };
    
    // ========== æ™ºèƒ½æŒ‡é’ˆç±»å‹åˆ«å ==========
    using AVFormatContextPtr = std::unique_ptr<AVFormatContext, AVFormatContextDeleter>;
    using AVCodecContextPtr = std::unique_ptr<AVCodecContext, AVCodecContextDeleter>;
    using AVFramePtr = std::unique_ptr<AVFrame, AVFrameDeleter>;
    using SwsContextPtr = std::unique_ptr<SwsContext, SwsContextDeleter>;
    using AVPacketPtr = std::unique_ptr<AVPacket, AVPacketDeleter>;
    
    // ========== ç§æœ‰æ–¹æ³• ==========
    
    /**
     * @brief åˆ›å»ºè¾“å‡ºæ–‡ä»¶
     */
    bool createOutputFile(const std::string& path);
    
    /**
     * @brief é…ç½®ç¼–ç å™¨å‚æ•°
     */
    bool configureEncoder(const EncoderConfig& config);
    
    /**
     * @brief åƒç´ æ ¼å¼è½¬æ¢ BGRA -> YUV420P
     */
    bool convertPixelFormat(const FrameData& src, AVFrame* dst);
    
    /**
     * @brief å†™å…¥ç¼–ç åçš„æ•°æ®åŒ…
     */
    bool writePacket(AVPacket* pkt);
    
    /**
     * @brief åˆ·æ–°ç¼–ç å™¨ç¼“å†²åŒº
     */
    void flushEncoder();
    
    /**
     * @brief é‡Šæ”¾æ‰€æœ‰èµ„æº
     */
    void cleanup();
    
    // ========== æˆå‘˜å˜é‡ ==========
    
    // FFmpeg ä¸Šä¸‹æ–‡ (æŒ‰é‡Šæ”¾é¡ºåºæ’åˆ—)
    AVFormatContextPtr format_ctx_;    // æ ¼å¼ä¸Šä¸‹æ–‡ (æœ€åé‡Šæ”¾)
    AVCodecContextPtr codec_ctx_;      // ç¼–ç å™¨ä¸Šä¸‹æ–‡
    AVFramePtr yuv_frame_;             // YUVå¸§ç¼“å†² (å¤ç”¨)
    SwsContextPtr sws_ctx_;            // åƒç´ è½¬æ¢ä¸Šä¸‹æ–‡
    AVPacketPtr packet_;               // æ•°æ®åŒ…ç¼“å†² (å¤ç”¨)
    
    AVStream* video_stream_ = nullptr; // è§†é¢‘æµ (ç”±format_ctx_ç®¡ç†)
    
    // çŠ¶æ€
    bool initialized_ = false;
    std::string last_error_;
    std::string output_path_;
    int64_t frame_count_ = 0;
    
    // é…ç½®å¤‡ä»½
    int width_ = 0;
    int height_ = 0;
};
```

### RAII èµ„æºç®¡ç†è®¾è®¡

```mermaid
graph TB
    subgraph "èµ„æºç”Ÿå‘½å‘¨æœŸ"
        A[æ„é€  FFmpegWrapper] --> B[è°ƒç”¨ initialize]
        B --> C[åˆ†é… AVFormatContext]
        C --> D[åˆ†é… AVCodecContext]
        D --> E[åˆ†é… AVFrame]
        E --> F[åˆ†é… SwsContext]
        F --> G[ç¼–ç è¿è¡Œä¸­...]
        
        G --> H[è°ƒç”¨ finalize æˆ– ææ„]
        H --> I[é‡Šæ”¾ SwsContext]
        I --> J[é‡Šæ”¾ AVFrame]
        J --> K[é‡Šæ”¾ AVCodecContext]
        K --> L[å…³é—­ avio]
        L --> M[é‡Šæ”¾ AVFormatContext]
    end
    
    style A fill:#90EE90
    style H fill:#FFB6C1
    style L fill:#FFA500
```

> [!WARNING]
> **èµ„æºé‡Šæ”¾é¡ºåºè‡³å…³é‡è¦ï¼**
> 
> FFmpeg èµ„æºä¹‹é—´å­˜åœ¨ä¾èµ–å…³ç³»ï¼Œå¿…é¡»æŒ‰æ­£ç¡®é¡ºåºé‡Šæ”¾ï¼š
> 1. å…ˆé‡Šæ”¾ SwsContextï¼ˆæ— ä¾èµ–ï¼‰
> 2. é‡Šæ”¾ AVFrameï¼ˆæ— ä¾èµ–ï¼‰  
> 3. é‡Šæ”¾ AVCodecContextï¼ˆæ— ä¾èµ–ï¼‰
> 4. **å…ˆå…³é—­ avio**ï¼ˆ`avio_closep`ï¼‰
> 5. æœ€åé‡Šæ”¾ AVFormatContext

### FFmpegWrapper åˆå§‹åŒ–æµç¨‹

```mermaid
sequenceDiagram
    participant Caller as FrameEncoder
    participant FFW as FFmpegWrapper
    participant AVFormat as libavformat
    participant AVCodec as libavcodec
    participant SWS as libswscale
    
    Caller->>FFW: initialize(config)
    activate FFW
    
    Note over FFW: 1ï¸âƒ£ æŸ¥æ‰¾ç¼–ç å™¨
    FFW->>AVCodec: avcodec_find_encoder_by_name(codec)
    AVCodec-->>FFW: const AVCodec*
    
    Note over FFW: 2ï¸âƒ£ åˆ›å»ºç¼–ç å™¨ä¸Šä¸‹æ–‡
    FFW->>AVCodec: avcodec_alloc_context3(codec)
    AVCodec-->>FFW: AVCodecContext* (ä¿å­˜åˆ°æ™ºèƒ½æŒ‡é’ˆ)
    
    Note over FFW: 3ï¸âƒ£ é…ç½®ç¼–ç å™¨å‚æ•°
    FFW->>FFW: configureEncoder(config)
    FFW->>AVCodec: av_opt_set(crf, preset, ...)
    
    Note over FFW: 4ï¸âƒ£ æ‰“å¼€ç¼–ç å™¨
    FFW->>AVCodec: avcodec_open2(ctx, codec, nullptr)
    
    Note over FFW: 5ï¸âƒ£ åˆ›å»ºè¾“å‡ºæ–‡ä»¶
    FFW->>FFW: createOutputFile(path)
    FFW->>AVFormat: avformat_alloc_output_context2()
    AVFormat-->>FFW: AVFormatContext*
    FFW->>AVFormat: avformat_new_stream()
    FFW->>AVFormat: avio_open()
    FFW->>AVFormat: avformat_write_header()
    
    Note over FFW: 6ï¸âƒ£ åˆ›å»ºåƒç´ è½¬æ¢ä¸Šä¸‹æ–‡
    FFW->>SWS: sws_getContext(BGRA -> YUV420P)
    SWS-->>FFW: SwsContext*
    
    Note over FFW: 7ï¸âƒ£ åˆ†é…å¸§ç¼“å†²
    FFW->>AVCodec: av_frame_alloc()
    FFW->>AVCodec: av_frame_get_buffer(yuv_frame, 32)
    
    FFW->>FFW: initialized_ = true
    FFW-->>Caller: true
    deactivate FFW
```

### FFmpegWrapper å®ç°è¯¦è§£

#### åˆå§‹åŒ–æ–¹æ³•

```cpp
bool FFmpegWrapper::initialize(const EncoderConfig& config) {
    if (initialized_) {
        last_error_ = "Already initialized";
        return false;
    }
    
    output_path_ = config.output_path;
    width_ = config.width;
    height_ = config.height;
    
    // 1ï¸âƒ£ æŸ¥æ‰¾ç¼–ç å™¨
    const AVCodec* codec = avcodec_find_encoder_by_name(config.codec.c_str());
    if (!codec) {
        // å°è¯•ä½¿ç”¨é»˜è®¤H.264ç¼–ç å™¨
        codec = avcodec_find_encoder(AV_CODEC_ID_H264);
        if (!codec) {
            last_error_ = "Codec not found: " + config.codec;
            return false;
        }
    }
    
    // 2ï¸âƒ£ åˆ›å»ºç¼–ç å™¨ä¸Šä¸‹æ–‡ (RAII)
    codec_ctx_.reset(avcodec_alloc_context3(codec));
    if (!codec_ctx_) {
        last_error_ = "Failed to allocate codec context";
        return false;
    }
    
    // 3ï¸âƒ£ é…ç½®ç¼–ç å™¨
    if (!configureEncoder(config)) {
        return false;
    }
    
    // 4ï¸âƒ£ æ‰“å¼€ç¼–ç å™¨
    int ret = avcodec_open2(codec_ctx_.get(), codec, nullptr);
    if (ret < 0) {
        char errbuf[AV_ERROR_MAX_STRING_SIZE];
        av_strerror(ret, errbuf, sizeof(errbuf));
        last_error_ = std::string("Failed to open codec: ") + errbuf;
        return false;
    }
    
    // 5ï¸âƒ£ åˆ›å»ºè¾“å‡ºæ–‡ä»¶
    if (!createOutputFile(config.output_path)) {
        return false;
    }
    
    // 6ï¸âƒ£ åˆ›å»ºåƒç´ è½¬æ¢ä¸Šä¸‹æ–‡ (RAII)
    sws_ctx_.reset(sws_getContext(
        config.width, config.height, AV_PIX_FMT_BGRA,   // æºæ ¼å¼
        config.width, config.height, AV_PIX_FMT_YUV420P, // ç›®æ ‡æ ¼å¼
        SWS_BILINEAR, nullptr, nullptr, nullptr
    ));
    
    if (!sws_ctx_) {
        last_error_ = "Failed to create SwsContext";
        cleanup();
        return false;
    }
    
    // 7ï¸âƒ£ åˆ†é…YUVå¸§ç¼“å†² (RAII)
    yuv_frame_.reset(av_frame_alloc());
    if (!yuv_frame_) {
        last_error_ = "Failed to allocate YUV frame";
        cleanup();
        return false;
    }
    
    yuv_frame_->format = AV_PIX_FMT_YUV420P;
    yuv_frame_->width = config.width;
    yuv_frame_->height = config.height;
    
    // 32å­—èŠ‚å¯¹é½ï¼Œä¼˜åŒ–SIMDæ€§èƒ½
    ret = av_frame_get_buffer(yuv_frame_.get(), 32);
    if (ret < 0) {
        last_error_ = "Failed to allocate frame buffer";
        cleanup();
        return false;
    }
    
    // 8ï¸âƒ£ åˆ†é…æ•°æ®åŒ…ç¼“å†² (RAII)
    packet_.reset(av_packet_alloc());
    if (!packet_) {
        last_error_ = "Failed to allocate packet";
        cleanup();
        return false;
    }
    
    initialized_ = true;
    frame_count_ = 0;
    
    return true;
}
```

#### ç¼–ç å™¨é…ç½®

```cpp
bool FFmpegWrapper::configureEncoder(const EncoderConfig& config) {
    codec_ctx_->width = config.width;
    codec_ctx_->height = config.height;
    codec_ctx_->time_base = {1, config.fps};
    codec_ctx_->framerate = {config.fps, 1};
    codec_ctx_->pix_fmt = AV_PIX_FMT_YUV420P;
    codec_ctx_->bit_rate = config.bitrate;
    
    // GOPè®¾ç½® (å…³é”®å¸§é—´éš”)
    codec_ctx_->gop_size = config.fps * 2;  // 2ç§’ä¸€ä¸ªå…³é”®å¸§
    codec_ctx_->max_b_frames = 2;
    
    // CRF è´¨é‡æ§åˆ¶ (ä»…libx264)
    if (config.codec == "libx264" || config.codec.find("x264") != std::string::npos) {
        av_opt_set(codec_ctx_->priv_data, "crf", 
                   std::to_string(config.crf).c_str(), 0);
        av_opt_set(codec_ctx_->priv_data, "preset", 
                   config.preset.c_str(), 0);
        
        // ä½å»¶è¿Ÿè®¾ç½®
        av_opt_set(codec_ctx_->priv_data, "tune", "zerolatency", 0);
    }
    
    // NVENC ç¡¬ä»¶ç¼–ç å™¨è®¾ç½®
    if (config.codec.find("nvenc") != std::string::npos) {
        av_opt_set(codec_ctx_->priv_data, "preset", "p4", 0);
        av_opt_set(codec_ctx_->priv_data, "rc", "vbr", 0);
        av_opt_set(codec_ctx_->priv_data, "cq", 
                   std::to_string(config.crf).c_str(), 0);
    }
    
    return true;
}
```

#### åˆ›å»ºè¾“å‡ºæ–‡ä»¶

```cpp
bool FFmpegWrapper::createOutputFile(const std::string& path) {
    AVFormatContext* fmt_ctx = nullptr;
    
    // åˆ†é…æ ¼å¼ä¸Šä¸‹æ–‡
    int ret = avformat_alloc_output_context2(&fmt_ctx, nullptr, nullptr, path.c_str());
    if (ret < 0 || !fmt_ctx) {
        last_error_ = "Failed to create output context";
        return false;
    }
    
    format_ctx_.reset(fmt_ctx);  // RAIIæ¥ç®¡
    
    // åˆ›å»ºè§†é¢‘æµ
    video_stream_ = avformat_new_stream(format_ctx_.get(), nullptr);
    if (!video_stream_) {
        last_error_ = "Failed to create video stream";
        return false;
    }
    
    video_stream_->time_base = codec_ctx_->time_base;
    
    // å¤åˆ¶ç¼–ç å™¨å‚æ•°åˆ°æµ
    ret = avcodec_parameters_from_context(video_stream_->codecpar, codec_ctx_.get());
    if (ret < 0) {
        last_error_ = "Failed to copy codec parameters";
        return false;
    }
    
    // æ‰“å¼€è¾“å‡ºæ–‡ä»¶
    if (!(format_ctx_->oformat->flags & AVFMT_NOFILE)) {
        ret = avio_open(&format_ctx_->pb, path.c_str(), AVIO_FLAG_WRITE);
        if (ret < 0) {
            char errbuf[AV_ERROR_MAX_STRING_SIZE];
            av_strerror(ret, errbuf, sizeof(errbuf));
            last_error_ = std::string("Failed to open file: ") + errbuf;
            return false;
        }
    }
    
    // å†™å…¥æ–‡ä»¶å¤´
    ret = avformat_write_header(format_ctx_.get(), nullptr);
    if (ret < 0) {
        last_error_ = "Failed to write header";
        return false;
    }
    
    return true;
}
```

#### ç¼–ç ä¸€å¸§

```cpp
bool FFmpegWrapper::encodeFrame(const FrameData& frame_data) {
    if (!initialized_) {
        last_error_ = "Not initialized";
        return false;
    }
    
    // ç¡®ä¿å¸§å¯å†™
    int ret = av_frame_make_writable(yuv_frame_.get());
    if (ret < 0) {
        last_error_ = "Frame not writable";
        return false;
    }
    
    // 1ï¸âƒ£ åƒç´ æ ¼å¼è½¬æ¢ BGRA -> YUV420P
    if (!convertPixelFormat(frame_data, yuv_frame_.get())) {
        return false;
    }
    
    // 2ï¸âƒ£ è®¾ç½®æ—¶é—´æˆ³
    yuv_frame_->pts = frame_count_++;
    
    // 3ï¸âƒ£ å‘é€å¸§åˆ°ç¼–ç å™¨
    ret = avcodec_send_frame(codec_ctx_.get(), yuv_frame_.get());
    if (ret < 0) {
        char errbuf[AV_ERROR_MAX_STRING_SIZE];
        av_strerror(ret, errbuf, sizeof(errbuf));
        last_error_ = std::string("avcodec_send_frame failed: ") + errbuf;
        return false;
    }
    
    // 4ï¸âƒ£ æ¥æ”¶ç¼–ç åçš„æ•°æ®åŒ…
    while (ret >= 0) {
        ret = avcodec_receive_packet(codec_ctx_.get(), packet_.get());
        
        if (ret == AVERROR(EAGAIN) || ret == AVERROR_EOF) {
            break;  // æ­£å¸¸æƒ…å†µï¼Œæ— æ›´å¤šæ•°æ®åŒ…
        } else if (ret < 0) {
            last_error_ = "avcodec_receive_packet failed";
            return false;
        }
        
        // 5ï¸âƒ£ å†™å…¥æ–‡ä»¶
        if (!writePacket(packet_.get())) {
            return false;
        }
        
        av_packet_unref(packet_.get());
    }
    
    return true;
}
```

#### å®Œæˆç¼–ç 

```cpp
void FFmpegWrapper::finalize() {
    if (!initialized_) {
        return;
    }
    
    // åˆ·æ–°ç¼–ç å™¨
    flushEncoder();
    
    // å†™å…¥æ–‡ä»¶å°¾
    if (format_ctx_) {
        av_write_trailer(format_ctx_.get());
    }
    
    // æ¸…ç†èµ„æº (RAIIè‡ªåŠ¨å¤„ç†)
    cleanup();
    
    initialized_ = false;
}

void FFmpegWrapper::flushEncoder() {
    // å‘é€NULLå¸§è§¦å‘ç¼–ç å™¨flush
    avcodec_send_frame(codec_ctx_.get(), nullptr);
    
    // æ¥æ”¶å‰©ä½™çš„æ•°æ®åŒ…
    int ret = 0;
    while (ret >= 0) {
        ret = avcodec_receive_packet(codec_ctx_.get(), packet_.get());
        if (ret == AVERROR(EAGAIN) || ret == AVERROR_EOF) {
            break;
        }
        
        writePacket(packet_.get());
        av_packet_unref(packet_.get());
    }
}

void FFmpegWrapper::cleanup() {
    // æ™ºèƒ½æŒ‡é’ˆæŒ‰å£°æ˜ååºè‡ªåŠ¨é‡Šæ”¾
    // ä½†æˆ‘ä»¬æ˜¾å¼resetä»¥ç¡®ä¿é¡ºåº
    
    packet_.reset();      // å…ˆé‡Šæ”¾packet
    sws_ctx_.reset();     // é‡Šæ”¾è½¬æ¢ä¸Šä¸‹æ–‡
    yuv_frame_.reset();   // é‡Šæ”¾å¸§ç¼“å†²
    codec_ctx_.reset();   // é‡Šæ”¾ç¼–ç å™¨ä¸Šä¸‹æ–‡
    // format_ctx_ æœ€åé‡Šæ”¾ (åˆ é™¤å™¨ä¼šå…ˆå…³é—­avio)
    format_ctx_.reset();
    
    video_stream_ = nullptr;
}
```

### æ™ºèƒ½æŒ‡é’ˆç±»å‹åˆ«åæ€»è§ˆ

```cpp
// ========== æ¨èåœ¨é¡¹ç›®ä¸­ä½¿ç”¨çš„ç±»å‹åˆ«å ==========

// æ ¼å¼ä¸Šä¸‹æ–‡ (åŒ…å«I/Oå’Œæµä¿¡æ¯)
using AVFormatContextPtr = std::unique_ptr<AVFormatContext, AVFormatContextDeleter>;

// ç¼–ç å™¨ä¸Šä¸‹æ–‡
using AVCodecContextPtr = std::unique_ptr<AVCodecContext, AVCodecContextDeleter>;

// å¸§ç¼“å†²
using AVFramePtr = std::unique_ptr<AVFrame, AVFrameDeleter>;

// åƒç´ è½¬æ¢ä¸Šä¸‹æ–‡
using SwsContextPtr = std::unique_ptr<SwsContext, SwsContextDeleter>;

// æ•°æ®åŒ…
using AVPacketPtr = std::unique_ptr<AVPacket, AVPacketDeleter>;
```

### å¼‚å¸¸å®‰å…¨ä¿è¯

```mermaid
graph TB
    subgraph "å¼‚å¸¸å®‰å…¨ç­‰çº§"
        A[åŸºæœ¬ä¿è¯] --> A1[èµ„æºä¸æ³„æ¼]
        A --> A2[å¯¹è±¡å¤„äºæœ‰æ•ˆçŠ¶æ€]
        
        B[å¼ºä¿è¯] --> B1[æ“ä½œè¦ä¹ˆå®Œå…¨æˆåŠŸ]
        B --> B2[è¦ä¹ˆæ— ä»»ä½•æ•ˆæœ]
        
        C[ä¸æŠ›å‡ºä¿è¯] --> C1[æ“ä½œä¿è¯ä¸æŠ›å‡ºå¼‚å¸¸]
    end
    
    subgraph "FFmpegWrapper ä¿è¯"
        D[initialize] --> B
        E[encodeFrame] --> A
        F[finalize] --> C
        G[ææ„å‡½æ•°] --> C
    end
    
    style B fill:#90EE90
    style A fill:#87CEEB
    style C fill:#FFB6C1
```

| æ–¹æ³• | å¼‚å¸¸å®‰å…¨ç­‰çº§ | è¯´æ˜ |
|------|-------------|------|
| `initialize()` | **å¼ºä¿è¯** | å¤±è´¥æ—¶ä¸åˆ›å»ºä»»ä½•èµ„æº |
| `encodeFrame()` | **åŸºæœ¬ä¿è¯** | å¤±è´¥å¯èƒ½å¯¼è‡´å¸§ä¸¢å¤± |
| `finalize()` | **ä¸æŠ›å‡º** | èµ„æºé‡Šæ”¾ä¸ä¼šå¤±è´¥ |
| `~FFmpegWrapper()` | **ä¸æŠ›å‡º** | ææ„å‡½æ•°ä»ä¸æŠ›å‡º |

---

## è¯¦ç»†å®ç°è§£æ

### start() æ–¹æ³•

```cpp
void FrameEncoder::start() {
    if (running_) {
        return;  // å·²ç»åœ¨è¿è¡Œ
    }
    
    // 1ï¸âƒ£ åˆ›å»ºFFmpegç¼–ç å™¨ (RAII)
    encoder_ = std::make_unique<FFmpegWrapper>();
    
    // 2ï¸âƒ£ è®¾ç½®è¿è¡Œæ ‡å¿—
    running_ = true;
    
    // 3ï¸âƒ£ å¯åŠ¨ç¼–ç çº¿ç¨‹
    thread_ = std::make_unique<std::thread>(&FrameEncoder::encodeLoop, this);
    
    std::cout << "[FrameEncoder] Started" << std::endl;
}
```

### encodeLoop() - æ ¸å¿ƒç¼–ç å¾ªç¯

```cpp
void FrameEncoder::encodeLoop() {
    // 1ï¸âƒ£ åˆå§‹åŒ–ç¼–ç å™¨
    if (!encoder_->initialize(config_)) {
        notifyError("Failed to initialize encoder: " + encoder_->getLastError());
        return;
    }
    
    std::cout << "[FrameEncoder] Encoding started" << std::endl;
    
    // 2ï¸âƒ£ ä¸»å¾ªç¯
    while (running_) {
        FrameData frame;
        
        // 3ï¸âƒ£ ä»é˜Ÿåˆ—å–å¸§ (è¶…æ—¶100ms)
        if (!queue_->pop(frame, std::chrono::milliseconds(100))) {
            // è¶…æ—¶,ç»§ç»­ç­‰å¾…
            continue;
        }
        
        // 4ï¸âƒ£ å¤„ç†å¸§
        if (!processFrame(frame)) {
            notifyError("Failed to encode frame: " + encoder_->getLastError());
            break;
        }
        
        // 5ï¸âƒ£ æ›´æ–°ç»Ÿè®¡
        encoded_count_++;
        
        // 6ï¸âƒ£ æ¯30å¸§é€šçŸ¥ä¸€æ¬¡è¿›åº¦
        if (encoded_count_ % 30 == 0) {
            notifyProgress();
        }
    }
    
    // 7ï¸âƒ£ å®Œæˆç¼–ç 
    encoder_->finalize();
    
    std::cout << "[FrameEncoder] Encoding finished, total frames: " 
              << encoded_count_ << std::endl;
    
    // 8ï¸âƒ£ é€šçŸ¥å®Œæˆ
    notifyFinished();
}
```

### ç¼–ç æµç¨‹æ—¶åºå›¾

```mermaid
sequenceDiagram
    participant Queue as ThreadSafeQueue
    participant Encoder as FrameEncoder
    participant FFW as FFmpegWrapper
    participant SWS as SwsContext
    participant File as è¾“å‡ºæ–‡ä»¶
    
    Note over Encoder: å¯åŠ¨ç¼–ç çº¿ç¨‹
    Encoder->>FFW: initialize(config)
    FFW->>FFW: åˆ›å»ºç¼–ç å™¨ä¸Šä¸‹æ–‡
    FFW->>FFW: åˆ›å»ºè¾“å‡ºæ–‡ä»¶
    FFW->>FFW: åˆ›å»ºSwsContext
    FFW->>File: avformat_write_header()
    
    loop ç¼–ç å¾ªç¯
        Encoder->>Queue: pop(frame, 100ms)
        
        alt é˜Ÿåˆ—éç©º
            Queue-->>Encoder: FrameData (BGRA)
            
            Encoder->>FFW: encodeFrame(frame)
            FFW->>SWS: sws_scale(BGRA â†’ YUV420P)
            SWS-->>FFW: è½¬æ¢å®Œæˆ
            FFW->>FFW: avcodec_send_frame()
            FFW->>FFW: avcodec_receive_packet()
            FFW->>File: av_interleaved_write_frame()
            
            Encoder->>Encoder: encoded_count_++
            
            alt æ¯30å¸§
                Encoder->>Encoder: notifyProgress()
            end
        else é˜Ÿåˆ—ä¸ºç©º
            Note over Encoder: è¶…æ—¶,ç»§ç»­ç­‰å¾…
        end
    end
    
    Note over Encoder: åœæ­¢ä¿¡å·
    Encoder->>FFW: finalize()
    FFW->>FFW: flushEncoder()
    FFW->>File: av_write_trailer()
    FFW->>FFW: cleanup() [RAIIé‡Šæ”¾]
    Encoder->>Encoder: notifyFinished()
```

---

## åƒç´ æ ¼å¼è½¬æ¢

### ä¸ºä»€ä¹ˆéœ€è¦æ ¼å¼è½¬æ¢?

| æ ¼å¼ | æ¯åƒç´ å­—èŠ‚ | 1080på¸§å¤§å° | é€‚ç”¨åœºæ™¯ |
|------|----------|------------|---------|
| BGRA | 4å­—èŠ‚ | 8.3MB | é‡‡é›†ã€å¤„ç† |
| YUV420P | 1.5å­—èŠ‚ | 3.1MB | ç¼–ç ã€å­˜å‚¨ |

**æ€§èƒ½å½±å“**:
- è½¬æ¢è€—æ—¶: ~2ms/å¸§ (1080p)
- å†…å­˜èŠ‚çœ: 62.5%
- å¿…è¦æ€§: H.264è¦æ±‚

### SwsContext é…ç½®

```cpp
// åœ¨FFmpegWrapper::initialize()ä¸­
sws_ctx_.reset(sws_getContext(
    config.width, config.height, AV_PIX_FMT_BGRA,     // æºæ ¼å¼
    config.width, config.height, AV_PIX_FMT_YUV420P,  // ç›®æ ‡æ ¼å¼
    SWS_BILINEAR,  // è½¬æ¢ç®—æ³•
    nullptr, nullptr, nullptr
));
```

### è½¬æ¢ç®—æ³•å¯¹æ¯”

| ç®—æ³• | è´¨é‡ | é€Ÿåº¦ | é€‚ç”¨åœºæ™¯ |
|------|------|------|---------|
| `SWS_FAST_BILINEAR` | â­â­ | âš¡âš¡âš¡ | å®æ—¶å½•åˆ¶ âœ… |
| `SWS_BILINEAR` | â­â­â­ | âš¡âš¡ | å¹³è¡¡æ¨¡å¼ âœ… |
| `SWS_BICUBIC` | â­â­â­â­ | âš¡ | é«˜è´¨é‡ç¦»çº¿ |
| `SWS_LANCZOS` | â­â­â­â­â­ | ğŸŒ | ä¸“ä¸šåæœŸ |

### convertPixelFormat() å®ç°

```cpp
bool FFmpegWrapper::convertPixelFormat(const FrameData& src, AVFrame* dst) {
    // 1ï¸âƒ£ å‡†å¤‡æºæ•°æ®
    // BGRA strideå¯èƒ½æœ‰paddingï¼Œéœ€è¦æ­£ç¡®è®¡ç®—
    const uint8_t* src_data[1] = { src.data };
    int src_linesize[1] = { src.width * 4 };  // BGRAæ¯åƒç´ 4å­—èŠ‚
    
    // 2ï¸âƒ£ æ‰§è¡Œè½¬æ¢
    int ret = sws_scale(
        sws_ctx_.get(),
        src_data,           // æºæ•°æ®æŒ‡é’ˆ
        src_linesize,       // æºè¡Œå­—èŠ‚æ•°
        0,                  // èµ·å§‹è¡Œ
        src.height,         // é«˜åº¦
        dst->data,          // ç›®æ ‡æ•°æ®æŒ‡é’ˆ
        dst->linesize       // ç›®æ ‡è¡Œå­—èŠ‚æ•°
    );
    
    if (ret <= 0) {
        last_error_ = "sws_scale failed";
        return false;
    }
    
    return true;
}
```

---

## æ€§èƒ½ä¼˜åŒ–ç­–ç•¥

### å†…å­˜ç®¡ç†ä¼˜åŒ–

```cpp
// âœ… ä½¿ç”¨æ™ºèƒ½æŒ‡é’ˆ + è‡ªå®šä¹‰åˆ é™¤å™¨ (FFmpegWrapperå·²å®ç°)
using AVFramePtr = std::unique_ptr<AVFrame, AVFrameDeleter>;
using AVPacketPtr = std::unique_ptr<AVPacket, AVPacketDeleter>;

// âœ… å¸§ç¼“å†²å¤ç”¨ (ä¸æ¯å¸§åˆ†é…)
// yuv_frame_ åœ¨initializeæ—¶åˆ†é…ä¸€æ¬¡ï¼Œåç»­å¤ç”¨

// âœ… æ•°æ®åŒ…ç¼“å†²å¤ç”¨
// packet_ åœ¨initializeæ—¶åˆ†é…ä¸€æ¬¡ï¼Œä½¿ç”¨av_packet_unrefæ¸…ç©ºåå¤ç”¨
```

### ç¼–ç å‚æ•°è°ƒä¼˜

| å‚æ•° | ä½å»¶è¿Ÿ | å¹³è¡¡ | é«˜è´¨é‡ |
|------|--------|------|--------|
| **Preset** | ultrafast | fast âœ… | medium |
| **CRF** | 28 | 23 âœ… | 18 |
| **Bitrate** | 4Mbps | 8Mbps âœ… | 12Mbps |
| **CPUå ç”¨** | 10% | 20% | 35% |

### ç¡¬ä»¶åŠ é€Ÿ

```cpp
// ä½¿ç”¨NVIDIAç¡¬ä»¶ç¼–ç å™¨
EncoderConfig config;
config.codec = "h264_nvenc";  // æ›¿ä»£libx264
config.preset = "p4";  // NVENCé¢„è®¾

// æ€§èƒ½æå‡:
// - CPUå ç”¨: 20% â†’ 5%
// - ç¼–ç é€Ÿåº¦: 2x-3xæå‡
```

---

## Pybind11å›è°ƒæœºåˆ¶

### å›è°ƒå‡½æ•°å®ç°

```cpp
void FrameEncoder::notifyProgress() {
    if (!on_progress_) {
        return;
    }
    
    try {
        // è·å–Python GIL
        py::gil_scoped_acquire acquire;
        
        // è°ƒç”¨Pythonå›è°ƒ
        on_progress_(
            encoded_count_.load(),
            encoder_->getOutputFileSize()
        );
    } catch (const std::exception& e) {
        std::cerr << "[FrameEncoder] Progress callback error: " << e.what() << std::endl;
    }
}
```

### Pybind11ç»‘å®š

```cpp
PYBIND11_MODULE(video_analysis_cpp, m) {
    // ç¼–ç å™¨é…ç½®
    py::class_<EncoderConfig>(m, "EncoderConfig")
        .def(py::init<>())
        .def_readwrite("output_path", &EncoderConfig::output_path)
        .def_readwrite("width", &EncoderConfig::width)
        .def_readwrite("height", &EncoderConfig::height)
        .def_readwrite("fps", &EncoderConfig::fps)
        .def_readwrite("bitrate", &EncoderConfig::bitrate)
        .def_readwrite("crf", &EncoderConfig::crf)
        .def_readwrite("preset", &EncoderConfig::preset)
        .def_readwrite("codec", &EncoderConfig::codec)
        .def_static("default_config", &EncoderConfig::defaultConfig);
    
    // å¸§ç¼–ç å™¨
    py::class_<FrameEncoder, std::shared_ptr<FrameEncoder>>(m, "FrameEncoder")
        .def(py::init<
            std::shared_ptr<ThreadSafetyQueue<FrameData>>,
            const EncoderConfig&
        >())
        .def("start", &FrameEncoder::start)
        .def("stop", &FrameEncoder::stop)
        .def("get_encoded_count", &FrameEncoder::getEncodedCount)
        .def("get_output_file_size", &FrameEncoder::getOutputFileSize)
        .def("is_running", &FrameEncoder::isRunning)
        
        // å›è°ƒå‡½æ•°
        .def("set_progress_callback", &FrameEncoder::setProgressCallback)
        .def("set_finished_callback", &FrameEncoder::setFinishedCallback)
        .def("set_error_callback", &FrameEncoder::setErrorCallback);
}
```

---

## å®æˆ˜ä½¿ç”¨æŒ‡å—

### C++å±‚ä½¿ç”¨

```cpp
#include "FrameEncoder.h"

int main() {
    // åˆ›å»ºé˜Ÿåˆ—
    auto queue = std::make_shared<ThreadSafetyQueue<FrameData>>(30);
    
    // é…ç½®ç¼–ç å™¨
    EncoderConfig config = EncoderConfig::defaultConfig();
    config.output_path = "recording.mp4";
    config.width = 1920;
    config.height = 1080;
    config.fps = 60;
    
    // åˆ›å»ºç¼–ç å™¨
    auto encoder = std::make_shared<FrameEncoder>(queue, config);
    
    // è®¾ç½®å›è°ƒ
    encoder->setProgressCallback([](int64_t frames, int64_t size) {
        std::cout << "Encoded: " << frames << " frames, " 
                  << size / 1024 / 1024 << " MB" << std::endl;
    });
    
    // å¯åŠ¨
    encoder->start();
    
    // ... è¿è¡Œ ...
    
    // åœæ­¢
    encoder->stop();
    
    return 0;
}
```

### Pythonå±‚ä½¿ç”¨

```python
import video_analysis_cpp as vac

class VideoService:
    def __init__(self):
        self.queue = vac.ThreadSafetyQueue(30)
        
        # é…ç½®ç¼–ç å™¨
        config = vac.EncoderConfig.default_config()
        config.output_path = "recording.mp4"
        config.fps = 60
        
        self.encoder = vac.FrameEncoder(self.queue, config)
        
        # è®¾ç½®å›è°ƒ
        self.encoder.set_progress_callback(self._on_progress)
        self.encoder.set_finished_callback(self._on_finished)
    
    def _on_progress(self, frames: int, file_size: int):
        """ç¼–ç è¿›åº¦å›è°ƒ"""
        mb = file_size / 1024 / 1024
        print(f"ğŸ“¹ Encoded: {frames} frames, {mb:.1f} MB")
    
    def _on_finished(self, total_frames: int, output_path: str):
        """ç¼–ç å®Œæˆå›è°ƒ"""
        print(f"âœ… Encoding finished: {total_frames} frames")
        print(f"ğŸ“ Output: {output_path}")
```

---

## æ€»ç»“

### æ¨¡å—å…³ç³»å›¾

```mermaid
graph TB
    subgraph "å¸§ç¼–ç å™¨æ¨¡å—"
        FE[FrameEncoder<br/>ç¼–ç çº¿ç¨‹ç®¡ç†]
        FFW[FFmpegWrapper<br/>FFmpeg RAIIå°è£…]
        EC[EncoderConfig<br/>ç¼–ç é…ç½®]
    end
    
    subgraph "å¤–éƒ¨ä¾èµ–"
        TSQ[ThreadSafetyQueue<br/>å¸§é˜Ÿåˆ—]
        FD[FrameData<br/>å¸§æ•°æ®]
        PY[Pythonå›è°ƒ<br/>Pybind11]
    end
    
    subgraph "FFmpegåº“"
        AVC[libavcodec]
        AVF[libavformat]
        SWS[libswscale]
    end
    
    FE --> FFW
    FE --> EC
    FE --> TSQ
    FE --> FD
    FE -.-> PY
    
    FFW --> AVC
    FFW --> AVF
    FFW --> SWS
    
    style FFW fill:#FFB6C1,stroke:#333,stroke-width:2px
    style FE fill:#90EE90,stroke:#333,stroke-width:2px
```

### å…³é”®ç‰¹æ€§æ€»ç»“

âœ… **é«˜æ•ˆç¼–ç **: H.264å®æ—¶ç¼–ç ï¼Œæ”¯æŒ60fps  
âœ… **æ ¼å¼è½¬æ¢**: BGRAâ†’YUV420Pï¼ŒSIMDåŠ é€Ÿ  
âœ… **FFmpegWrapper RAIIå°è£…**: è‡ªå®šä¹‰åˆ é™¤å™¨ï¼Œå¼‚å¸¸å®‰å…¨ï¼Œé›¶å†…å­˜æ³„æ¼  
âœ… **è·¨è¯­è¨€é€šä¿¡**: Pybind11å›è°ƒ + GILç®¡ç†  
âœ… **ç¡¬ä»¶åŠ é€Ÿ**: æ”¯æŒNVENCç­‰ç¡¬ä»¶ç¼–ç å™¨  
âœ… **èµ„æºå®‰å…¨**: æ­£ç¡®çš„èµ„æºé‡Šæ”¾é¡ºåºï¼Œå¼ºå¼‚å¸¸å®‰å…¨ä¿è¯

### æ–‡ä»¶ç»“æ„å»ºè®®

```
cpp/include/core/ScreenRecorder/ProcessLayer/
â”œâ”€â”€ FrameEncoder.h          # å¸§ç¼–ç å™¨å®šä¹‰
â”œâ”€â”€ FFmpegWrapper.h         # FFmpeg RAIIå°è£… â­ æ–°å¢
â”œâ”€â”€ EncoderConfig.h         # ç¼–ç å™¨é…ç½® (å¯é€‰ï¼Œä¹Ÿå¯åœ¨FFmpegWrapper.hä¸­)
â”œâ”€â”€ FrameGrabberThread.h    # å¸§é‡‡é›†çº¿ç¨‹
â””â”€â”€ ThreadSafetyQueue.h     # çº¿ç¨‹å®‰å…¨é˜Ÿåˆ—

cpp/src/core/ScreenRecorder/ProcessLayer/
â”œâ”€â”€ FrameEncoder.cpp        # å¸§ç¼–ç å™¨å®ç°
â”œâ”€â”€ FFmpegWrapper.cpp       # FFmpegå°è£…å®ç° â­ æ–°å¢
â””â”€â”€ FrameGrabberThread.cpp  # å¸§é‡‡é›†çº¿ç¨‹å®ç°
```

---

**ä¸‹ä¸€æ­¥**: æ•´åˆç”Ÿäº§è€…å’Œæ¶ˆè´¹è€… [3.2.4 ç”Ÿäº§è€…-æ¶ˆè´¹è€…åä½œæœºåˆ¶](file:///d:/ç¼–ç¨‹/é¡¹ç›®/AiVideoAnalsysSystem/.agent/ç¬¬ä¸‰ç« /3.2.4_ç”Ÿäº§è€…æ¶ˆè´¹è€…åä½œ.md)
