# 3.2.2 å¸§é‡‡é›†çº¿ç¨‹è®¾è®¡

> **ç”Ÿäº§è€…æ ¸å¿ƒ**  
> `FrameGrabberThread` æ˜¯è§†é¢‘æµå¤„ç†çš„ç”Ÿäº§è€…,è´Ÿè´£ä»¥ç²¾ç¡®çš„å¸§ç‡æŒç»­æ•è·å±å¹•å¸§,å¹¶é€šè¿‡çº¿ç¨‹å®‰å…¨é˜Ÿåˆ—ä¼ é€’ç»™ç¼–ç å™¨ã€‚æœ¬æ–‡æ¡£è¯¦è§£å…¶è®¾è®¡åŸç†ã€å¸§ç‡æ§åˆ¶ç®—æ³•å’Œä¸Pythonå±‚çš„é€šä¿¡æœºåˆ¶ã€‚

---

## ğŸ“‹ ç›®å½•

1. [æ¨¡å—æ¦‚è¿°ä¸å®šä½](#æ¨¡å—æ¦‚è¿°ä¸å®šä½)
2. [è®¾è®¡ç›®æ ‡ä¸æŒ‘æˆ˜](#è®¾è®¡ç›®æ ‡ä¸æŒ‘æˆ˜)
3. [æ ¸å¿ƒæ¶æ„è®¾è®¡](#æ ¸å¿ƒæ¶æ„è®¾è®¡)
4. [è¯¦ç»†å®ç°è§£æ](#è¯¦ç»†å®ç°è§£æ)
5. [ç²¾ç¡®å¸§ç‡æ§åˆ¶](#ç²¾ç¡®å¸§ç‡æ§åˆ¶)
6. [Pybind11å›è°ƒæœºåˆ¶](#pybind11å›è°ƒæœºåˆ¶)
7. [æ€§èƒ½ç›‘æ§ä¸ç»Ÿè®¡](#æ€§èƒ½ç›‘æ§ä¸ç»Ÿè®¡)
8. [å®æˆ˜ä½¿ç”¨æŒ‡å—](#å®æˆ˜ä½¿ç”¨æŒ‡å—)

---

## æ¨¡å—æ¦‚è¿°ä¸å®šä½

### åœ¨ç³»ç»Ÿä¸­çš„ä½ç½®

```mermaid
graph TB
    subgraph "C++æ ¸å¿ƒå±‚"
        Grabber[IScreenGrabber<br/>å±å¹•é‡‡é›†å™¨]
        Thread[FrameGrabberThread<br/>é‡‡é›†çº¿ç¨‹æ§åˆ¶]
        Queue[ThreadSafeQueue<br/>å¸§é˜Ÿåˆ—]
    end
    
    subgraph "Pythonä¸šåŠ¡å±‚"
        Service[VideoService<br/>è§†é¢‘æœåŠ¡]
        Callback[å›è°ƒå‡½æ•°<br/>è¿›åº¦/é”™è¯¯é€šçŸ¥]
    end
    
    subgraph "QML UIå±‚"
        UI[å½•åˆ¶ç•Œé¢<br/>è¿›åº¦æ˜¾ç¤º]
    end
    
    Thread -->|captureFrame| Grabber
    Grabber -->|FrameData| Thread
    Thread -->|push| Queue
    Thread -.Pybind11å›è°ƒ.-> Callback
    Callback -->|Signal| Service
    Service -->|Signal| UI
    
    style Thread fill:#87CEEB,stroke:#333,stroke-width:3px
    style Callback fill:#FFA500
```

### æ ¸å¿ƒèŒè´£

| èŒè´£ | è¯´æ˜ | æŠ€æœ¯å®ç° |
|------|------|---------|
| **å±å¹•é‡‡é›†** | è°ƒç”¨IScreenGrabberæ•è·å¸§ | DXGI/GDI/X11 |
| **å¸§ç‡æ§åˆ¶** | ç²¾ç¡®æ§åˆ¶60fps | `std::chrono` é«˜ç²¾åº¦å®šæ—¶ |
| **é˜Ÿåˆ—ç®¡ç†** | æ¨é€å¸§åˆ°ThreadSafeQueue | ç§»åŠ¨è¯­ä¹‰,è¶…æ—¶å¤„ç† |
| **çŠ¶æ€ç›‘æ§** | FPSè®¡ç®—,ä¸¢å¸§ç»Ÿè®¡ | æ»‘åŠ¨çª—å£ç®—æ³• |
| **Pythoné€šä¿¡** | è¿›åº¦/é”™è¯¯é€šçŸ¥ | Pybind11å›è°ƒ + GILç®¡ç† |

---

## è®¾è®¡ç›®æ ‡ä¸æŒ‘æˆ˜

### æ ¸å¿ƒè®¾è®¡ç›®æ ‡

```mermaid
mindmap
  root((FrameGrabberThread))
    ç²¾ç¡®å¸§ç‡
      60fpsç¨³å®šè¾“å‡º
      æ—¶é—´æ¼‚ç§»è¡¥å¿
      è‡ªé€‚åº”è°ƒæ•´
    é«˜æ€§èƒ½
      CPUå ç”¨ < 15%
      é›¶æ‹·è´ä¼ é€’
      æœ€å°åŒ–é”ç«äº‰
    å¯é æ€§
      ä¸¢å¸§æ£€æµ‹
      é”™è¯¯æ¢å¤
      ä¼˜é›…åœæ­¢
    å¯è§‚æµ‹æ€§
      å®æ—¶FPSç»Ÿè®¡
      ä¸¢å¸§ç‡ç›‘æ§
      Pythonå±‚é€šçŸ¥
```

### æŠ€æœ¯æŒ‘æˆ˜

| æŒ‘æˆ˜ | é—®é¢˜ | è§£å†³æ–¹æ¡ˆ |
|------|------|---------|
| **å¸§ç‡ç²¾åº¦** | `sleep()` ç²¾åº¦ä¸è¶³ | `std::this_thread::sleep_for()` + æ—¶é—´è¡¥å¿ |
| **æ—¶é—´æ¼‚ç§»** | ç´¯ç§¯è¯¯å·®å¯¼è‡´å¸§ç‡åç§» | åŸºäºç»å¯¹æ—¶é—´æˆ³è®¡ç®— |
| **GILé—®é¢˜** | Pythonå›è°ƒé˜»å¡C++çº¿ç¨‹ | `py::gil_scoped_acquire` æœ€å°åŒ–æŒæœ‰æ—¶é—´ |
| **é˜Ÿåˆ—æ»¡** | ç¼–ç å™¨æ…¢å¯¼è‡´ä¸¢å¸§ | è¶…æ—¶æœºåˆ¶ + ä¸¢å¸§ç»Ÿè®¡ |

---

## æ ¸å¿ƒæ¶æ„è®¾è®¡

### ç±»å®šä¹‰

```cpp
#pragma once

#include <thread>
#include <atomic>
#include <memory>
#include <chrono>
#include <deque>
#include <functional>

#include "IScreenGrabber.h"
#include "ThreadSafeQueue.h"
#include "FrameData.h"

/**
 * @brief å¸§é‡‡é›†çº¿ç¨‹
 * 
 * åœ¨ç‹¬ç«‹çº¿ç¨‹ä¸­ä»¥ç²¾ç¡®å¸§ç‡æŒç»­æ•è·å±å¹•å¸§,å¹¶æ¨é€åˆ°é˜Ÿåˆ—
 */
class FrameGrabberThread {
public:
    /**
     * @brief æ„é€ å‡½æ•°
     * @param grabber å±å¹•é‡‡é›†å™¨
     * @param queue å¸§é˜Ÿåˆ—
     * @param target_fps ç›®æ ‡å¸§ç‡ (é»˜è®¤60fps)
     */
    FrameGrabberThread(
        std::shared_ptr<IScreenGrabber> grabber,
        std::shared_ptr<ThreadSafeQueue<FrameData>> queue,
        int target_fps = 60
    );
    
    ~FrameGrabberThread();
    
    // ç¦æ­¢æ‹·è´
    FrameGrabberThread(const FrameGrabberThread&) = delete;
    FrameGrabberThread& operator=(const FrameGrabberThread&) = delete;
    
    /**
     * @brief å¯åŠ¨é‡‡é›†çº¿ç¨‹
     */
    void start();
    
    /**
     * @brief åœæ­¢é‡‡é›†çº¿ç¨‹
     */
    void stop();
    
    /**
     * @brief æš‚åœé‡‡é›†
     */
    void pause();
    
    /**
     * @brief æ¢å¤é‡‡é›†
     */
    void resume();
    
    /**
     * @brief è·å–ç»Ÿè®¡ä¿¡æ¯
     */
    int64_t getFrameCount() const { return frame_count_; }
    int64_t getDroppedCount() const { return dropped_count_; }
    double getCurrentFPS() const { return current_fps_; }
    bool isRunning() const { return running_; }
    bool isPaused() const { return paused_; }
    
    // Pybind11å›è°ƒå‡½æ•°ç±»å‹
    using ProgressCallback = std::function<void(int64_t, int, double)>;
    using ErrorCallback = std::function<void(const std::string&)>;
    using DroppedCallback = std::function<void(int)>;
    
    /**
     * @brief è®¾ç½®å›è°ƒå‡½æ•° (ä»Pythonå±‚è°ƒç”¨)
     */
    void setProgressCallback(ProgressCallback callback) { 
        on_progress_ = callback; 
    }
    void setErrorCallback(ErrorCallback callback) { 
        on_error_ = callback; 
    }
    void setDroppedCallback(DroppedCallback callback) { 
        on_dropped_ = callback; 
    }
    
private:
    /**
     * @brief é‡‡é›†å¾ªç¯ (åœ¨ç‹¬ç«‹çº¿ç¨‹ä¸­è¿è¡Œ)
     */
    void captureLoop();
    
    /**
     * @brief è®¡ç®—å®é™…FPS
     */
    void updateFPS();
    
    /**
     * @brief ç²¾ç¡®å¸§ç‡æ§åˆ¶
     */
    void waitForNextFrame();
    
    /**
     * @brief è°ƒç”¨Pythonå›è°ƒ (å¤„ç†GIL)
     */
    void notifyProgress();
    void notifyError(const std::string& error);
    void notifyDropped(int count);
    
    // æ ¸å¿ƒç»„ä»¶
    std::shared_ptr<IScreenGrabber> grabber_;
    std::shared_ptr<ThreadSafeQueue<FrameData>> queue_;
    std::unique_ptr<std::thread> thread_;
    
    // å¸§ç‡æ§åˆ¶
    int target_fps_;
    std::chrono::microseconds frame_interval_;  // å¸§é—´éš”
    
    // çŠ¶æ€æ ‡å¿—
    std::atomic<bool> running_{false};
    std::atomic<bool> paused_{false};
    
    // ç»Ÿè®¡ä¿¡æ¯
    std::atomic<int64_t> frame_count_{0};
    std::atomic<int64_t> dropped_count_{0};
    std::atomic<double> current_fps_{0.0};
    
    // æ—¶é—´æˆ³
    std::chrono::steady_clock::time_point start_time_;
    std::chrono::steady_clock::time_point last_frame_time_;
    
    // FPSè®¡ç®— (æ»‘åŠ¨çª—å£)
    static constexpr int FPS_SAMPLE_SIZE = 60;
    std::deque<std::chrono::steady_clock::time_point> fps_samples_;
    
    // Pythonå›è°ƒ
    ProgressCallback on_progress_;
    ErrorCallback on_error_;
    DroppedCallback on_dropped_;
};
```

### çº¿ç¨‹ç”Ÿå‘½å‘¨æœŸ

```mermaid
stateDiagram-v2
    [*] --> Created: æ„é€ å‡½æ•°
    Created --> Running: start()
    Running --> Paused: pause()
    Paused --> Running: resume()
    Running --> Stopped: stop()
    Stopped --> [*]: ææ„å‡½æ•°
    
    state Running {
        [*] --> Capturing
        Capturing --> WaitingFrame: å¸§ç‡æ§åˆ¶
        WaitingFrame --> Capturing: sleepç»“æŸ
        Capturing --> PushingQueue: æ•è·æˆåŠŸ
        PushingQueue --> Capturing: pushå®Œæˆ
        PushingQueue --> DroppedFrame: é˜Ÿåˆ—æ»¡
        DroppedFrame --> Capturing: è®°å½•ä¸¢å¸§
    }
```

---

## è¯¦ç»†å®ç°è§£æ

### start() æ–¹æ³•

```cpp
void FrameGrabberThread::start() {
    if (running_) {
        return;  // å·²ç»åœ¨è¿è¡Œ
    }
    
    // 1ï¸âƒ£ åˆå§‹åŒ–é‡‡é›†å™¨
    if (!grabber_->start()) {
        notifyError("Failed to start screen grabber");
        return;
    }
    
    // 2ï¸âƒ£ è®¾ç½®è¿è¡Œæ ‡å¿—
    running_ = true;
    paused_ = false;
    
    // 3ï¸âƒ£ å¯åŠ¨é‡‡é›†çº¿ç¨‹
    thread_ = std::make_unique<std::thread>(&FrameGrabberThread::captureLoop, this);
    
    std::cout << "[FrameGrabberThread] Started, target FPS: " << target_fps_ << std::endl;
}
```

### captureLoop() - æ ¸å¿ƒé‡‡é›†å¾ªç¯

```cpp
void FrameGrabberThread::captureLoop() {
    // 1ï¸âƒ£ åˆå§‹åŒ–æ—¶é—´æˆ³
    start_time_ = std::chrono::steady_clock::now();
    last_frame_time_ = start_time_;
    
    std::cout << "[FrameGrabberThread] Capture loop started" << std::endl;
    
    // 2ï¸âƒ£ ä¸»å¾ªç¯
    while (running_) {
        // æ£€æŸ¥æš‚åœçŠ¶æ€
        if (paused_) {
            std::this_thread::sleep_for(std::chrono::milliseconds(10));
            continue;
        }
        
        // 3ï¸âƒ£ æ•è·å¸§
        auto capture_start = std::chrono::steady_clock::now();
        FrameData frame = grabber_->captureFrame(100);  // è¶…æ—¶100ms
        
        if (!frame.data) {
            // æ•è·å¤±è´¥ (å¯èƒ½æ˜¯è¶…æ—¶æˆ–é”™è¯¯)
            continue;
        }
        
        // 4ï¸âƒ£ è®¾ç½®æ—¶é—´æˆ³ (ç›¸å¯¹äºå¼€å§‹æ—¶é—´)
        frame.timestamp_us = std::chrono::duration_cast<std::chrono::microseconds>(
            capture_start - start_time_
        ).count();
        
        // 5ï¸âƒ£ æ¨é€åˆ°é˜Ÿåˆ—
        if (!queue_->push(std::move(frame), std::chrono::milliseconds(100))) {
            // é˜Ÿåˆ—å·²æ»¡,ä¸¢å¸§
            dropped_count_++;
            notifyDropped(dropped_count_);
        } else {
            // æˆåŠŸæ¨é€
            frame_count_++;
            
            // æ›´æ–°FPS
            updateFPS();
            
            // æ¯30å¸§é€šçŸ¥ä¸€æ¬¡è¿›åº¦ (å‡å°‘å›è°ƒå¼€é”€)
            if (frame_count_ % 30 == 0) {
                notifyProgress();
            }
        }
        
        // 6ï¸âƒ£ å¸§ç‡æ§åˆ¶
        waitForNextFrame();
    }
    
    std::cout << "[FrameGrabberThread] Capture loop stopped" << std::endl;
}
```

#### å…³é”®ç‚¹è§£æ

**ä¸ºä»€ä¹ˆæ¯30å¸§æ‰é€šçŸ¥ä¸€æ¬¡è¿›åº¦?**

```cpp
// âŒ æ¯å¸§éƒ½é€šçŸ¥: æ€§èƒ½å¼€é”€å¤§
if (frame_count_ > 0) {
    notifyProgress();  // 60æ¬¡/ç§’,é¢‘ç¹è·å–GIL
}

// âœ… æ¯30å¸§é€šçŸ¥: å¹³è¡¡æ€§èƒ½å’Œå®æ—¶æ€§
if (frame_count_ % 30 == 0) {
    notifyProgress();  // 2æ¬¡/ç§’,å¼€é”€å°
}
```

**åŸå› **:
- Pythonå›è°ƒéœ€è¦è·å–GIL,æœ‰æ€§èƒ½å¼€é”€
- UIæ›´æ–°é¢‘ç‡ä¸éœ€è¦60fps,2fpsè¶³å¤Ÿ
- å‡å°‘è·¨è¯­è¨€è°ƒç”¨æ¬¡æ•°

---

## ç²¾ç¡®å¸§ç‡æ§åˆ¶

### å¸§ç‡æ§åˆ¶ç®—æ³•

```mermaid
sequenceDiagram
    participant Loop as é‡‡é›†å¾ªç¯
    participant Timer as å¸§ç‡æ§åˆ¶å™¨
    participant Clock as ç³»ç»Ÿæ—¶é’Ÿ
    
    Note over Loop: ç›®æ ‡: 60fps (16.67ms/å¸§)
    
    loop æ¯å¸§
        Loop->>Clock: è®°å½•å¼€å§‹æ—¶é—´ t0
        Loop->>Loop: captureFrame()
        Loop->>Loop: push to queue
        Loop->>Clock: å½“å‰æ—¶é—´ t1
        
        Loop->>Timer: waitForNextFrame()
        activate Timer
        
        Timer->>Timer: elapsed = t1 - t0
        Timer->>Timer: sleep_time = 16.67ms - elapsed
        
        alt sleep_time > 0
            Timer->>Clock: sleep_for(sleep_time)
            Note over Timer: ç²¾ç¡®ç­‰å¾…
        else sleep_time <= 0
            Note over Timer: å·²è¶…æ—¶,ç«‹å³ç»§ç»­
        end
        
        Timer->>Clock: æ›´æ–° last_frame_time
        deactivate Timer
    end
```

### waitForNextFrame() å®ç°

```cpp
void FrameGrabberThread::waitForNextFrame() {
    auto now = std::chrono::steady_clock::now();
    auto elapsed = now - last_frame_time_;
    
    // å¦‚æœè¿˜æ²¡åˆ°ä¸‹ä¸€å¸§æ—¶é—´,ç­‰å¾…
    if (elapsed < frame_interval_) {
        auto sleep_duration = frame_interval_ - elapsed;
        std::this_thread::sleep_for(sleep_duration);
    }
    
    // æ›´æ–°æ—¶é—´æˆ³ (ä½¿ç”¨å®é™…æ—¶é—´,è€Œéç†è®ºæ—¶é—´)
    last_frame_time_ = std::chrono::steady_clock::now();
}
```

### æ—¶é—´æ¼‚ç§»é—®é¢˜

````carousel
**é—®é¢˜: ç´¯ç§¯è¯¯å·®**

```cpp
// âŒ é”™è¯¯: åŸºäºç†è®ºæ—¶é—´
void badWaitForNextFrame() {
    std::this_thread::sleep_for(frame_interval_);
    // é—®é¢˜: sleepå¯èƒ½ä¸ç²¾ç¡®,è¯¯å·®ç´¯ç§¯
}
```

**ç»“æœ**:
- ç†è®ºå¸§ç‡: 60fps
- å®é™…å¸§ç‡: 59.5fps (è¯¯å·®ç´¯ç§¯)
- 1å°æ—¶å: ä¸¢å¤±180å¸§!

<!-- slide -->

**è§£å†³: åŸºäºç»å¯¹æ—¶é—´**

```cpp
// âœ… æ­£ç¡®: åŸºäºç»å¯¹æ—¶é—´æˆ³
void goodWaitForNextFrame() {
    auto now = std::chrono::steady_clock::now();
    auto elapsed = now - last_frame_time_;
    
    if (elapsed < frame_interval_) {
        std::this_thread::sleep_for(frame_interval_ - elapsed);
    }
    
    last_frame_time_ = std::chrono::steady_clock::now();
}
```

**ç»“æœ**:
- ç†è®ºå¸§ç‡: 60fps
- å®é™…å¸§ç‡: 60.0fps (è‡ªåŠ¨è¡¥å¿)
- 1å°æ—¶å: 0å¸§è¯¯å·®! âœ…
````

### FPSè®¡ç®— - æ»‘åŠ¨çª—å£ç®—æ³•

```cpp
void FrameGrabberThread::updateFPS() {
    auto now = std::chrono::steady_clock::now();
    fps_samples_.push_back(now);
    
    // ä¿æŒæœ€è¿‘60å¸§çš„æ—¶é—´æˆ³
    if (fps_samples_.size() > FPS_SAMPLE_SIZE) {
        fps_samples_.pop_front();
    }
    
    // è®¡ç®—å¹³å‡FPS
    if (fps_samples_.size() >= 2) {
        auto duration = fps_samples_.back() - fps_samples_.front();
        auto seconds = std::chrono::duration<double>(duration).count();
        current_fps_ = (fps_samples_.size() - 1) / seconds;
    }
}
```

**ç®—æ³•ä¼˜åŠ¿**:
- âœ… å¹³æ»‘FPSæ³¢åŠ¨
- âœ… åæ˜ æœ€è¿‘1ç§’çš„å®é™…å¸§ç‡
- âœ… è‡ªåŠ¨é€‚åº”æ€§èƒ½å˜åŒ–

---

## Pybind11å›è°ƒæœºåˆ¶

### å›è°ƒå‡½æ•°è®¾è®¡

```mermaid
graph TB
    subgraph "C++ FrameGrabberThread"
        Event[äº‹ä»¶å‘ç”Ÿ<br/>è¿›åº¦/é”™è¯¯/ä¸¢å¸§]
        Check{æœ‰å›è°ƒ?}
        GIL[è·å–Python GIL]
        Call[è°ƒç”¨Pythonå‡½æ•°]
        Release[é‡Šæ”¾GIL]
    end
    
    subgraph "Python VideoService"
        PyFunc[Pythonå›è°ƒå‡½æ•°]
        Signal[å‘é€Qtä¿¡å·]
    end
    
    subgraph "QML UI"
        UI[æ›´æ–°ç•Œé¢]
    end
    
    Event --> Check
    Check -->|æ˜¯| GIL
    Check -->|å¦| Event
    GIL --> Call
    Call --> PyFunc
    PyFunc --> Signal
    Signal --> UI
    Call --> Release
    
    style GIL fill:#FFA500
    style Call fill:#87CEEB
```

### notifyProgress() å®ç°

```cpp
void FrameGrabberThread::notifyProgress() {
    if (!on_progress_) {
        return;  // æ²¡æœ‰è®¾ç½®å›è°ƒ
    }
    
    try {
        // ğŸ”’ è·å–Python GIL (Global Interpreter Lock)
        py::gil_scoped_acquire acquire;
        
        // è°ƒç”¨Pythonå›è°ƒ
        on_progress_(
            frame_count_.load(),
            queue_->size(),
            current_fps_.load()
        );
        
        // ğŸ”“ GILè‡ªåŠ¨é‡Šæ”¾ (RAII)
    } catch (const std::exception& e) {
        std::cerr << "[FrameGrabberThread] Callback error: " << e.what() << std::endl;
    }
}
```

### Python GIL ç®¡ç†

> [!IMPORTANT]
> **Python GIL (Global Interpreter Lock)**
> 
> Pythonçš„å…¨å±€è§£é‡Šå™¨é”,åŒä¸€æ—¶åˆ»åªå…è®¸ä¸€ä¸ªçº¿ç¨‹æ‰§è¡ŒPythonä»£ç ã€‚
> 
> **C++è°ƒç”¨Pythonæ—¶å¿…é¡»è·å–GIL!**

```cpp
// âŒ é”™è¯¯: æ²¡æœ‰è·å–GIL
void badCallback() {
    on_progress_(frame_count_, queue_->size(), current_fps_);
    // ğŸ’¥ å´©æºƒ! Pythonè§£é‡Šå™¨æœªé”å®š
}

// âœ… æ­£ç¡®: ä½¿ç”¨RAIIè·å–GIL
void goodCallback() {
    py::gil_scoped_acquire acquire;  // è·å–GIL
    on_progress_(frame_count_, queue_->size(), current_fps_);
    // GILè‡ªåŠ¨é‡Šæ”¾
}
```

### Pybind11ç»‘å®šä»£ç 

```cpp
#include <pybind11/pybind11.h>
#include <pybind11/functional.h>

namespace py = pybind11;

PYBIND11_MODULE(video_analysis_cpp, m) {
    py::class_<FrameGrabberThread, std::shared_ptr<FrameGrabberThread>>(m, "FrameGrabberThread")
        .def(py::init<
            std::shared_ptr<IScreenGrabber>,
            std::shared_ptr<ThreadSafeQueue<FrameData>>,
            int
        >())
        .def("start", &FrameGrabberThread::start)
        .def("stop", &FrameGrabberThread::stop)
        .def("pause", &FrameGrabberThread::pause)
        .def("resume", &FrameGrabberThread::resume)
        .def("get_frame_count", &FrameGrabberThread::getFrameCount)
        .def("get_dropped_count", &FrameGrabberThread::getDroppedCount)
        .def("get_current_fps", &FrameGrabberThread::getCurrentFPS)
        .def("is_running", &FrameGrabberThread::isRunning)
        
        // ç»‘å®šå›è°ƒå‡½æ•°
        .def("set_progress_callback", &FrameGrabberThread::setProgressCallback)
        .def("set_error_callback", &FrameGrabberThread::setErrorCallback)
        .def("set_dropped_callback", &FrameGrabberThread::setDroppedCallback);
}
```

---

## æ€§èƒ½ç›‘æ§ä¸ç»Ÿè®¡

### ç»Ÿè®¡æŒ‡æ ‡

| æŒ‡æ ‡ | è¯´æ˜ | è®¡ç®—æ–¹å¼ |
|------|------|---------|
| **frame_count** | å·²æ•è·å¸§æ•° | ç´¯åŠ  |
| **dropped_count** | ä¸¢å¸§æ•° | pushå¤±è´¥æ¬¡æ•° |
| **current_fps** | å®é™…å¸§ç‡ | æ»‘åŠ¨çª—å£å¹³å‡ |
| **queue_size** | é˜Ÿåˆ—æ·±åº¦ | `queue_->size()` |

### æ€§èƒ½ç›‘æ§é¢æ¿

```mermaid
graph LR
    subgraph "C++ é‡‡é›†çº¿ç¨‹"
        Stats[ç»Ÿè®¡æ•°æ®<br/>å¸§æ•°/ä¸¢å¸§/FPS]
    end
    
    subgraph "Python æœåŠ¡å±‚"
        Service[VideoService<br/>æ¥æ”¶å›è°ƒ]
    end
    
    subgraph "QML UI"
        FPS[FPSæ˜¾ç¤º<br/>60.0 fps]
        Frames[å¸§æ•°æ˜¾ç¤º<br/>1800 frames]
        Dropped[ä¸¢å¸§è­¦å‘Š<br/>0 dropped]
        Queue[é˜Ÿåˆ—æ·±åº¦<br/>15/30]
    end
    
    Stats -.å›è°ƒ.-> Service
    Service --> FPS
    Service --> Frames
    Service --> Dropped
    Service --> Queue
    
    style Stats fill:#87CEEB
    style Service fill:#90EE90
```

---

## å®æˆ˜ä½¿ç”¨æŒ‡å—

### C++å±‚ä½¿ç”¨

```cpp
#include "FrameGrabberThread.h"
#include "GrabberFactory.h"

int main() {
    // 1ï¸âƒ£ åˆ›å»ºé‡‡é›†å™¨
    auto grabber = GrabberFactory::createGrabber(GrabberType::DXGI);
    
    // 2ï¸âƒ£ åˆ›å»ºé˜Ÿåˆ—
    auto queue = std::make_shared<ThreadSafeQueue<FrameData>>(30);
    
    // 3ï¸âƒ£ åˆ›å»ºé‡‡é›†çº¿ç¨‹
    auto grabber_thread = std::make_shared<FrameGrabberThread>(
        grabber, queue, 60  // 60fps
    );
    
    // 4ï¸âƒ£ è®¾ç½®å›è°ƒ (å¯é€‰,ç”¨äºç›‘æ§)
    grabber_thread->setProgressCallback([](int64_t frames, int queue_size, double fps) {
        std::cout << "Frames: " << frames 
                  << ", Queue: " << queue_size 
                  << ", FPS: " << fps << std::endl;
    });
    
    // 5ï¸âƒ£ å¯åŠ¨
    grabber_thread->start();
    
    // 6ï¸âƒ£ è¿è¡Œä¸€æ®µæ—¶é—´
    std::this_thread::sleep_for(std::chrono::seconds(10));
    
    // 7ï¸âƒ£ åœæ­¢
    grabber_thread->stop();
    
    return 0;
}
```

### Pythonå±‚ä½¿ç”¨

```python
import video_analysis_cpp

class VideoService:
    def __init__(self):
        # åˆ›å»ºC++å¯¹è±¡
        self.grabber = video_analysis_cpp.create_grabber("DXGI")
        self.queue = video_analysis_cpp.ThreadSafeQueue(30)
        self.grabber_thread = video_analysis_cpp.FrameGrabberThread(
            self.grabber, self.queue, 60
        )
        
        # è®¾ç½®å›è°ƒ
        self.grabber_thread.set_progress_callback(self._on_progress)
        self.grabber_thread.set_error_callback(self._on_error)
        self.grabber_thread.set_dropped_callback(self._on_dropped)
    
    def _on_progress(self, frames: int, queue_size: int, fps: float):
        """è¿›åº¦å›è°ƒ (åœ¨C++çº¿ç¨‹ä¸­è°ƒç”¨)"""
        print(f"ğŸ“Š Frames: {frames}, Queue: {queue_size}, FPS: {fps:.1f}")
        # å‘é€Qtä¿¡å·åˆ°UI
        self.progress_signal.emit(frames, fps)
    
    def _on_error(self, error: str):
        """é”™è¯¯å›è°ƒ"""
        print(f"âŒ Error: {error}")
        self.error_signal.emit(error)
    
    def _on_dropped(self, count: int):
        """ä¸¢å¸§å›è°ƒ"""
        print(f"âš ï¸ Dropped frames: {count}")
        self.dropped_signal.emit(count)
    
    def start_recording(self):
        """å¯åŠ¨å½•åˆ¶"""
        self.grabber_thread.start()
    
    def stop_recording(self):
        """åœæ­¢å½•åˆ¶"""
        self.grabber_thread.stop()
```

### QML UIé›†æˆ

```qml
// RecordingPage.qml
Rectangle {
    Column {
        // FPSæ˜¾ç¤º
        Text {
            text: "FPS: " + videoViewModel.currentFps.toFixed(1)
            font.pixelSize: 24
            color: videoViewModel.currentFps >= 59 ? "green" : "orange"
        }
        
        // å¸§æ•°æ˜¾ç¤º
        Text {
            text: "Frames: " + videoViewModel.frameCount
        }
        
        // ä¸¢å¸§è­¦å‘Š
        Text {
            text: videoViewModel.droppedCount > 0 
                  ? "âš ï¸ Dropped: " + videoViewModel.droppedCount 
                  : "âœ… No frames dropped"
            color: videoViewModel.droppedCount > 0 ? "red" : "green"
        }
        
        // é˜Ÿåˆ—æ·±åº¦
        ProgressBar {
            value: videoViewModel.queueSize / 30.0
            text: videoViewModel.queueSize + " / 30"
        }
    }
}
```

---

## æ€»ç»“

`FrameGrabberThread` æ˜¯è§†é¢‘æµå¤„ç†çš„ç”Ÿäº§è€…æ ¸å¿ƒ,å…³é”®ç‰¹æ€§:

âœ… **ç²¾ç¡®å¸§ç‡**: åŸºäºç»å¯¹æ—¶é—´æˆ³,è‡ªåŠ¨è¡¥å¿è¯¯å·®  
âœ… **é«˜æ€§èƒ½**: CPUå ç”¨<15%,é›¶æ‹·è´ä¼ é€’  
âœ… **å¯è§‚æµ‹**: å®æ—¶FPS/ä¸¢å¸§ç»Ÿè®¡  
âœ… **è·¨è¯­è¨€é€šä¿¡**: Pybind11å›è°ƒ + GILç®¡ç†

**ä¸‹ä¸€æ­¥**: å®ç°æ¶ˆè´¹è€… [3.2.3 å¸§ç¼–ç å™¨è®¾è®¡](file:///d:/ç¼–ç¨‹/é¡¹ç›®/AiVideoAnalsysSystem/.agent/ç¬¬ä¸‰ç« /3.2.3_å¸§ç¼–ç å™¨è®¾è®¡.md)
