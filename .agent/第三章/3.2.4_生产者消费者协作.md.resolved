# 3.2.4 ç”Ÿäº§è€…-æ¶ˆè´¹è€…åä½œæœºåˆ¶

> **ç³»ç»Ÿé›†æˆæ ¸å¿ƒ**  
> æœ¬æ–‡æ¡£è¯¦è§£ `FrameGrabberThread` (ç”Ÿäº§è€…) å’Œ `FrameEncoder` (æ¶ˆè´¹è€…) å¦‚ä½•é€šè¿‡ `ThreadSafeQueue` åä½œ,ä»¥åŠå¦‚ä½•é€šè¿‡ Pybind11 ä¸ Python å±‚é€šä¿¡,æœ€ç»ˆåœ¨ QML UI ä¸­å±•ç¤ºã€‚è¿™æ˜¯æ•´ä¸ªè§†é¢‘æµå¤„ç†ç³»ç»Ÿçš„é›†æˆè®¾è®¡ã€‚

---

## ğŸ“‹ ç›®å½•

1. [æ¨¡å—æ¦‚è¿°ä¸å®šä½](#æ¨¡å—æ¦‚è¿°ä¸å®šä½)
2. [æ•´ä½“æ¶æ„è®¾è®¡](#æ•´ä½“æ¶æ„è®¾è®¡)
3. [C++å±‚å¤šçº¿ç¨‹åä½œ](#cå±‚å¤šçº¿ç¨‹åä½œ)
4. [Pybind11è·¨è¯­è¨€é€šä¿¡](#pybind11è·¨è¯­è¨€é€šä¿¡)
5. [PythonæœåŠ¡å±‚å°è£…](#pythonæœåŠ¡å±‚å°è£…)
6. [QML UIé›†æˆ](#qml-uié›†æˆ)
7. [å®Œæ•´æ•°æ®æµ](#å®Œæ•´æ•°æ®æµ)
8. [é”™è¯¯å¤„ç†ä¸æ¢å¤](#é”™è¯¯å¤„ç†ä¸æ¢å¤)
9. [å®æˆ˜é›†æˆç¤ºä¾‹](#å®æˆ˜é›†æˆç¤ºä¾‹)

---

## æ¨¡å—æ¦‚è¿°ä¸å®šä½

### ä¸‰å±‚æ¶æ„å…¨æ™¯

```mermaid
graph TB
    subgraph "QML UIå±‚"
        UI[RecordingPage.qml<br/>å½•åˆ¶ç•Œé¢]
        Display[å®æ—¶æ˜¾ç¤º<br/>FPS/å¸§æ•°/è¿›åº¦]
    end
    
    subgraph "Pythonä¸šåŠ¡å±‚"
        VM[VideoViewModel<br/>PySide6 QObject]
        Service[VideoService<br/>ä¸šåŠ¡é€»è¾‘]
    end
    
    subgraph "C++æ ¸å¿ƒå±‚"
        Recorder[ScreenRecorder<br/>å½•åˆ¶æ§åˆ¶å™¨]
        Grabber[FrameGrabberThread<br/>é‡‡é›†çº¿ç¨‹]
        Queue[ThreadSafeQueue<br/>å¸§é˜Ÿåˆ—]
        Encoder[FrameEncoder<br/>ç¼–ç çº¿ç¨‹]
        FFmpeg[FFmpegWrapper<br/>ç¼–ç å™¨]
    end
    
    subgraph "ç³»ç»Ÿå±‚"
        Screen[å±å¹•<br/>DXGI/GDI/X11]
        File[è§†é¢‘æ–‡ä»¶<br/>output.mp4]
    end
    
    UI <-->|Signal/Slot| VM
    VM <--> Service
    Service <-->|Pybind11| Recorder
    Recorder --> Grabber
    Recorder --> Encoder
    Grabber -->|push| Queue
    Queue -->|pop| Encoder
    Grabber <--> Screen
    Encoder --> FFmpeg
    FFmpeg --> File
    
    Grabber -.å›è°ƒ.-> Service
    Encoder -.å›è°ƒ.-> Service
    
    style Recorder fill:#FFB6C1,stroke:#333,stroke-width:3px
    style Service fill:#90EE90
    style UI fill:#FFD700
```

### æ ¸å¿ƒåä½œå…³ç³»

| ç»„ä»¶ | è§’è‰² | é€šä¿¡æ–¹å¼ | èŒè´£ |
|------|------|---------|------|
| **FrameGrabberThread** | ç”Ÿäº§è€… | push â†’ Queue | æ•è·å±å¹•å¸§ |
| **ThreadSafeQueue** | ç¼“å†²åŒº | çº¿ç¨‹å®‰å…¨ | è§£è€¦ç”Ÿäº§/æ¶ˆè´¹ |
| **FrameEncoder** | æ¶ˆè´¹è€… | pop â† Queue | ç¼–ç å¹¶å†™å…¥æ–‡ä»¶ |
| **Pybind11** | æ¡¥æ¢ | C++ â†” Python | è·¨è¯­è¨€è°ƒç”¨ |
| **VideoService** | å°è£…å±‚ | Python API | ä¸šåŠ¡é€»è¾‘ |
| **VideoViewModel** | å±•ç¤ºå±‚ | Qt Signal/Slot | UIæ•°æ®ç»‘å®š |

---

## æ•´ä½“æ¶æ„è®¾è®¡

### ScreenRecorder - é¡¶å±‚æ§åˆ¶å™¨

```cpp
#pragma once

#include <memory>
#include <string>
#include "IScreenGrabber.h"
#include "FrameGrabberThread.h"
#include "FrameEncoder.h"
#include "ThreadSafeQueue.h"

/**
 * @brief å±å¹•å½•åˆ¶å™¨ - é¡¶å±‚æ§åˆ¶å™¨
 * 
 * åè°ƒé‡‡é›†çº¿ç¨‹å’Œç¼–ç çº¿ç¨‹,æä¾›ç»Ÿä¸€çš„å½•åˆ¶æ¥å£
 */
class ScreenRecorder {
public:
    ScreenRecorder();
    ~ScreenRecorder();
    
    /**
     * @brief å¼€å§‹å½•åˆ¶
     * @param output_path è¾“å‡ºæ–‡ä»¶è·¯å¾„
     * @param width è§†é¢‘å®½åº¦
     * @param height è§†é¢‘é«˜åº¦
     * @param fps å¸§ç‡
     * @return æˆåŠŸè¿”å›true
     */
    bool startRecording(
        const std::string& output_path,
        int width = 1920,
        int height = 1080,
        int fps = 60
    );
    
    /**
     * @brief åœæ­¢å½•åˆ¶
     */
    void stopRecording();
    
    /**
     * @brief æš‚åœå½•åˆ¶
     */
    void pauseRecording();
    
    /**
     * @brief æ¢å¤å½•åˆ¶
     */
    void resumeRecording();
    
    /**
     * @brief è·å–ç»Ÿè®¡ä¿¡æ¯
     */
    int64_t getFrameCount() const;
    int64_t getEncodedCount() const;
    int64_t getDroppedCount() const;
    double getCurrentFPS() const;
    bool isRecording() const;
    
    // Pybind11å›è°ƒ
    using ProgressCallback = std::function<void(int64_t, double, int64_t)>;
    using ErrorCallback = std::function<void(const std::string&)>;
    
    void setProgressCallback(ProgressCallback callback);
    void setErrorCallback(ErrorCallback callback);
    
private:
    std::shared_ptr<IScreenGrabber> grabber_;
    std::shared_ptr<ThreadSafeQueue<FrameData>> queue_;
    std::shared_ptr<FrameGrabberThread> grabber_thread_;
    std::shared_ptr<FrameEncoder> encoder_;
    
    bool recording_ = false;
};
```

### åä½œæ—¶åºå›¾

```mermaid
sequenceDiagram
    participant Python as VideoService
    participant Recorder as ScreenRecorder
    participant Grabber as FrameGrabberThread
    participant Queue as ThreadSafeQueue
    participant Encoder as FrameEncoder
    
    Note over Python: ç”¨æˆ·ç‚¹å‡»"å¼€å§‹å½•åˆ¶"
    Python->>Recorder: startRecording("output.mp4")
    
    activate Recorder
    Recorder->>Recorder: åˆ›å»ºé‡‡é›†å™¨/é˜Ÿåˆ—/çº¿ç¨‹
    Recorder->>Grabber: start()
    Recorder->>Encoder: start()
    Recorder-->>Python: true (æˆåŠŸ)
    deactivate Recorder
    
    activate Grabber
    activate Encoder
    
    par é‡‡é›†çº¿ç¨‹
        loop æ¯16.67ms (60fps)
            Grabber->>Grabber: captureFrame()
            Grabber->>Queue: push(frame)
            
            alt æ¯30å¸§
                Grabber->>Python: è¿›åº¦å›è°ƒ(å¸§æ•°, FPS)
                Python->>Python: å‘é€Qtä¿¡å·
            end
        end
    and ç¼–ç çº¿ç¨‹
        loop æŒç»­è¿è¡Œ
            Encoder->>Queue: pop(frame, 100ms)
            alt é˜Ÿåˆ—éç©º
                Encoder->>Encoder: convertPixelFormat()
                Encoder->>Encoder: encodeFrame()
                
                alt æ¯30å¸§
                    Encoder->>Python: è¿›åº¦å›è°ƒ(å·²ç¼–ç , æ–‡ä»¶å¤§å°)
                    Python->>Python: å‘é€Qtä¿¡å·
                end
            end
        end
    end
    
    Note over Python: ç”¨æˆ·ç‚¹å‡»"åœæ­¢å½•åˆ¶"
    Python->>Recorder: stopRecording()
    
    Recorder->>Grabber: stop()
    Recorder->>Queue: stop()
    Recorder->>Encoder: stop()
    
    deactivate Grabber
    deactivate Encoder
    
    Encoder->>Python: å®Œæˆå›è°ƒ(æ€»å¸§æ•°, æ–‡ä»¶è·¯å¾„)
    Python->>Python: å‘é€Qtä¿¡å·
```

---

## C++å±‚å¤šçº¿ç¨‹åä½œ

### startRecording() å®ç°

```cpp
bool ScreenRecorder::startRecording(
    const std::string& output_path,
    int width, int height, int fps
) {
    if (recording_) {
        return false;  // å·²åœ¨å½•åˆ¶
    }
    
    // 1ï¸âƒ£ åˆ›å»ºå±å¹•é‡‡é›†å™¨
    grabber_ = GrabberFactory::createGrabber(GrabberType::DXGI);
    if (!grabber_) {
        notifyError("Failed to create screen grabber");
        return false;
    }
    
    // 2ï¸âƒ£ åˆ›å»ºçº¿ç¨‹å®‰å…¨é˜Ÿåˆ— (å®¹é‡30å¸§)
    queue_ = std::make_shared<ThreadSafeQueue<FrameData>>(30);
    
    // 3ï¸âƒ£ åˆ›å»ºé‡‡é›†çº¿ç¨‹
    grabber_thread_ = std::make_shared<FrameGrabberThread>(
        grabber_, queue_, fps
    );
    
    // 4ï¸âƒ£ è®¾ç½®é‡‡é›†çº¿ç¨‹å›è°ƒ
    grabber_thread_->setProgressCallback([this](int64_t frames, int queue_size, double fps) {
        // è½¬å‘åˆ°Pythonå±‚
        if (on_progress_) {
            on_progress_(frames, fps, queue_size);
        }
    });
    
    grabber_thread_->setErrorCallback([this](const std::string& error) {
        if (on_error_) {
            on_error_("Grabber error: " + error);
        }
    });
    
    // 5ï¸âƒ£ åˆ›å»ºç¼–ç å™¨é…ç½®
    EncoderConfig config;
    config.output_path = output_path;
    config.width = width;
    config.height = height;
    config.fps = fps;
    config.bitrate = 8000000;  // 8Mbps
    config.crf = 23;
    config.preset = "fast";
    config.codec = "libx264";
    
    // 6ï¸âƒ£ åˆ›å»ºç¼–ç å™¨
    encoder_ = std::make_shared<FrameEncoder>(queue_, config);
    
    // 7ï¸âƒ£ è®¾ç½®ç¼–ç å™¨å›è°ƒ
    encoder_->setProgressCallback([this](int64_t encoded, int64_t file_size) {
        // å¯ä»¥åœ¨è¿™é‡Œæ·»åŠ ç¼–ç è¿›åº¦é€šçŸ¥
    });
    
    encoder_->setFinishedCallback([this](int64_t total_frames, const std::string& path) {
        std::cout << "Recording finished: " << total_frames << " frames" << std::endl;
    });
    
    // 8ï¸âƒ£ å¯åŠ¨çº¿ç¨‹
    grabber_thread_->start();
    encoder_->start();
    
    recording_ = true;
    
    std::cout << "[ScreenRecorder] Recording started: " << output_path << std::endl;
    return true;
}
```

### stopRecording() å®ç°

```cpp
void ScreenRecorder::stopRecording() {
    if (!recording_) {
        return;
    }
    
    std::cout << "[ScreenRecorder] Stopping recording..." << std::endl;
    
    // 1ï¸âƒ£ åœæ­¢é‡‡é›†çº¿ç¨‹
    if (grabber_thread_) {
        grabber_thread_->stop();
    }
    
    // 2ï¸âƒ£ åœæ­¢é˜Ÿåˆ— (å”¤é†’ç¼–ç çº¿ç¨‹)
    if (queue_) {
        queue_->stop();
    }
    
    // 3ï¸âƒ£ åœæ­¢ç¼–ç çº¿ç¨‹
    if (encoder_) {
        encoder_->stop();
    }
    
    // 4ï¸âƒ£ ç­‰å¾…çº¿ç¨‹ç»“æŸ (åœ¨ææ„å‡½æ•°ä¸­è‡ªåŠ¨å®Œæˆ)
    
    recording_ = false;
    
    std::cout << "[ScreenRecorder] Recording stopped" << std::endl;
}
```

### çº¿ç¨‹ç”Ÿå‘½å‘¨æœŸç®¡ç†

```mermaid
stateDiagram-v2
    [*] --> Idle: æ„é€ å‡½æ•°
    Idle --> Starting: startRecording()
    
    state Starting {
        [*] --> CreateGrabber
        CreateGrabber --> CreateQueue
        CreateQueue --> CreateThreads
        CreateThreads --> StartThreads
        StartThreads --> [*]
    }
    
    Starting --> Recording: å¯åŠ¨æˆåŠŸ
    Starting --> Idle: å¯åŠ¨å¤±è´¥
    
    state Recording {
        [*] --> Capturing
        Capturing --> Encoding: é€šè¿‡é˜Ÿåˆ—
        
        state Capturing {
            [*] --> GrabFrame
            GrabFrame --> PushQueue
            PushQueue --> GrabFrame
        }
        
        state Encoding {
            [*] --> PopQueue
            PopQueue --> Convert
            Convert --> Encode
            Encode --> Write
            Write --> PopQueue
        }
    }
    
    Recording --> Stopping: stopRecording()
    
    state Stopping {
        [*] --> StopGrabber
        StopGrabber --> StopQueue
        StopQueue --> StopEncoder
        StopEncoder --> WaitThreads
        WaitThreads --> [*]
    }
    
    Stopping --> Idle: åœæ­¢å®Œæˆ
    Idle --> [*]: ææ„å‡½æ•°
```

---

## Pybind11è·¨è¯­è¨€é€šä¿¡

### C++ç«¯ç»‘å®š

```cpp
#include <pybind11/pybind11.h>
#include <pybind11/functional.h>
#include <pybind11/stl.h>

namespace py = pybind11;

PYBIND11_MODULE(video_analysis_cpp, m) {
    m.doc() = "AI Video Analysis System - C++ Core Module";
    
    // ScreenRecorderç±»
    py::class_<ScreenRecorder, std::shared_ptr<ScreenRecorder>>(m, "ScreenRecorder")
        .def(py::init<>())
        .def("start_recording", &ScreenRecorder::startRecording,
             py::arg("output_path"),
             py::arg("width") = 1920,
             py::arg("height") = 1080,
             py::arg("fps") = 60,
             "å¼€å§‹å½•åˆ¶å±å¹•")
        .def("stop_recording", &ScreenRecorder::stopRecording,
             "åœæ­¢å½•åˆ¶")
        .def("pause_recording", &ScreenRecorder::pauseRecording,
             "æš‚åœå½•åˆ¶")
        .def("resume_recording", &ScreenRecorder::resumeRecording,
             "æ¢å¤å½•åˆ¶")
        .def("get_frame_count", &ScreenRecorder::getFrameCount,
             "è·å–å·²æ•è·å¸§æ•°")
        .def("get_encoded_count", &ScreenRecorder::getEncodedCount,
             "è·å–å·²ç¼–ç å¸§æ•°")
        .def("get_dropped_count", &ScreenRecorder::getDroppedCount,
             "è·å–ä¸¢å¸§æ•°")
        .def("get_current_fps", &ScreenRecorder::getCurrentFPS,
             "è·å–å½“å‰FPS")
        .def("is_recording", &ScreenRecorder::isRecording,
             "æ˜¯å¦æ­£åœ¨å½•åˆ¶")
        
        // å›è°ƒå‡½æ•°
        .def("set_progress_callback", &ScreenRecorder::setProgressCallback,
             "è®¾ç½®è¿›åº¦å›è°ƒ: callback(frames, fps, queue_size)")
        .def("set_error_callback", &ScreenRecorder::setErrorCallback,
             "è®¾ç½®é”™è¯¯å›è°ƒ: callback(error_message)");
}
```

### Python GILå¤„ç†

> [!IMPORTANT]
> **Python GIL (Global Interpreter Lock) ç®¡ç†**
> 
> ä»C++çº¿ç¨‹è°ƒç”¨Pythonå‡½æ•°æ—¶,å¿…é¡»è·å–GIL!

```cpp
// C++ç«¯å›è°ƒå®ç°
void ScreenRecorder::notifyProgress(int64_t frames, double fps, int64_t queue_size) {
    if (!on_progress_) {
        return;
    }
    
    try {
        // ğŸ”’ è·å–Python GIL
        py::gil_scoped_acquire acquire;
        
        // è°ƒç”¨Pythonå›è°ƒ
        on_progress_(frames, fps, queue_size);
        
        // ğŸ”“ GILè‡ªåŠ¨é‡Šæ”¾ (RAII)
    } catch (const py::error_already_set& e) {
        std::cerr << "[ScreenRecorder] Python callback error: " << e.what() << std::endl;
    }
}
```

### å¼‚å¸¸ä¼ æ’­

```mermaid
graph LR
    subgraph "C++å±‚"
        A[C++å¼‚å¸¸<br/>std::exception]
        B[æ•è·å¼‚å¸¸]
        C[è½¬æ¢ä¸ºå­—ç¬¦ä¸²]
    end
    
    subgraph "Pybind11"
        D[py::error_already_set]
        E[å¼‚å¸¸è½¬æ¢]
    end
    
    subgraph "Pythonå±‚"
        F[Pythonå¼‚å¸¸<br/>RuntimeError]
        G[try/exceptæ•è·]
        H[é”™è¯¯å¤„ç†]
    end
    
    A --> B
    B --> C
    C --> D
    D --> E
    E --> F
    F --> G
    G --> H
    
    style D fill:#FFA500
    style E fill:#FFA500
```

---

## PythonæœåŠ¡å±‚å°è£…

### VideoService å®Œæ•´å®ç°

```python
"""
è§†é¢‘æœåŠ¡ - å°è£…C++å½•åˆ¶åŠŸèƒ½
"""
import sys
from pathlib import Path
from PySide6.QtCore import QObject, Signal

# å¯¼å…¥C++æ¨¡å—
sys.path.insert(0, str(Path(__file__).parent.parent.parent / "build" / "python"))
import video_analysis_cpp as vac


class VideoService(QObject):
    """è§†é¢‘æœåŠ¡ - ä¸šåŠ¡é€»è¾‘å±‚"""
    
    # Qtä¿¡å·å®šä¹‰
    progress_updated = Signal(int, float, int)  # frames, fps, queue_size
    recording_finished = Signal(str)  # output_path
    error_occurred = Signal(str)  # error_message
    
    def __init__(self, parent=None):
        super().__init__(parent)
        
        # åˆ›å»ºC++å½•åˆ¶å™¨
        self.recorder = vac.ScreenRecorder()
        
        # è®¾ç½®C++å›è°ƒ
        self.recorder.set_progress_callback(self._on_progress)
        self.recorder.set_error_callback(self._on_error)
        
        print("[VideoService] Initialized")
    
    def _on_progress(self, frames: int, fps: float, queue_size: int):
        """
        C++è¿›åº¦å›è°ƒ (åœ¨C++çº¿ç¨‹ä¸­è°ƒç”¨)
        
        æ³¨æ„: æ­¤å‡½æ•°åœ¨C++çº¿ç¨‹ä¸­æ‰§è¡Œ,éœ€è¦é€šè¿‡Qtä¿¡å·ä¼ é€’åˆ°ä¸»çº¿ç¨‹
        """
        # å‘é€Qtä¿¡å·åˆ°ä¸»çº¿ç¨‹
        self.progress_updated.emit(frames, fps, queue_size)
    
    def _on_error(self, error: str):
        """C++é”™è¯¯å›è°ƒ"""
        self.error_occurred.emit(error)
    
    def start_recording(self, output_path: str, width: int = 1920, 
                       height: int = 1080, fps: int = 60) -> bool:
        """
        å¼€å§‹å½•åˆ¶
        
        Args:
            output_path: è¾“å‡ºæ–‡ä»¶è·¯å¾„
            width: è§†é¢‘å®½åº¦
            height: è§†é¢‘é«˜åº¦
            fps: å¸§ç‡
            
        Returns:
            æˆåŠŸè¿”å›True
        """
        try:
            success = self.recorder.start_recording(output_path, width, height, fps)
            if success:
                print(f"[VideoService] Recording started: {output_path}")
            else:
                print("[VideoService] Failed to start recording")
            return success
        except Exception as e:
            print(f"[VideoService] Error: {e}")
            self.error_occurred.emit(str(e))
            return False
    
    def stop_recording(self):
        """åœæ­¢å½•åˆ¶"""
        try:
            self.recorder.stop_recording()
            print("[VideoService] Recording stopped")
        except Exception as e:
            print(f"[VideoService] Error: {e}")
            self.error_occurred.emit(str(e))
    
    def pause_recording(self):
        """æš‚åœå½•åˆ¶"""
        self.recorder.pause_recording()
    
    def resume_recording(self):
        """æ¢å¤å½•åˆ¶"""
        self.recorder.resume_recording()
    
    def get_stats(self) -> dict:
        """è·å–ç»Ÿè®¡ä¿¡æ¯"""
        return {
            'frame_count': self.recorder.get_frame_count(),
            'encoded_count': self.recorder.get_encoded_count(),
            'dropped_count': self.recorder.get_dropped_count(),
            'current_fps': self.recorder.get_current_fps(),
            'is_recording': self.recorder.is_recording()
        }
```

---

## QML UIé›†æˆ

### VideoViewModel

```python
"""
è§†é¢‘ViewModel - è¿æ¥æœåŠ¡å±‚å’ŒUIå±‚
"""
from PySide6.QtCore import QObject, Signal, Slot, Property


class VideoViewModel(QObject):
    """è§†é¢‘ViewModel - MVVMæ¨¡å¼"""
    
    # ä¿¡å·å®šä¹‰
    frameCountChanged = Signal(int)
    currentFpsChanged = Signal(float)
    queueSizeChanged = Signal(int)
    droppedCountChanged = Signal(int)
    isRecordingChanged = Signal(bool)
    errorOccurred = Signal(str)
    
    def __init__(self, video_service, parent=None):
        super().__init__(parent)
        self.service = video_service
        
        # çŠ¶æ€
        self._frame_count = 0
        self._current_fps = 0.0
        self._queue_size = 0
        self._dropped_count = 0
        self._is_recording = False
        
        # è¿æ¥æœåŠ¡å±‚ä¿¡å·
        self.service.progress_updated.connect(self._on_progress)
        self.service.error_occurred.connect(self._on_error)
    
    def _on_progress(self, frames: int, fps: float, queue_size: int):
        """å¤„ç†è¿›åº¦æ›´æ–°"""
        self._frame_count = frames
        self._current_fps = fps
        self._queue_size = queue_size
        
        self.frameCountChanged.emit(frames)
        self.currentFpsChanged.emit(fps)
        self.queueSizeChanged.emit(queue_size)
    
    def _on_error(self, error: str):
        """å¤„ç†é”™è¯¯"""
        self.errorOccurred.emit(error)
    
    @Slot(str, int, int, int)
    def startRecording(self, output_path: str, width: int, height: int, fps: int):
        """å¼€å§‹å½•åˆ¶ (ä»QMLè°ƒç”¨)"""
        success = self.service.start_recording(output_path, width, height, fps)
        if success:
            self._is_recording = True
            self.isRecordingChanged.emit(True)
    
    @Slot()
    def stopRecording(self):
        """åœæ­¢å½•åˆ¶ (ä»QMLè°ƒç”¨)"""
        self.service.stop_recording()
        self._is_recording = False
        self.isRecordingChanged.emit(False)
    
    # Properties
    @Property(int, notify=frameCountChanged)
    def frameCount(self):
        return self._frame_count
    
    @Property(float, notify=currentFpsChanged)
    def currentFps(self):
        return self._current_fps
    
    @Property(int, notify=queueSizeChanged)
    def queueSize(self):
        return self._queue_size
    
    @Property(bool, notify=isRecordingChanged)
    def isRecording(self):
        return self._is_recording
```

### QMLç•Œé¢

```qml
// RecordingPage.qml
import QtQuick 2.15
import QtQuick.Controls 2.15
import QtQuick.Layouts 1.15

Rectangle {
    id: root
    color: "#1e1e1e"
    
    ColumnLayout {
        anchors.centerIn: parent
        spacing: 20
        
        // FPSæ˜¾ç¤º
        Text {
            text: "FPS: " + videoViewModel.currentFps.toFixed(1)
            font.pixelSize: 48
            font.bold: true
            color: videoViewModel.currentFps >= 59 ? "#00ff00" : "#ff9900"
        }
        
        // å¸§æ•°æ˜¾ç¤º
        Text {
            text: "Frames: " + videoViewModel.frameCount
            font.pixelSize: 24
            color: "#ffffff"
        }
        
        // é˜Ÿåˆ—æ·±åº¦
        RowLayout {
            Text {
                text: "Queue: "
                color: "#ffffff"
            }
            ProgressBar {
                Layout.preferredWidth: 200
                value: videoViewModel.queueSize / 30.0
                
                background: Rectangle {
                    color: "#333333"
                    radius: 3
                }
                
                contentItem: Rectangle {
                    width: parent.visualPosition * parent.width
                    color: videoViewModel.queueSize > 25 ? "#ff0000" : "#00ff00"
                    radius: 3
                }
            }
            Text {
                text: videoViewModel.queueSize + " / 30"
                color: "#ffffff"
            }
        }
        
        // æ§åˆ¶æŒ‰é’®
        RowLayout {
            spacing: 10
            
            Button {
                text: videoViewModel.isRecording ? "åœæ­¢å½•åˆ¶" : "å¼€å§‹å½•åˆ¶"
                onClicked: {
                    if (videoViewModel.isRecording) {
                        videoViewModel.stopRecording()
                    } else {
                        videoViewModel.startRecording(
                            "recording.mp4",
                            1920, 1080, 60
                        )
                    }
                }
            }
        }
    }
    
    // é”™è¯¯æç¤º
    Connections {
        target: videoViewModel
        function onErrorOccurred(error) {
            errorDialog.text = error
            errorDialog.open()
        }
    }
}
```

---

## å®Œæ•´æ•°æ®æµ

### ç«¯åˆ°ç«¯æµç¨‹

```mermaid
graph TB
    subgraph "ç”¨æˆ·æ“ä½œ"
        A[ç‚¹å‡»"å¼€å§‹å½•åˆ¶"]
    end
    
    subgraph "QMLå±‚"
        B[RecordingPage.qml]
        C[Button.onClicked]
    end
    
    subgraph "Python ViewModel"
        D[VideoViewModel<br/>startRecording]
    end
    
    subgraph "Python Service"
        E[VideoService<br/>start_recording]
    end
    
    subgraph "Pybind11"
        F[è·¨è¯­è¨€è°ƒç”¨]
    end
    
    subgraph "C++ ScreenRecorder"
        G[startRecording]
        H[åˆ›å»ºçº¿ç¨‹]
    end
    
    subgraph "C++ é‡‡é›†çº¿ç¨‹"
        I[FrameGrabberThread]
        J[captureFrame]
        K[push to queue]
    end
    
    subgraph "C++ ç¼–ç çº¿ç¨‹"
        L[FrameEncoder]
        M[pop from queue]
        N[encode & write]
    end
    
    subgraph "å›è°ƒé€šçŸ¥"
        O[C++å›è°ƒ]
        P[Pythonä¿¡å·]
        Q[QMLæ›´æ–°]
    end
    
    A --> B
    B --> C
    C --> D
    D --> E
    E --> F
    F --> G
    G --> H
    H --> I
    H --> L
    I --> J
    J --> K
    K --> M
    M --> N
    
    I -.è¿›åº¦.-> O
    L -.è¿›åº¦.-> O
    O --> P
    P --> Q
    Q --> B
    
    style F fill:#FFA500
    style O fill:#87CEEB
```

---

## é”™è¯¯å¤„ç†ä¸æ¢å¤

### é”™è¯¯ç±»å‹ä¸å¤„ç†

| é”™è¯¯ç±»å‹ | å‘ç”Ÿä½ç½® | å¤„ç†ç­–ç•¥ |
|---------|---------|---------|
| **é‡‡é›†å™¨åˆå§‹åŒ–å¤±è´¥** | ScreenRecorder::startRecording | è¿”å›false,é€šçŸ¥Python |
| **é˜Ÿåˆ—æ»¡ä¸¢å¸§** | FrameGrabberThread | è®°å½•ä¸¢å¸§æ•°,å›è°ƒé€šçŸ¥ |
| **ç¼–ç å¤±è´¥** | FrameEncoder | åœæ­¢å½•åˆ¶,å›è°ƒé”™è¯¯ |
| **Pythonå›è°ƒå¼‚å¸¸** | C++å›è°ƒå‡½æ•° | æ•è·å¹¶æ‰“å°,ä¸å½±å“C++çº¿ç¨‹ |
| **ç£ç›˜ç©ºé—´ä¸è¶³** | MediaWriter | åœæ­¢å½•åˆ¶,ä¿å­˜å·²æœ‰æ•°æ® |

### å¼‚å¸¸å®‰å…¨ä¿è¯

```cpp
// âœ… RAIIä¿è¯èµ„æºé‡Šæ”¾
class ScreenRecorder {
public:
    ~ScreenRecorder() {
        // è‡ªåŠ¨åœæ­¢å½•åˆ¶
        if (recording_) {
            stopRecording();
        }
        // æ™ºèƒ½æŒ‡é’ˆè‡ªåŠ¨é‡Šæ”¾èµ„æº
    }
};

// âœ… å¼‚å¸¸æ•è·
void ScreenRecorder::notifyProgress(...) {
    try {
        py::gil_scoped_acquire acquire;
        on_progress_(...);
    } catch (const std::exception& e) {
        // ä¸è®©å¼‚å¸¸ä¼ æ’­åˆ°C++çº¿ç¨‹
        std::cerr << "Callback error: " << e.what() << std::endl;
    }
}
```

---

## å®æˆ˜é›†æˆç¤ºä¾‹

### å®Œæ•´åº”ç”¨å¯åŠ¨

```python
# main.py
import sys
from pathlib import Path
from PySide6.QtWidgets import QApplication
from PySide6.QtQml import QQmlApplicationEngine
from PySide6.QtCore import QUrl

from services.video_service import VideoService
from viewmodels.video_viewmodel import VideoViewModel


def main():
    app = QApplication(sys.argv)
    engine = QQmlApplicationEngine()
    
    # 1ï¸âƒ£ åˆ›å»ºæœåŠ¡å±‚
    video_service = VideoService()
    
    # 2ï¸âƒ£ åˆ›å»ºViewModel
    video_viewmodel = VideoViewModel(video_service)
    
    # 3ï¸âƒ£ æ³¨å…¥åˆ°QMLä¸Šä¸‹æ–‡
    context = engine.rootContext()
    context.setContextProperty("videoViewModel", video_viewmodel)
    
    # 4ï¸âƒ£ åŠ è½½QML
    qml_file = Path(__file__).parent / "views" / "main.qml"
    engine.load(QUrl.fromLocalFile(str(qml_file)))
    
    if not engine.rootObjects():
        return -1
    
    return app.exec()


if __name__ == "__main__":
    sys.exit(main())
```

---

## æ€»ç»“

ç”Ÿäº§è€…-æ¶ˆè´¹è€…åä½œæœºåˆ¶æ˜¯æ•´ä¸ªè§†é¢‘æµå¤„ç†ç³»ç»Ÿçš„é›†æˆæ ¸å¿ƒ:

âœ… **C++å¤šçº¿ç¨‹**: FrameGrabberThread + FrameEncoder é€šè¿‡ ThreadSafeQueue åä½œ  
âœ… **Pybind11é€šä¿¡**: C++ â†” Python è·¨è¯­è¨€è°ƒç”¨ + GILç®¡ç†  
âœ… **ä¸‰å±‚æ¶æ„**: C++ (æ ¸å¿ƒ) â†’ Python (ä¸šåŠ¡) â†’ QML (UI)  
âœ… **å¼‚æ­¥é€šçŸ¥**: å›è°ƒå‡½æ•° + Qtä¿¡å·æ§½  
âœ… **é”™è¯¯å¤„ç†**: å¼‚å¸¸å®‰å…¨ + ä¼˜é›…é™çº§

**ä¸‹ä¸€æ­¥**: æ€§èƒ½ä¼˜åŒ– [3.2.5 æ€§èƒ½ä¼˜åŒ–ä¸è°ƒä¼˜](file:///d:/ç¼–ç¨‹/é¡¹ç›®/AiVideoAnalsysSystem/.agent/ç¬¬ä¸‰ç« /3.2.5_æ€§èƒ½ä¼˜åŒ–è°ƒä¼˜.md)
