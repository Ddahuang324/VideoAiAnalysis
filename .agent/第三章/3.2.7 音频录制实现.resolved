# 独立音频采集架构设计文档

## 1. 概述 (Overview)

本架构设计旨在为 `AiVideoAnalsysSystem` 的 [ScreenRecorder](file:///d:/%E7%BC%96%E7%A8%8B/%E9%A1%B9%E7%9B%AE/AiVideoAnalsysSystem/cpp/include/core/ScreenRecorder/ScreenRecorder.h#18-59) 模块引入“独立音频采集”功能。
核心目标是支持 **SNAPSHOT 模式**（视频 1 FPS，幻灯片式）下，同时录制 **高采样率、连续流畅的音频**（如 48kHz AAC）。

### 核心需求
- **视频流**：SNAPSHOT 模式（1 FPS），低带宽，用于 AI 关键帧分析。
- **音频流**：连续音频（48kHz），用于语音识别 (ASR) 和环境音分析。
- **容器封装**：标准 MP4 容器，视频和音频流独立，通过 PTS（显示时间戳）严格同步。

---

## 2. 架构设计 (Architecture Design)

目前的 [ScreenRecorder](file:///d:/%E7%BC%96%E7%A8%8B/%E9%A1%B9%E7%9B%AE/AiVideoAnalsysSystem/cpp/include/core/ScreenRecorder/ScreenRecorder.h#18-59) 是单视频流架构。我们将对其进行扩展，引入平行的音频处理流水线。

### 2.1 高层架构图 (Component Diagram)

```mermaid
graph TD
    subgraph CaptureLayer ["采集层"]
        VG["IScreenGrabber<br/>(Video)"]
        AG["IAudioGrabber<br/>(Audio)"]
    end

    subgraph Threading ["线程/队列层"]
        VQ["ThreadSafetyQueue<br/>FrameData"]
        AQ["ThreadSafetyQueue<br/>AudioData"]
    end

    subgraph ProcessLayer ["处理层"]
        VE["FrameEncoder<br/>(Video)"]
        AE["AudioEncoder<br/>(Audio)"]
    end

    subgraph OutputLayer ["输出层"]
        FF["FFmpegWrapper<br/>(Muxer)"]
    end

    %% Data Flow
    VG -->|Video Frame| VQ
    AG -->|Audio Packet| AQ
    
    VQ -->|Pop| VE
    AQ -->|Pop| AE
    
    VE -->|AVPacket Video| FF
    AE -->|AVPacket Audio| FF
    
    FF -->|MP4 File| File[Disk]

    %% Control Flow
    SR["ScreenRecorder<br/>(Controller)"]
    SR -.->|Manage| VG
    SR -.->|Manage| AG
    SR -.->|Manage| VE
    SR -.->|Manage| AE
    SR -.->|Manage| FF
```

### 2.2 核心组件职责

| 组件 | 现有职责 | 新增职责/新组件 |
| :--- | :--- | :--- |
| **ScreenRecorder** | 管理视频采集、编码、文件写入生命周期 | 管理 AudioGrabber 和 AudioEncoder 的生命周期；协调双流开始/停止 |
| **IScreenGrabber** | 截屏 (DXGI/GDI) | (不变) 仅负责视频 |
| **IAudioGrabber** | (无) | **[新增]** 负责从系统音频设备 (WASAPI loopback) 采集 PCM 数据 |
| **AudioGrabberThread**| (无) | **[新增]** 独立线程运行 IAudioGrabber，将 `AudioData` 推入队列 |
| **ThreadSafetyQueue** | 视频帧队列 | 新增音频队列实例 `audioQueue_` |
| **FrameEncoder** | 视频帧预处理、编码调度 | (不变) 仅负责视频 |
| **AudioEncoder** | (无) | **[新增]** 从队列取音频数据，调用 FFmpegWrapper 进行编码 |
| **FFmpegWrapper** | 视频编码、MP4 封装 | 支持双流 (Video/Audio) 创建、编码、交织写入 (Interleaved Write) |

---

## 3. 详细设计 (Detailed Design)

### 3.1 数据结构扩展

#### AudioData (新增)
用于在采集层和编码层之间传输原始音频数据。

```cpp
struct AudioData {
    std::vector<uint8_t> data; // PCM 数据
    int64_t timestamp;         // 采集时间戳 (用于计算 PTS)
    int sampleRate;            // 采样率 (48000)
    int channels;              // 通道数 (2)
    int samplesPerChannel;     // 每个通道的样本数 (1024 typically)
};
```

#### EncoderConfig (修改)
扩展配置以包含音频参数。

```cpp
struct EncoderConfig {
    // ... 现有视频参数 ...
    
    // [新增] 音频参数
    bool enableAudio = true;
    int audioSampleRate = 48000;
    int audioChannels = 2;
    int audioBitrate = 128000; // 128 kbps
    std::string audioCodec = "aac";
};
```

### 3.2 接口定义

#### IAudioGrabber (抽象基类)

```cpp
class IAudioGrabber {
public:
    virtual ~IAudioGrabber() = default;
    virtual bool start() = 0;
    virtual void stop() = 0;
    // 类似于 FrameGrabberThread 的回调机制
    virtual void setCallback(std::function<void(const AudioData&)> callback) = 0;
};
// 实现类: WasapiAudioGrabber (Windows)
```

#### FFmpegWrapper (关键修改)

需要在 [FFmpegWrapper](file:///d:/%E7%BC%96%E7%A8%8B/%E9%A1%B9%E7%9B%AE/AiVideoAnalsysSystem/cpp/include/core/ScreenRecorder/ProcessLayer/FFmpegWrapper.h#71-133) 中增加音频上下文管理，并实现严谨的 PTS 同步。

```cpp
class FFmpegWrapper {
    // ...
private:
    // 新增音频成员
    AVStream* audioStream_ = nullptr;
    AVCodecContextPtr audioCodecContext_;
    AVFramePtr audioFrame_; 
    
    // 更新初始化步骤
    bool step3_createStreams(const EncoderConfig& config); // 合并 Video/Audio 流创建
    
public:
    // 新增音频编码接口
    bool encodeAudioFrame(const AudioData& data); 
};
```

---

## 4. 关键流程与挑战 (Process & Challenges)

### 4.1 时间戳同步 (PTS Synchronization)
这是最关键的技术难点。在 SNAPSHOT 模式下：
- **视频**：PTS 间距巨大 (time_base = 1/FPS = 1.0s)。
- **音频**：PTS 间距微小 (time_base = 1/SampleRate = 1/48000s)。

**解决方案**：
[FFmpegWrapper](file:///d:/%E7%BC%96%E7%A8%8B/%E9%A1%B9%E7%9B%AE/AiVideoAnalsysSystem/cpp/include/core/ScreenRecorder/ProcessLayer/FFmpegWrapper.h#71-133) 必须维护两个独立的 `next_pts` 计数器，并在写入时通过 `av_interleaved_write_frame` 自动处理封装。

**PTS 计算公式**：
- **Video PTS**: `frameIndex * (StreamTimeBase / FPS)`
- **Audio PTS**: `totalSamplesEncoded` (累加每次编码的 nb_samples)

### 4.2 编码循环流程图

```mermaid
sequenceDiagram
    participant AG as AudioGrabber
    participant AQ as AudioQueue
    participant AE as AudioEncoder
    participant FF as FFmpegWrapper
    participant File as MP4 File

    Note over AG, File: 音频处理流水线 (独立运行)

    loop Every ~21ms (1024 samples @ 48kHz)
        AG->>AG: Capture PCM
        AG->>AQ: Push AudioData
    end

    loop Worker Thread
        AQ->>AE: Pop AudioData
        AE->>AE: Prepare AVFrame (PCM)
        AE->>AE: Set PTS = totalSamples
        AE->>FF: avcodec_send_frame(audioFrame)
        
        loop Receive Packet
            FF->>FF: avcodec_receive_packet
            FF->>File: av_interleaved_write_frame
            Note right of FF: FFmpeg 自动处理<br/>音视频包的交错写入
        end
        
        AE->>AE: totalSamples += 1024
    end
```

## 5. 实施步骤规划 (Implementation Plan)

1.  **AudioGrabber 原型** (3天)
    - 使用 WASAPI (Windows Audio Session API) 实现 Loopback 采集。
    - 验证可以获取连续的 PCM 数据。
2.  **FFmpegWrapper 改造** (2天)
    - 增加 `addAudioStream()` 私有方法。
    - 修改 `initialize` 支持双流。
    - 实现 `encodeAudioFrame`。
3.  **整合 ScreenRecorder** (2天)
    - 修改 [EncoderConfig](file:///d:/%E7%BC%96%E7%A8%8B/%E9%A1%B9%E7%9B%AE/AiVideoAnalsysSystem/cpp/include/core/ScreenRecorder/ProcessLayer/FFmpegWrapper.h#134-144)。
    - 在 [ScreenRecorder](file:///d:/%E7%BC%96%E7%A8%8B/%E9%A1%B9%E7%9B%AE/AiVideoAnalsysSystem/cpp/include/core/ScreenRecorder/ScreenRecorder.h#18-59) 中实例化 `AudioGrabber` 和 `AudioEncoder`。
    - 协调 Start/Stop 逻辑。
4.  **同步测试** (1天)
    - 验证 1 FPS 视频下，音频长录制是否音画同步（虽然是幻灯片，但声音不应漂移）。

## 6. 总结

该架构通过**解耦**视频和音频的采集与编码过程，利用 MP4 容器的多流特性，完美解决了低帧率视频与高帧率音频共存的需求。
- **优点**：模块化程度高，不影响现有的视频录制逻辑；资源占用低。
- **风险**：Windows WASAPI 采集的兼容性（需处理设备插拔、格式变更）。
