# å±å¹•å½•åˆ¶ä¸åˆ†ç‰‡æœºåˆ¶æ¶æ„åˆ†æ

## æ–‡æ¡£æ¦‚è¿°

æœ¬æ–‡æ¡£æ·±å…¥åˆ†æå‚è€ƒé¡¹ç›®çš„å±å¹•å½•åˆ¶å’Œè§†é¢‘åˆ†ç‰‡æœºåˆ¶è®¾è®¡ï¼Œæ¢è®¨å¦‚ä½•åœ¨**æœ€å°åŒ–å­˜å‚¨å‹åŠ›**çš„åŒæ—¶ä¿æŒ**è§†é¢‘è¿è´¯æ€§**ï¼Œä½¿AIèƒ½å¤Ÿæœ‰æ•ˆåˆ†æå…¨è§†é¢‘çŠ¶æ€ã€‚åŒæ—¶ç»“åˆæœ¬é¡¹ç›®ç¬¬ä¸‰ç« ï¼ˆC++ æ ¸å¿ƒ - å±å¹•å½•åˆ¶å¼•æ“ï¼‰çš„å®ç°è¦æ±‚ï¼Œæå‡ºå·¥ä¸šçº§çš„è®¾è®¡æ–¹æ¡ˆã€‚

---

## ä¸€ã€æ ¸å¿ƒè®¾è®¡ç›®æ ‡

### 1.1 å­˜å‚¨ä¼˜åŒ–ç›®æ ‡

> [!IMPORTANT]
> **å­˜å‚¨å‹åŠ›çš„æœ¬è´¨çŸ›ç›¾**ï¼šé«˜è´¨é‡å±å¹•å½•åˆ¶äº§ç”Ÿæµ·é‡æ•°æ®ï¼ˆ1080p@30fps â‰ˆ 200MB/min æœªå‹ç¼©ï¼‰ï¼Œä½†AIåˆ†æéœ€è¦å®Œæ•´è§†é¢‘ä¸Šä¸‹æ–‡ã€‚

**è®¾è®¡ç›®æ ‡**ï¼š
- âœ… **å®æ—¶å‹ç¼©**ï¼šå½•åˆ¶æ—¶å³è¿›è¡ŒH.264/HEVCç¼–ç ï¼Œå‡å°‘90%+å­˜å‚¨ç©ºé—´
- âœ… **æ™ºèƒ½åˆ†ç‰‡**ï¼šæŒ‰æ—¶é—´/å¤§å°åˆ‡åˆ†è§†é¢‘å—ï¼Œé¿å…å•æ–‡ä»¶è¿‡å¤§
- âœ… **ä¸´æ—¶å­˜å‚¨**ï¼šåˆ†æå®Œæˆåè‡ªåŠ¨æ¸…ç†ä¸­é—´æ–‡ä»¶
- âœ… **æµå¼å¤„ç†**ï¼šè¾¹å½•åˆ¶è¾¹ä¸Šä¼ ï¼Œæ— éœ€ç­‰å¾…å®Œæ•´å½•åˆ¶ç»“æŸ

### 1.2 è¿è´¯æ€§ä¿è¯ç›®æ ‡

**AIåˆ†æçš„å…³é”®éœ€æ±‚**ï¼š
- ğŸ“¹ **æ—¶é—´è¿ç»­æ€§**ï¼šåˆ†ç‰‡é—´æ— ä¸¢å¸§ã€æ— æ—¶é—´æˆ³è·³è·ƒ
- ğŸ¬ **è¯­ä¹‰å®Œæ•´æ€§**ï¼šå…³é”®æ“ä½œä¸è¢«åˆ†ç‰‡è¾¹ç•Œæˆªæ–­
- ğŸ”— **å…ƒæ•°æ®å…³è”**ï¼šæ¯ä¸ªåˆ†ç‰‡æºå¸¦å…¨å±€ä¸Šä¸‹æ–‡ä¿¡æ¯

---

## äºŒã€å‚è€ƒé¡¹ç›®çš„å…¸å‹æ¶æ„æ¨¡å¼

### 2.1 å‰ç«¯å½•åˆ¶å±‚ï¼ˆBrowser MediaRecorder APIï¼‰

åŸºäºWebæŠ€æœ¯æ ˆçš„å±å¹•å½•åˆ¶é€šå¸¸é‡‡ç”¨ä»¥ä¸‹æ¶æ„ï¼š

```mermaid
graph TB
    A[ç”¨æˆ·è§¦å‘å½•åˆ¶] --> B[navigator.mediaDevices.getDisplayMedia]
    B --> C[MediaRecorder å®ä¾‹åŒ–]
    C --> D{è®¾ç½®åˆ†ç‰‡ç­–ç•¥}
    D --> E[timeslice: 10000ms]
    E --> F[ondataavailable äº‹ä»¶]
    F --> G[Blob æ•°æ®å—]
    G --> H{å­˜å‚¨ç­–ç•¥}
    H --> I[IndexedDB ä¸´æ—¶å­˜å‚¨]
    H --> J[ç›´æ¥ä¸Šä¼ åˆ°åç«¯]
    I --> K[å½•åˆ¶ç»“æŸååˆå¹¶]
    J --> L[æµå¼ä¼ è¾“]
```

**å…³é”®ä»£ç æ¨¡å¼**ï¼ˆTypeScriptä¼ªä»£ç ï¼‰ï¼š

```typescript
// å‰ç«¯å½•åˆ¶æœåŠ¡æ ¸å¿ƒé€»è¾‘
class RecordingService {
  private mediaRecorder: MediaRecorder;
  private chunks: Blob[] = [];
  
  async startRecording(options: RecordingOptions) {
    const stream = await navigator.mediaDevices.getDisplayMedia({
      video: { width: 1920, height: 1080, frameRate: 30 }
    });
    
    // å…³é”®ï¼šè®¾ç½® timeslice å®ç°è‡ªåŠ¨åˆ†ç‰‡
    this.mediaRecorder = new MediaRecorder(stream, {
      mimeType: 'video/webm;codecs=vp9',
      videoBitsPerSecond: 2500000 // 2.5 Mbps
    });
    
    // æ¯10ç§’è§¦å‘ä¸€æ¬¡ dataavailable
    this.mediaRecorder.start(10000); // timeslice = 10s
    
    this.mediaRecorder.ondataavailable = (event) => {
      if (event.data.size > 0) {
        this.handleChunk(event.data);
      }
    };
  }
  
  private async handleChunk(blob: Blob) {
    // ç­–ç•¥1: ä¸´æ—¶å­˜å‚¨åˆ° IndexedDB
    await this.saveToIndexedDB(blob);
    
    // ç­–ç•¥2: ç«‹å³ä¸Šä¼ ï¼ˆæµå¼å¤„ç†ï¼‰
    await this.uploadChunk(blob);
  }
}
```

### 2.2 åç«¯å¤„ç†å±‚ï¼ˆNode.js + FFmpegï¼‰

```mermaid
sequenceDiagram
    participant F as Frontend
    participant B as Backend API
    participant S as Storage
    participant AI as Gemini AI
    
    F->>B: ä¸Šä¼ è§†é¢‘åˆ†ç‰‡ (chunk_0.webm)
    B->>S: ä¸´æ—¶å­˜å‚¨ /temp/session_id/
    F->>B: ä¸Šä¼ åˆ†ç‰‡ (chunk_1.webm)
    B->>S: è¿½åŠ å­˜å‚¨
    F->>B: å½•åˆ¶ç»“æŸä¿¡å·
    B->>B: FFmpeg åˆå¹¶åˆ†ç‰‡
    B->>AI: ä¸Šä¼ å®Œæ•´è§†é¢‘
    AI-->>B: è¿”å›åˆ†æç»“æœ
    B->>S: åˆ é™¤ä¸´æ—¶åˆ†ç‰‡
```

**åç«¯è§†é¢‘æœåŠ¡æ ¸å¿ƒé€»è¾‘**ï¼ˆTypeScriptä¼ªä»£ç ï¼‰ï¼š

```typescript
// åç«¯è§†é¢‘å¤„ç†æœåŠ¡
class VideoService {
  async stitchVideos(sessionId: string): Promise<string> {
    const tempDir = `/temp/${sessionId}`;
    const chunks = await this.getChunkFiles(tempDir);
    
    // ç”Ÿæˆ FFmpeg concat æ–‡ä»¶åˆ—è¡¨
    const concatList = chunks.map(c => `file '${c}'`).join('\n');
    await fs.writeFile(`${tempDir}/concat.txt`, concatList);
    
    // ä½¿ç”¨ FFmpeg æ— æŸåˆå¹¶ï¼ˆå…³é”®ï¼šä½¿ç”¨ concat demuxerï¼‰
    const outputPath = `/output/${sessionId}_final.mp4`;
    await this.execFFmpeg([
      '-f', 'concat',
      '-safe', '0',
      '-i', `${tempDir}/concat.txt`,
      '-c', 'copy', // æ— é‡æ–°ç¼–ç ï¼Œä¿è¯é€Ÿåº¦å’Œè´¨é‡
      outputPath
    ]);
    
    // æ¸…ç†ä¸´æ—¶æ–‡ä»¶
    await this.cleanupTemp(tempDir);
    
    return outputPath;
  }
}
```

### 2.3 å­˜å‚¨ä¼˜åŒ–çš„å…³é”®æŠ€æœ¯

#### æŠ€æœ¯1ï¼šè‡ªé€‚åº”ç ç‡æ§åˆ¶

```typescript
// æ ¹æ®å±å¹•å†…å®¹åŠ¨æ€è°ƒæ•´ç ç‡
function calculateBitrate(screenActivity: 'low' | 'medium' | 'high'): number {
  const bitrateMap = {
    low: 1500000,    // é™æ€å†…å®¹ï¼ˆæ–‡æ¡£é˜…è¯»ï¼‰
    medium: 2500000, // ä¸€èˆ¬æ“ä½œï¼ˆç¼–ç ï¼‰
    high: 4000000    // é«˜åŠ¨æ€ï¼ˆè§†é¢‘æ’­æ”¾ï¼‰
  };
  return bitrateMap[screenActivity];
}
```

#### æŠ€æœ¯2ï¼šå…³é”®å¸§å¯¹é½åˆ†ç‰‡

> [!WARNING]
> **å¸¸è§é”™è¯¯**ï¼šåœ¨ä»»æ„æ—¶é—´ç‚¹åˆ‡åˆ†è§†é¢‘ä¼šå¯¼è‡´åˆ†ç‰‡æ— æ³•ç‹¬ç«‹è§£ç ï¼

**æ­£ç¡®åšæ³•**ï¼šåœ¨GOPï¼ˆGroup of Picturesï¼‰è¾¹ç•Œåˆ‡åˆ†

```typescript
// ç¡®ä¿åˆ†ç‰‡èµ·å§‹äºå…³é”®å¸§
mediaRecorder.start(10000); // 10ç§’åˆ†ç‰‡
// é…åˆç¼–ç å™¨è®¾ç½®ï¼škeyint=300 (10s * 30fps)
```

#### æŠ€æœ¯3ï¼šå…ƒæ•°æ®åµŒå…¥

æ¯ä¸ªåˆ†ç‰‡æºå¸¦å…¨å±€ä¸Šä¸‹æ–‡ï¼š

```json
{
  "chunkIndex": 0,
  "sessionId": "uuid-xxx",
  "startTime": "2024-01-01T10:00:00Z",
  "duration": 10.0,
  "resolution": "1920x1080",
  "globalMetadata": {
    "totalDuration": 120.5,
    "applicationName": "Desktop Activity Tracker"
  }
}
```

---

## ä¸‰ã€æœ¬é¡¹ç›®ç¬¬ä¸‰ç« çš„C++å®ç°æ–¹æ¡ˆ

### 3.1 é‡‡é›†å™¨æ¶æ„è®¾è®¡

åŸºäºç¬¬ä¸‰ç« è¦æ±‚ï¼Œæˆ‘ä»¬éœ€è¦åœ¨C++å±‚å®ç°æ›´é«˜æ€§èƒ½çš„å½•åˆ¶å¼•æ“ï¼š

```mermaid
classDiagram
    class IScreenGrabber {
        <<interface>>
        +start() void
        +stop() void
        +pause() void
        +resume() void
    }
    
    class FFmpegWrapper {
        -AVFormatContext* formatCtx
        -AVCodecContext* codecCtx
        -AVStream* videoStream
        +initEncoder() bool
        +writeFrame(AVFrame*) bool
        +finalize() void
        ~FFmpegWrapper()
    }
    
    class FrameGrabberThread {
        -std::thread captureThread
        -std::atomic~bool~ isRunning
        +run() void
        -captureFrame() AVFrame*
    }
    
    class ChunkManager {
        -int currentChunkIndex
        -std::chrono::time_point chunkStartTime
        +shouldRotateChunk() bool
        +rotateChunk() void
    }
    
    IScreenGrabber <|-- ScreenRecorder
    ScreenRecorder *-- FFmpegWrapper
    ScreenRecorder *-- FrameGrabberThread
    ScreenRecorder *-- ChunkManager
```

### 3.2 åˆ†ç‰‡ç­–ç•¥å®ç°

#### ç­–ç•¥Aï¼šåŸºäºæ—¶é—´çš„åˆ†ç‰‡ï¼ˆæ¨èç”¨äºAIåˆ†æï¼‰

```cpp
// ChunkManager.h
class ChunkManager {
public:
    ChunkManager(int chunkDurationSec = 60) 
        : maxChunkDuration_(chunkDurationSec) {}
    
    bool shouldRotateChunk() const {
        auto elapsed = std::chrono::duration_cast<std::chrono::seconds>(
            std::chrono::steady_clock::now() - chunkStartTime_
        ).count();
        return elapsed >= maxChunkDuration_;
    }
    
    std::string getChunkPath(const std::string& sessionId) {
        return fmt::format("temp/session_{}/chunk_{:04d}.mp4", 
                          sessionId, currentChunkIndex_);
    }
    
    void rotateChunk() {
        currentChunkIndex_++;
        chunkStartTime_ = std::chrono::steady_clock::now();
        emit chunkRotated(currentChunkIndex_);
    }
    
private:
    int maxChunkDuration_;
    int currentChunkIndex_ = 0;
    std::chrono::steady_clock::time_point chunkStartTime_;
};
```

#### ç­–ç•¥Bï¼šåŸºäºæ–‡ä»¶å¤§å°çš„åˆ†ç‰‡ï¼ˆå¤‡é€‰æ–¹æ¡ˆï¼‰

```cpp
class FileSizeChunkManager : public ChunkManager {
public:
    bool shouldRotateChunk() const override {
        std::filesystem::path currentFile = getCurrentChunkPath();
        if (!std::filesystem::exists(currentFile)) return false;
        
        auto fileSize = std::filesystem::file_size(currentFile);
        return fileSize >= maxChunkSize_; // ä¾‹å¦‚ 100MB
    }
    
private:
    size_t maxChunkSize_ = 100 * 1024 * 1024; // 100MB
};
```

### 3.3 è§†é¢‘æµå¤„ç†ç®¡é“

```cpp
// FrameEncoder.cpp
class FrameEncoder {
public:
    void encodeFrame(AVFrame* frame) {
        // 1. æ—¶é—´æˆ³ç®¡ç†ï¼ˆå…³é”®ï¼šä¿è¯è¿ç»­æ€§ï¼‰
        frame->pts = frameCount_++;
        
        // 2. ç¼–ç 
        int ret = avcodec_send_frame(codecCtx_, frame);
        if (ret < 0) {
            throw EncodingException("Failed to send frame");
        }
        
        // 3. è·å–ç¼–ç åŒ…
        AVPacket* pkt = av_packet_alloc();
        while (avcodec_receive_packet(codecCtx_, pkt) == 0) {
            // 4. æ£€æŸ¥æ˜¯å¦éœ€è¦åˆ‡æ¢åˆ†ç‰‡
            if (chunkManager_->shouldRotateChunk()) {
                rotateOutputFile();
            }
            
            // 5. å†™å…¥å½“å‰åˆ†ç‰‡
            av_interleaved_write_frame(formatCtx_, pkt);
            av_packet_unref(pkt);
        }
        av_packet_free(&pkt);
    }
    
private:
    void rotateOutputFile() {
        // 1. å…³é—­å½“å‰æ–‡ä»¶
        av_write_trailer(formatCtx_);
        avio_closep(&formatCtx_->pb);
        
        // 2. ä¿å­˜å…ƒæ•°æ®
        saveChunkMetadata();
        
        // 3. æ‰“å¼€æ–°æ–‡ä»¶
        std::string newPath = chunkManager_->getChunkPath(sessionId_);
        avio_open(&formatCtx_->pb, newPath.c_str(), AVIO_FLAG_WRITE);
        avformat_write_header(formatCtx_, nullptr);
        
        // 4. é‡ç½®PTSï¼ˆå…³é”®ï¼šé¿å…æ—¶é—´æˆ³è·³è·ƒï¼‰
        lastChunkEndPts_ = frameCount_;
        
        chunkManager_->rotateChunk();
    }
    
    int64_t frameCount_ = 0;
    int64_t lastChunkEndPts_ = 0;
};
```

### 3.4 è¿è´¯æ€§ä¿è¯æœºåˆ¶

#### æœºåˆ¶1ï¼šGOPå¯¹é½åˆ‡ç‰‡

```cpp
// ç¼–ç å™¨åˆå§‹åŒ–æ—¶è®¾ç½®GOPå¤§å°
AVDictionary* opts = nullptr;
av_dict_set(&opts, "g", "60", 0);        // GOP = 60å¸§ (2ç§’@30fps)
av_dict_set(&opts, "keyint_min", "60", 0); // å¼ºåˆ¶å…³é”®å¸§é—´éš”
avcodec_open2(codecCtx_, codec, &opts);

// åˆ‡ç‰‡æ—¶ç­‰å¾…å…³é”®å¸§
bool FrameEncoder::canRotateNow(AVPacket* pkt) {
    return (pkt->flags & AV_PKT_FLAG_KEY) && 
           chunkManager_->shouldRotateChunk();
}
```

#### æœºåˆ¶2ï¼šæ—¶é—´æˆ³è¿ç»­æ€§

```cpp
// å…¨å±€æ—¶é—´æˆ³ç®¡ç†å™¨
class TimestampManager {
public:
    int64_t getNextPts() {
        return globalPts_++;
    }
    
    void saveCheckpoint(int chunkIndex) {
        checkpoints_[chunkIndex] = globalPts_;
    }
    
    // ç”¨äºåæœŸåˆå¹¶éªŒè¯
    bool validateContinuity() {
        for (size_t i = 1; i < checkpoints_.size(); i++) {
            if (checkpoints_[i] <= checkpoints_[i-1]) {
                return false; // æ£€æµ‹åˆ°æ—¶é—´æˆ³å€’é€€
            }
        }
        return true;
    }
    
private:
    std::atomic<int64_t> globalPts_{0};
    std::map<int, int64_t> checkpoints_;
};
```

#### æœºåˆ¶3ï¼šå…ƒæ•°æ®é“¾

```cpp
// ChunkMetadata.json
struct ChunkMetadata {
    int index;
    std::string filePath;
    int64_t startPts;
    int64_t endPts;
    double durationSec;
    std::string sessionId;
    
    nlohmann::json toJson() const {
        return {
            {"index", index},
            {"filePath", filePath},
            {"startPts", startPts},
            {"endPts", endPts},
            {"duration", durationSec},
            {"sessionId", sessionId}
        };
    }
};

// ä¿å­˜åˆ° session_metadata.json
void saveSessionMetadata(const std::vector<ChunkMetadata>& chunks) {
    nlohmann::json j;
    j["chunks"] = nlohmann::json::array();
    for (const auto& chunk : chunks) {
        j["chunks"].push_back(chunk.toJson());
    }
    j["totalDuration"] = calculateTotalDuration(chunks);
    
    std::ofstream file("temp/session_metadata.json");
    file << j.dump(2);
}
```

---

## å››ã€AIåˆ†æçš„é€‚é…è®¾è®¡

### 4.1 æµå¼ä¸Šä¼ ç­–ç•¥

```cpp
// AnalysisBridge.cpp
class AnalysisBridge : public QObject {
    Q_OBJECT
public:
    void startAnalysis(const QString& sessionId) {
        // 1. è¯»å–å…ƒæ•°æ®
        auto metadata = loadSessionMetadata(sessionId);
        
        // 2. é€ä¸ªä¸Šä¼ åˆ†ç‰‡ï¼ˆæ— éœ€ç­‰å¾…å…¨éƒ¨å½•åˆ¶å®Œæˆï¼‰
        for (const auto& chunk : metadata.chunks) {
            uploadChunkToGemini(chunk);
        }
        
        // 3. è§¦å‘AIåˆ†æ
        emit analysisStarted(sessionId);
    }
    
private:
    void uploadChunkToGemini(const ChunkMetadata& chunk) {
        // ä½¿ç”¨ gRPC æµå¼ä¸Šä¼ 
        grpc::ClientContext context;
        UploadRequest request;
        request.set_chunk_data(readFile(chunk.filePath));
        request.set_chunk_index(chunk.index);
        request.set_session_id(chunk.sessionId);
        
        stub_->UploadChunk(&context, request, &response);
    }
};
```

### 4.2 Gemini APIçš„åˆ†ç‰‡å¤„ç†

```python
# Python AI æœåŠ¡ç«¯
class GeminiAnalyzer:
    async def analyze_session(self, session_id: str):
        # 1. è·å–æ‰€æœ‰åˆ†ç‰‡
        chunks = await self.get_chunks(session_id)
        
        # 2. æŒ‰é¡ºåºä¸Šä¼ åˆ° Gemini
        file_uris = []
        for chunk in chunks:
            file = genai.upload_file(chunk.path)
            # ç­‰å¾…å¤„ç†å®Œæˆ
            while file.state.name == "PROCESSING":
                await asyncio.sleep(1)
                file = genai.get_file(file.name)
            file_uris.append(file.uri)
        
        # 3. æ„å»ºåˆ†æPromptï¼ˆå…³é”®ï¼šå‘ŠçŸ¥AIè¿™æ˜¯åˆ†ç‰‡è§†é¢‘ï¼‰
        prompt = f"""
        ä»¥ä¸‹æ˜¯ä¸€ä¸ªå®Œæ•´å½•å±ä¼šè¯çš„ {len(chunks)} ä¸ªè¿ç»­åˆ†ç‰‡ï¼š
        - æ€»æ—¶é•¿: {total_duration}ç§’
        - åˆ†ç‰‡ç­–ç•¥: æ¯60ç§’åˆ‡åˆ†
        
        è¯·æŒ‰æ—¶é—´é¡ºåºåˆ†æç”¨æˆ·çš„å®Œæ•´æ“ä½œæµç¨‹ï¼Œç”Ÿæˆæ´»åŠ¨å¡ç‰‡ã€‚
        """
        
        # 4. è°ƒç”¨ Geminiï¼ˆæ”¯æŒå¤šæ–‡ä»¶è¾“å…¥ï¼‰
        model = genai.GenerativeModel("gemini-1.5-flash")
        response = await model.generate_content([prompt] + file_uris)
        
        return response.text
```

### 4.3 åˆ†æç»“æœçš„æ—¶é—´å¯¹é½

```python
# å°†AIè¿”å›çš„æ—¶é—´æˆ³æ˜ å°„å›åŸå§‹è§†é¢‘
def map_timestamp_to_global(chunk_index: int, local_timestamp: float) -> float:
    """
    chunk_index: åˆ†ç‰‡ç´¢å¼•
    local_timestamp: åˆ†ç‰‡å†…çš„ç›¸å¯¹æ—¶é—´æˆ³
    è¿”å›: å…¨å±€æ—¶é—´æˆ³
    """
    metadata = load_session_metadata()
    chunk = metadata['chunks'][chunk_index]
    return chunk['startPts'] / FRAME_RATE + local_timestamp
```

---

## äº”ã€å­˜å‚¨å‹åŠ›æœ€å°åŒ–çš„å·¥ç¨‹å®è·µ

### 5.1 ä¸‰çº§å­˜å‚¨ç­–ç•¥

```mermaid
graph LR
    A[å½•åˆ¶ä¸­] -->|å®æ—¶å†™å…¥| B[L1: å†…å­˜ç¼“å†²åŒº<br/>Ring Buffer 64MB]
    B -->|æ¯10ç§’| C[L2: ä¸´æ—¶ç£ç›˜<br/>temp/chunks/]
    C -->|åˆ†æå®Œæˆ| D[L3: å½’æ¡£å­˜å‚¨<br/>å¯é€‰]
    C -->|è‡ªåŠ¨æ¸…ç†| E[åˆ é™¤]
    
    style B fill:#90EE90
    style C fill:#FFD700
    style E fill:#FF6347
```

**å®ç°ä»£ç **ï¼š

```cpp
class StorageManager {
public:
    void onChunkComplete(const std::string& chunkPath) {
        // 1. ç§»åŠ¨åˆ°ä¸´æ—¶ç›®å½•
        std::filesystem::path tempPath = getTempDir() / 
            std::filesystem::path(chunkPath).filename();
        std::filesystem::rename(chunkPath, tempPath);
        
        // 2. æ³¨å†Œæ¸…ç†ä»»åŠ¡
        cleanupQueue_.push({tempPath, CleanupPolicy::AfterAnalysis});
    }
    
    void onAnalysisComplete(const std::string& sessionId) {
        // 3. æ¸…ç†æ‰€æœ‰ä¸´æ—¶æ–‡ä»¶
        auto sessionDir = getTempDir() / sessionId;
        std::filesystem::remove_all(sessionDir);
        
        qDebug() << "Cleaned up session:" << sessionId;
    }
    
private:
    std::filesystem::path getTempDir() {
        return std::filesystem::temp_directory_path() / "ai_video_analysis";
    }
    
    std::queue<CleanupTask> cleanupQueue_;
};
```

### 5.2 å‹ç¼©å‚æ•°ä¼˜åŒ–

```cpp
// é’ˆå¯¹å±å¹•å½•åˆ¶çš„æœ€ä¼˜ç¼–ç å‚æ•°
void setupEncoderForScreenCapture(AVCodecContext* ctx) {
    // 1. ä½¿ç”¨ H.264 High Profileï¼ˆæ›´å¥½çš„å‹ç¼©ç‡ï¼‰
    ctx->profile = FF_PROFILE_H264_HIGH;
    
    // 2. å±å¹•å†…å®¹ä¼˜åŒ–ï¼ˆå…³é”®ï¼ï¼‰
    av_opt_set(ctx->priv_data, "tune", "zerolatency", 0);
    av_opt_set(ctx->priv_data, "preset", "veryfast", 0);
    
    // 3. ç ç‡æ§åˆ¶ï¼ˆCRFæ¨¡å¼ï¼Œæ’å®šè´¨é‡ï¼‰
    av_opt_set(ctx->priv_data, "crf", "23", 0); // 18-28èŒƒå›´ï¼Œ23ä¸ºå¹³è¡¡ç‚¹
    
    // 4. å…³é”®å¸§é—´éš”ï¼ˆ2ç§’ï¼Œä¾¿äºåˆ†ç‰‡ï¼‰
    ctx->gop_size = 60; // 30fps * 2s
    
    // 5. Bå¸§è®¾ç½®ï¼ˆå±å¹•å½•åˆ¶å¯ç¦ç”¨Bå¸§æå‡ç¼–ç é€Ÿåº¦ï¼‰
    ctx->max_b_frames = 0;
}
```

**å‹ç¼©æ•ˆæœå¯¹æ¯”**ï¼š

| é…ç½® | ç ç‡ | 1å°æ—¶æ–‡ä»¶å¤§å° | CPUå ç”¨ | é€‚ç”¨åœºæ™¯ |
|------|------|--------------|---------|---------|
| æœªå‹ç¼©RGB | ~1.5 Gbps | ~675 GB | ä½ | âŒ ä¸å¯è¡Œ |
| H.264 CRF=18 | ~8 Mbps | ~3.6 GB | ä¸­ | é«˜è´¨é‡å½’æ¡£ |
| **H.264 CRF=23** | **~3 Mbps** | **~1.35 GB** | **ä¸­** | **âœ… æ¨è** |
| H.264 CRF=28 | ~1.5 Mbps | ~675 MB | ä½ | ä½è´¨é‡é¢„è§ˆ |

### 5.3 æ™ºèƒ½æ¸…ç†ç­–ç•¥

```cpp
// è‡ªåŠ¨æ¸…ç†ç®¡ç†å™¨
class AutoCleanupManager {
public:
    void scheduleCleanup(const std::string& sessionId, 
                        std::chrono::minutes delay = std::chrono::minutes(30)) {
        auto cleanupTime = std::chrono::steady_clock::now() + delay;
        
        cleanupSchedule_[sessionId] = cleanupTime;
        
        // å¯åŠ¨åå°æ¸…ç†çº¿ç¨‹
        if (!cleanupThread_.joinable()) {
            cleanupThread_ = std::thread(&AutoCleanupManager::cleanupWorker, this);
        }
    }
    
private:
    void cleanupWorker() {
        while (isRunning_) {
            auto now = std::chrono::steady_clock::now();
            
            for (auto it = cleanupSchedule_.begin(); it != cleanupSchedule_.end();) {
                if (now >= it->second) {
                    cleanupSession(it->first);
                    it = cleanupSchedule_.erase(it);
                } else {
                    ++it;
                }
            }
            
            std::this_thread::sleep_for(std::chrono::seconds(60));
        }
    }
    
    void cleanupSession(const std::string& sessionId) {
        auto sessionPath = getTempDir() / sessionId;
        if (std::filesystem::exists(sessionPath)) {
            auto size = calculateDirSize(sessionPath);
            std::filesystem::remove_all(sessionPath);
            qDebug() << "Cleaned" << size / 1024 / 1024 << "MB for session" << sessionId;
        }
    }
    
    std::map<std::string, std::chrono::steady_clock::time_point> cleanupSchedule_;
    std::thread cleanupThread_;
    std::atomic<bool> isRunning_{true};
};
```

---

## å…­ã€å®Œæ•´å·¥ä½œæµç¨‹ç¤ºä¾‹

### 6.1 ç«¯åˆ°ç«¯æµç¨‹å›¾

```mermaid
sequenceDiagram
    participant U as ç”¨æˆ·
    participant UI as QMLç•Œé¢
    participant RC as RecorderController
    participant FE as FrameEncoder
    participant CM as ChunkManager
    participant SM as StorageManager
    participant AB as AnalysisBridge
    participant AI as Gemini AI
    
    U->>UI: ç‚¹å‡»å½•åˆ¶
    UI->>RC: startRecording()
    RC->>FE: åˆå§‹åŒ–ç¼–ç å™¨
    
    loop æ¯å¸§
        FE->>FE: æ•è·å±å¹•
        FE->>FE: ç¼–ç H.264
        FE->>CM: æ£€æŸ¥æ˜¯å¦éœ€è¦åˆ‡ç‰‡
        alt éœ€è¦åˆ‡ç‰‡
            CM->>FE: rotateChunk()
            FE->>SM: ä¿å­˜å½“å‰åˆ†ç‰‡
            SM->>SM: ç§»åŠ¨åˆ°tempç›®å½•
        end
    end
    
    U->>UI: åœæ­¢å½•åˆ¶
    UI->>RC: stopRecording()
    RC->>FE: finalize()
    FE->>SM: ä¿å­˜æœ€ååˆ†ç‰‡
    SM->>AB: è§¦å‘åˆ†æ
    
    AB->>AI: ä¸Šä¼ åˆ†ç‰‡1
    AB->>AI: ä¸Šä¼ åˆ†ç‰‡2
    AB->>AI: ä¸Šä¼ åˆ†ç‰‡N
    AI-->>AB: è¿”å›åˆ†æç»“æœ
    AB->>SM: æ¸…ç†ä¸´æ—¶æ–‡ä»¶
    SM->>SM: åˆ é™¤tempç›®å½•
```

### 6.2 å…³é”®æ—¶é—´èŠ‚ç‚¹

| é˜¶æ®µ | æ—¶é—´ | å­˜å‚¨å ç”¨ | è¯´æ˜ |
|------|------|---------|------|
| T0 | 0s | 0 MB | å¼€å§‹å½•åˆ¶ |
| T1 | 60s | ~45 MB | ç¬¬1ä¸ªåˆ†ç‰‡å®Œæˆ |
| T2 | 120s | ~90 MB | ç¬¬2ä¸ªåˆ†ç‰‡å®Œæˆ |
| T3 | 180s | ~135 MB | å½•åˆ¶ç»“æŸï¼Œå¼€å§‹ä¸Šä¼  |
| T4 | 240s | ~135 MB | AIåˆ†æä¸­ |
| T5 | 300s | 0 MB | åˆ†æå®Œæˆï¼Œä¸´æ—¶æ–‡ä»¶å·²æ¸…ç† |

---

## ä¸ƒã€ä¸ç¬¬ä¸‰ç« å®ç°çš„å¯¹åº”å…³ç³»

### 7.1 ç« èŠ‚æ˜ å°„

| ç¬¬ä¸‰ç« èŠ‚ç‚¹ | æœ¬æ–‡æ¡£å¯¹åº”ç« èŠ‚ | æ ¸å¿ƒæŠ€æœ¯ |
|-----------|--------------|---------|
| 3.1 é‡‡é›†å™¨æ¶æ„ | ä¸‰.1 é‡‡é›†å™¨æ¶æ„è®¾è®¡ | IScreenGrabberæ¥å£ã€FFmpegWrapper |
| 3.2 è§†é¢‘æµå¤„ç† | ä¸‰.3 è§†é¢‘æµå¤„ç†ç®¡é“ | FrameEncoderã€æ—¶é—´æˆ³ç®¡ç† |
| 3.3 å†™å…¥æ§åˆ¶ | ä¸‰.2 åˆ†ç‰‡ç­–ç•¥å®ç° | ChunkManagerã€æ–‡ä»¶è½®è½¬ |

### 7.2 å®ç°ä¼˜å…ˆçº§

> [!TIP]
> **å»ºè®®çš„å¼€å‘é¡ºåº**ï¼š
> 1. âœ… **Phase 1**: å®ç°åŸºç¡€çš„å•æ–‡ä»¶å½•åˆ¶ï¼ˆæ— åˆ†ç‰‡ï¼‰
> 2. âœ… **Phase 2**: æ·»åŠ åŸºäºæ—¶é—´çš„åˆ†ç‰‡é€»è¾‘
> 3. âœ… **Phase 3**: é›†æˆå…ƒæ•°æ®ç®¡ç†å’Œæ¸…ç†ç­–ç•¥
> 4. âœ… **Phase 4**: å¯¹æ¥AIåˆ†ææµç¨‹

### 7.3 æ€§èƒ½æŒ‡æ ‡

**ç›®æ ‡æ€§èƒ½**ï¼ˆ1080p@30fpså½•åˆ¶ï¼‰ï¼š
- CPUå ç”¨: < 15%ï¼ˆå•æ ¸ï¼‰
- å†…å­˜å ç”¨: < 200 MB
- ç£ç›˜å†™å…¥: ~3 MB/s
- åˆ†ç‰‡åˆ‡æ¢å»¶è¿Ÿ: < 100ms
- ä¸´æ—¶å­˜å‚¨å³°å€¼: < 500 MBï¼ˆ5åˆ†é’Ÿå½•åˆ¶ï¼‰

---

## å…«ã€å¸¸è§é—®é¢˜ä¸è§£å†³æ–¹æ¡ˆ

### Q1: åˆ†ç‰‡è¾¹ç•Œå‡ºç°ç”»é¢æ’•è£‚æ€ä¹ˆåŠï¼Ÿ

**åŸå› **: åœ¨éå…³é”®å¸§ä½ç½®åˆ‡åˆ†å¯¼è‡´è§£ç å™¨æ— æ³•åˆå§‹åŒ–

**è§£å†³æ–¹æ¡ˆ**:
```cpp
// å¼ºåˆ¶åœ¨å…³é”®å¸§åˆ‡åˆ†
if ((pkt->flags & AV_PKT_FLAG_KEY) && shouldRotate) {
    rotateChunk();
}
```

### Q2: AIåˆ†ææ—¶æç¤ºè§†é¢‘ä¸è¿ç»­ï¼Ÿ

**åŸå› **: æ—¶é—´æˆ³ç®¡ç†é”™è¯¯ï¼ŒPTSå‡ºç°è·³è·ƒ

**è§£å†³æ–¹æ¡ˆ**:
```cpp
// ä½¿ç”¨å…¨å±€PTSè®¡æ•°å™¨
frame->pts = globalPtsCounter_++;
// åˆ‡ç‰‡æ—¶ä¸é‡ç½®PTS
```

### Q3: ä¸´æ—¶æ–‡ä»¶å ç”¨ç£ç›˜ç©ºé—´è¿‡å¤§ï¼Ÿ

**åŸå› **: æ¸…ç†ç­–ç•¥æœªç”Ÿæ•ˆ

**è§£å†³æ–¹æ¡ˆ**:
```cpp
// åˆ†æå®Œæˆåç«‹å³æ¸…ç†
connect(analysisBridge, &AnalysisBridge::analysisComplete,
        storageManager, &StorageManager::cleanupSession);
```

### Q4: é•¿æ—¶é—´å½•åˆ¶å¯¼è‡´å†…å­˜æ³„æ¼ï¼Ÿ

**åŸå› **: AVFrame/AVPacketæœªæ­£ç¡®é‡Šæ”¾

**è§£å†³æ–¹æ¡ˆ**:
```cpp
// ä½¿ç”¨RAIIå°è£…
class AVFrameGuard {
public:
    AVFrameGuard() : frame_(av_frame_alloc()) {}
    ~AVFrameGuard() { av_frame_free(&frame_); }
    AVFrame* get() { return frame_; }
private:
    AVFrame* frame_;
};
```

---

## ä¹ã€æ€»ç»“ä¸å±•æœ›

### 9.1 æ ¸å¿ƒè®¾è®¡åŸåˆ™

1. **å®æ—¶å‹ç¼©ä¼˜å…ˆ**: å½•åˆ¶æ—¶å³ç¼–ç ï¼Œé¿å…åŸå§‹æ•°æ®å †ç§¯
2. **æ™ºèƒ½åˆ†ç‰‡ç­–ç•¥**: åŸºäºæ—¶é—´+GOPå¯¹é½ï¼Œä¿è¯è¿è´¯æ€§
3. **ä¸´æ—¶å­˜å‚¨è®¾è®¡**: åˆ†æå®Œæˆå³æ¸…ç†ï¼Œæœ€å°åŒ–ç£ç›˜å ç”¨
4. **å…ƒæ•°æ®é©±åŠ¨**: å®Œæ•´çš„ä¸Šä¸‹æ–‡ä¿¡æ¯ï¼Œæ”¯æŒAIç†è§£å…¨å±€

### 9.2 ä¸å‚è€ƒé¡¹ç›®çš„å¯¹æ¯”

| ç»´åº¦ | å‚è€ƒé¡¹ç›®ï¼ˆWebï¼‰ | æœ¬é¡¹ç›®ï¼ˆC++ï¼‰ |
|------|----------------|--------------|
| å½•åˆ¶æ€§èƒ½ | ä¸­ç­‰ï¼ˆå—æµè§ˆå™¨é™åˆ¶ï¼‰ | é«˜ï¼ˆåŸç”ŸFFmpegï¼‰ |
| åˆ†ç‰‡ç²¾åº¦ | ç§’çº§ï¼ˆMediaRecorderï¼‰ | å¸§çº§ï¼ˆGOPå¯¹é½ï¼‰ |
| å­˜å‚¨æ§åˆ¶ | ä¾èµ–IndexedDB | å®Œå…¨å¯æ§çš„æ–‡ä»¶ç³»ç»Ÿ |
| è·¨å¹³å° | ä¼˜ç§€ï¼ˆæµè§ˆå™¨ï¼‰ | éœ€é€‚é…DXGI/X11 |

### 9.3 åç»­ä¼˜åŒ–æ–¹å‘

- [ ] **ç¡¬ä»¶åŠ é€Ÿ**: é›†æˆNVENC/QSVå®ç°GPUç¼–ç 
- [ ] **è‡ªé€‚åº”ç ç‡**: æ ¹æ®å±å¹•å†…å®¹åŠ¨æ€è°ƒæ•´
- [ ] **å¢é‡ä¸Šä¼ **: è¾¹å½•åˆ¶è¾¹ä¸Šä¼ ï¼Œæ— éœ€ç­‰å¾…å®Œæ•´åˆ†ç‰‡
- [ ] **æ–­ç‚¹ç»­ä¼ **: æ”¯æŒç½‘ç»œä¸­æ–­åçš„ç»­ä¼ 

---

## é™„å½•ï¼šå‚è€ƒèµ„æ–™

- [FFmpegå®˜æ–¹æ–‡æ¡£ - Muxing](https://ffmpeg.org/doxygen/trunk/muxing_8c-example.html)
- [H.264ç¼–ç å‚æ•°ä¼˜åŒ–æŒ‡å—](https://trac.ffmpeg.org/wiki/Encode/H.264)
- [Gemini API - è§†é¢‘åˆ†ææœ€ä½³å®è·µ](https://ai.google.dev/gemini-api/docs/vision)
- [Qtå¤šçº¿ç¨‹ç¼–ç¨‹æŒ‡å—](https://doc.qt.io/qt-6/threads-technologies.html)

---

**æ–‡æ¡£ç‰ˆæœ¬**: v1.0  
**æœ€åæ›´æ–°**: 2024-12-12  
**ä½œè€…**: AI Video Analysis System Team
