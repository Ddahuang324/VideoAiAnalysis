# IScreenGrabber 双模式采集架构设计

为 [IScreenGrabber](file:///d:/%E7%BC%96%E7%A8%8B/%E9%A1%B9%E7%9B%AE/AiVideoAnalsysSystem/cpp/include/core/ScreenRecorder/CaptureLayer/IScreenGrabber.h#40-66) 接口添加 **VideoMode (30FPS 连续录制)** 和 **SnapshotMode (1FPS/自定义间隔快照)** 双模式支持，参考 Dayflow 项目的"极低帧率采集 + 定时分片批处理"思想。

---

## 目标与设计原则

| 目标 | 说明 |
|------|------|
| **存储友好** | SnapshotMode 使用 JPEG 快照替代连续视频，大幅降低磁盘占用 |
| **CPU 轻量** | 快照模式 CPU 占用 <1%，适合 24/7 后台运行 |
| **灵活切换** | 运行时可在两种模式间切换，无需重启采集器 |
| **AI 优化** | 快照分片可批量合成视频送 Gemini，或逐帧描述送 ChatGPT/Claude |

---

## 核心架构

```mermaid
graph TB
    subgraph "CaptureLayer 采集层"
        A[IScreenGrabber] --> B["GDI_Grabber / DXGI_Grabber"]
        A --> C[CaptureMode]
        C --> D["VideoMode (30 FPS)"]
        C --> E["SnapshotMode (1 FPS/自定义)"]
    end
    
    subgraph "ProcessLayer 处理层"
        F[FrameGrabberThread] --> G{CaptureMode?}
        G -->|VideoMode| H[高频采集 → FrameQueue]
        G -->|SnapshotMode| I[低频采集 → SnapshotQueue]
    end
    
    subgraph "OutputLayer 输出层"
        H --> J[FrameEncoder → MP4]
        I --> K[SnapshotSaver → JPEG 分片]
        K --> L[StorageManager 配额管理]
    end
    
    subgraph "AnalysisLayer 分析层 (Python)"
        K --> M[BatchAggregator 15分钟分片]
        M --> N["VideoSynthesizer 合成 1FPS 视频"]
        N --> O[AI Provider → Gemini/ChatGPT]
    end
```

---

## 接口设计

### 1. CaptureMode 枚举

```cpp
// IScreenGrabber.h 新增
enum class CaptureMode {
    VIDEO,      // 高帧率视频录制 (默认 30 FPS)
    SNAPSHOT,   // 低帧率快照采集 (默认 0.1 FPS = 10秒/帧)
};
```

### 2. CaptureConfig 配置类

```cpp
// IScreenGrabber.h 新增
struct CaptureConfig {
    CaptureMode mode = CaptureMode::VIDEO;
    
    // VideoMode 配置
    int videoFps = 30;
    
    // SnapshotMode 配置
    int snapshotIntervalMs = 10000;  // 快照间隔 (毫秒)
    float jpegQuality = 0.85f;        // JPEG 压缩质量
    
    // 缩放配置 (仅 SnapshotMode，采集始终是全屏)
    enum class ScaleMode {
        NONE,           // 不缩放，保持原始分辨率
        FIT_LONG_EDGE,  // 按长边缩放 (推荐，适配任意宽高比)
        FIT_BOX,        // 适配到指定宽高框内 (保持宽高比)
    };
    ScaleMode scaleMode = ScaleMode::FIT_LONG_EDGE;
    int maxLongEdge = 1920;  // 长边最大像素 (4K 屏幕会缩放为 1920 宽)
    // 或使用 FIT_BOX 模式时：
    int maxBoxWidth = 1920;
    int maxBoxHeight = 1080;
};
```

### 3. IScreenGrabber 接口扩展

```diff
class IScreenGrabber {
public:
    virtual ~IScreenGrabber() = default;

-   virtual bool start() = 0;
+   virtual bool start(const CaptureConfig& config = CaptureConfig{}) = 0;
    virtual void stop() = 0;
    virtual void pause() = 0;
    virtual void resume() = 0;

+   // 模式管理
+   virtual CaptureMode getCaptureMode() const = 0;
+   virtual void setCaptureMode(CaptureMode mode) = 0;
+   virtual const CaptureConfig& getConfig() const = 0;
+   virtual void setConfig(const CaptureConfig& config) = 0;

    virtual int getWidth() const = 0;
    virtual int getHeight() const = 0;
-   virtual int getFps() const = 0;
+   virtual double getEffectiveFps() const = 0;  // 返回实际帧率
    virtual PixelFormat getPixelFormat() const = 0;

    virtual bool isRunning() const = 0;
    virtual bool isPaused() const = 0;

    virtual FrameData CaptureFrame(int timeout_ms = 100) = 0;
};
```

---

## 组件修改详情

### CaptureLayer

#### [MODIFY] [IScreenGrabber.h](file:///d:/编程/项目/AiVideoAnalsysSystem/cpp/include/core/ScreenRecorder/CaptureLayer/IScreenGrabber.h)

- 添加 `CaptureMode` 枚举
- 添加 `CaptureConfig` 配置结构体
- 扩展接口方法：`setCaptureMode()`, `setConfig()`, `getEffectiveFps()`

---

#### [MODIFY] [GDI_Grabber.h](file:///d:/编程/项目/AiVideoAnalsysSystem/cpp/include/core/ScreenRecorder/CaptureLayer/SpecificGrabber/Win/GDI_Grabber.h)

- 添加 `CaptureConfig m_config_` 成员
- 实现模式相关方法
- 在 SnapshotMode 下实现 JPEG 压缩和缩放

---

#### [MODIFY] [DXGI_Grabber.h](file:///d:/编程/项目/AiVideoAnalsysSystem/cpp/include/core/ScreenRecorder/CaptureLayer/SpecificGrabber/Win/DXGI_Grabber.h)

- 同 GDI_Grabber 的修改

---

### ProcessLayer

#### [MODIFY] [FrameGrabberThread.h](file:///d:/编程/项目/AiVideoAnalsysSystem/cpp/include/core/ScreenRecorder/ProcessLayer/FrameGrabberThread.h)

```diff
class FrameGrabberThread {
public:
-   FrameGrabberThread(std::shared_ptr<IScreenGrabber> grabber, 
-                      ThreadSafetyQueue<FrameData>& queue,
-                      int target_fps = 30);
+   FrameGrabberThread(std::shared_ptr<IScreenGrabber> grabber, 
+                      ThreadSafetyQueue<FrameData>& queue,
+                      const CaptureConfig& config = CaptureConfig{});

+   // 动态配置
+   void setCaptureMode(CaptureMode mode);
+   void setConfig(const CaptureConfig& config);

private:
-   int target_fps_;
+   CaptureConfig config_;
    
    void captureLoop();  // 内部根据 mode 调整循环逻辑
};
```

**核心逻辑改动**：

```cpp
void FrameGrabberThread::captureLoop() {
    while (running_) {
        auto interval = (config_.mode == CaptureMode::VIDEO)
            ? std::chrono::milliseconds(1000 / config_.videoFps)
            : std::chrono::milliseconds(config_.snapshotIntervalMs);
        
        // 采集帧
        FrameData frame = grabber_->CaptureFrame();
        
        if (config_.mode == CaptureMode::SNAPSHOT) {
            // 快照模式: 缩放 + JPEG 压缩
            frame = resizeAndCompress(frame, config_);
        }
        
        frame_queue_.push(std::move(frame));
        
        // 等待下一帧
        std::this_thread::sleep_for(interval);
    }
}
```

---

### OutputLayer

#### [NEW] [SnapshotSaver.h](file:///d:/编程/项目/AiVideoAnalsysSystem/cpp/include/core/ScreenRecorder/WriteLayer/SnapshotSaver.h)

专用于 SnapshotMode 的快照存储组件：

```cpp
class SnapshotSaver {
public:
    SnapshotSaver(const std::string& outputDir, const CaptureConfig& config);
    
    // 保存单帧快照
    bool saveSnapshot(const FrameData& frame);
    
    // 获取保存的快照列表
    std::vector<std::string> getSnapshotPaths() const;
    
    // 存储配额管理
    void setStorageQuota(int64_t maxBytes);
    void cleanupOldSnapshots();
    
private:
    std::string outputDir_;
    CaptureConfig config_;
    int64_t storageQuota_;
};
```

---

### 顶层接口

#### [MODIFY] [ScreenRecorder.h](file:///d:/编程/项目/AiVideoAnalsysSystem/cpp/include/core/ScreenRecorder/ScreenRecorder.h)

```diff
class ScreenRecorder {
public:
-   bool startRecording(std::string& path);
+   bool startRecording(const std::string& path, const CaptureConfig& config = CaptureConfig{});
    
+   // 模式管理
+   void setCaptureMode(CaptureMode mode);
+   CaptureMode getCaptureMode() const;
    
+   // 快照模式专用
+   std::vector<std::string> getSnapshotPaths() const;
+   void setStorageQuota(int64_t maxBytes);
};
```

---

## 数据流对比

### VideoMode 数据流

```
GDI/DXGI → 30 FPS 采集 → FrameQueue → FrameEncoder → MP4 文件
```

### SnapshotMode 数据流

```
GDI/DXGI → 0.1 FPS 采集 → 缩放+JPEG → SnapshotQueue → SnapshotSaver → JPEG 分片
                                                            ↓
                                                   StorageManager (配额监控)
```

---

## Python 层扩展

### Pybind11 绑定

```cpp
// bindings.cpp
py::enum_<CaptureMode>(m, "CaptureMode")
    .value("VIDEO", CaptureMode::VIDEO)
    .value("SNAPSHOT", CaptureMode::SNAPSHOT);

py::class_<CaptureConfig>(m, "CaptureConfig")
    .def(py::init<>())
    .def_readwrite("mode", &CaptureConfig::mode)
    .def_readwrite("video_fps", &CaptureConfig::videoFps)
    .def_readwrite("snapshot_interval_ms", &CaptureConfig::snapshotIntervalMs)
    .def_readwrite("jpeg_quality", &CaptureConfig::jpegQuality);
```

### Python Service 层

```python
# video_service.py
class VideoService:
    def start_video_recording(self, path: str, fps: int = 30):
        config = CaptureConfig()
        config.mode = CaptureMode.VIDEO
        config.video_fps = fps
        self._recorder.start_recording(path, config)
    
    def start_snapshot_capture(self, output_dir: str, interval_sec: float = 10):
        config = CaptureConfig()
        config.mode = CaptureMode.SNAPSHOT
        config.snapshot_interval_ms = int(interval_sec * 1000)
        self._recorder.start_recording(output_dir, config)
```

---

## 存储估算

| 模式 | 帧率 | 1小时估算 | 24小时估算 |
|------|------|-----------|------------|
| VideoMode (1080p H.264) | 30 FPS | ~500 MB | ~12 GB |
| SnapshotMode (1080p JPEG 85%) | 0.1 FPS | ~25 MB | ~600 MB |

> SnapshotMode 存储占用约为 VideoMode 的 **1/20**

---

## 验证计划

### 自动化测试

1. **单元测试**: 验证 `CaptureConfig` 默认值和序列化
   ```powershell
   cd d:\编程\项目\AiVideoAnalsysSystem\cpp
   cmake --build build --target test
   ```

2. **集成测试**: 验证模式切换不会导致崩溃
   - 需要新增测试用例（待实施阶段编写）

### 手动验证

1. **VideoMode 录制测试**
   - 启动应用 → 选择 VideoMode → 录制 10 秒 → 验证输出 MP4

2. **SnapshotMode 采集测试**
   - 启动应用 → 选择 SnapshotMode (间隔 5s) → 运行 30 秒 → 验证输出 6 张 JPEG

3. **模式切换测试**
   - 先 VideoMode 录制 5 秒 → 切换到 SnapshotMode → 采集 15 秒 → 验证两种输出都正确

---

## User Review Required

> [!IMPORTANT]
> **架构决策确认**
> 1. `SnapshotMode` 是否需要支持运行时修改间隔？还是仅在启动时配置？
> 2. 快照存储配额默认值建议为 **1GB**，是否合适？
> 3. 是否需要在 QML UI 中添加模式切换控件？

> [!WARNING]
> **破坏性变更**
> - `IScreenGrabber::start()` 签名变更为 `start(const CaptureConfig&)`
> - `IScreenGrabber::getFps()` 更名为 `getEffectiveFps()` 并改为返回 `double`
> - 需要同步更新所有现有实现类
