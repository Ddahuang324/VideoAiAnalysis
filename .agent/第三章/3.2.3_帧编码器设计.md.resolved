# 3.2.3 å¸§ç¼–ç å™¨è®¾è®¡

> **æ¶ˆè´¹è€…æ ¸å¿ƒ**  
> `FrameEncoder` æ˜¯è§†é¢‘æµå¤„ç†çš„æ¶ˆè´¹è€…,è´Ÿè´£ä»é˜Ÿåˆ—ä¸­å–å‡ºåŸå§‹å¸§æ•°æ®,è¿›è¡Œåƒç´ æ ¼å¼è½¬æ¢å’ŒH.264ç¼–ç ,æœ€ç»ˆå†™å…¥è§†é¢‘æ–‡ä»¶ã€‚æœ¬æ–‡æ¡£è¯¦è§£å…¶è®¾è®¡åŸç†ã€FFmpegé›†æˆå’Œæ€§èƒ½ä¼˜åŒ–ç­–ç•¥ã€‚

---

## ğŸ“‹ ç›®å½•

1. [æ¨¡å—æ¦‚è¿°ä¸å®šä½](#æ¨¡å—æ¦‚è¿°ä¸å®šä½)
2. [è®¾è®¡ç›®æ ‡ä¸æŒ‘æˆ˜](#è®¾è®¡ç›®æ ‡ä¸æŒ‘æˆ˜)
3. [æ ¸å¿ƒæ¶æ„è®¾è®¡](#æ ¸å¿ƒæ¶æ„è®¾è®¡)
4. [è¯¦ç»†å®ç°è§£æ](#è¯¦ç»†å®ç°è§£æ)
5. [åƒç´ æ ¼å¼è½¬æ¢](#åƒç´ æ ¼å¼è½¬æ¢)
6. [FFmpegç¼–ç æµç¨‹](#ffmpegç¼–ç æµç¨‹)
7. [Pybind11å›è°ƒæœºåˆ¶](#pybind11å›è°ƒæœºåˆ¶)
8. [æ€§èƒ½ä¼˜åŒ–ç­–ç•¥](#æ€§èƒ½ä¼˜åŒ–ç­–ç•¥)
9. [å®æˆ˜ä½¿ç”¨æŒ‡å—](#å®æˆ˜ä½¿ç”¨æŒ‡å—)

---

## æ¨¡å—æ¦‚è¿°ä¸å®šä½

### åœ¨ç³»ç»Ÿä¸­çš„ä½ç½®

```mermaid
graph TB
    subgraph "C++æ ¸å¿ƒå±‚"
        Queue[ThreadSafeQueue<br/>å¸§é˜Ÿåˆ—]
        Encoder[FrameEncoder<br/>ç¼–ç çº¿ç¨‹]
        FFmpeg[FFmpegWrapper<br/>ç¼–ç å™¨å°è£…]
        Sws[SwsContext<br/>åƒç´ è½¬æ¢]
    end
    
    subgraph "Pythonä¸šåŠ¡å±‚"
        Service[VideoService<br/>è§†é¢‘æœåŠ¡]
        Callback[å›è°ƒå‡½æ•°<br/>è¿›åº¦/å®Œæˆé€šçŸ¥]
    end
    
    subgraph "æ–‡ä»¶ç³»ç»Ÿ"
        File[è¾“å‡ºè§†é¢‘<br/>output.mp4]
    end
    
    Queue -->|pop| Encoder
    Encoder -->|FrameData| Sws
    Sws -->|YUV420P| FFmpeg
    FFmpeg -->|AVPacket| File
    Encoder -.Pybind11å›è°ƒ.-> Callback
    Callback --> Service
    
    style Encoder fill:#90EE90,stroke:#333,stroke-width:3px
    style FFmpeg fill:#FFB6C1
    style Callback fill:#FFA500
```

### æ ¸å¿ƒèŒè´£

| èŒè´£ | è¯´æ˜ | æŠ€æœ¯å®ç° |
|------|------|---------|
| **é˜Ÿåˆ—æ¶ˆè´¹** | ä»ThreadSafeQueueå–å¸§ | é˜»å¡å¼pop,è¶…æ—¶100ms |
| **æ ¼å¼è½¬æ¢** | BGRA â†’ YUV420P | libswscale (`sws_scale`) |
| **è§†é¢‘ç¼–ç ** | H.264ç¼–ç  | libavcodec (x264) |
| **æ–‡ä»¶å†™å…¥** | å†™å…¥MP4å®¹å™¨ | libavformat |
| **è¿›åº¦é€šçŸ¥** | é€šçŸ¥Pythonå±‚ | Pybind11å›è°ƒ + GIL |

---

## è®¾è®¡ç›®æ ‡ä¸æŒ‘æˆ˜

### æ ¸å¿ƒè®¾è®¡ç›®æ ‡

```mermaid
mindmap
  root((FrameEncoder))
    é«˜æ€§èƒ½ç¼–ç 
      æ”¯æŒ60fpså®æ—¶ç¼–ç 
      CPUå ç”¨ < 30%
      ç¡¬ä»¶åŠ é€Ÿæ”¯æŒ
    é«˜è´¨é‡è¾“å‡º
      H.264ç¼–ç 
      CRFè´¨é‡æ§åˆ¶
      ç ç‡è‡ªé€‚åº”
    å¯é æ€§
      ç¼–ç é”™è¯¯æ¢å¤
      æ–‡ä»¶å®Œæ•´æ€§ä¿è¯
      ä¼˜é›…åœæ­¢
    å¯è§‚æµ‹æ€§
      ç¼–ç è¿›åº¦é€šçŸ¥
      æ–‡ä»¶å¤§å°ç»Ÿè®¡
      æ€§èƒ½æŒ‡æ ‡ç›‘æ§
```

### æŠ€æœ¯æŒ‘æˆ˜

| æŒ‘æˆ˜ | é—®é¢˜ | è§£å†³æ–¹æ¡ˆ |
|------|------|---------|
| **æ ¼å¼è½¬æ¢** | BGRAâ†’YUV420Pè€—æ—¶ | `sws_scale` ç¡¬ä»¶åŠ é€Ÿ + SIMD |
| **ç¼–ç å»¶è¿Ÿ** | H.264ç¼–ç æ…¢äºé‡‡é›† | é˜Ÿåˆ—ç¼“å†² + ç¼–ç å‚æ•°ä¼˜åŒ– |
| **å†…å­˜ç®¡ç†** | AVFrame/AVPacketæ³„æ¼ | RAIIæ™ºèƒ½æŒ‡é’ˆ + è‡ªå®šä¹‰åˆ é™¤å™¨ |
| **GILé˜»å¡** | Pythonå›è°ƒå½±å“æ€§èƒ½ | å¼‚æ­¥é€šçŸ¥ + æ‰¹é‡å›è°ƒ |

---

## æ ¸å¿ƒæ¶æ„è®¾è®¡

### ç±»å®šä¹‰

```cpp
#pragma once

#include <thread>
#include <atomic>
#include <memory>
#include <functional>

#include "ThreadSafeQueue.h"
#include "FrameData.h"
#include "FFmpegWrapper.h"

/**
 * @brief å¸§ç¼–ç å™¨
 * 
 * ä»é˜Ÿåˆ—ä¸­å–å‡ºå¸§,è¿›è¡Œåƒç´ æ ¼å¼è½¬æ¢å’ŒH.264ç¼–ç 
 */
class FrameEncoder {
public:
    /**
     * @brief æ„é€ å‡½æ•°
     * @param queue å¸§é˜Ÿåˆ—
     * @param config ç¼–ç å™¨é…ç½®
     */
    FrameEncoder(
        std::shared_ptr<ThreadSafeQueue<FrameData>> queue,
        const EncoderConfig& config
    );
    
    ~FrameEncoder();
    
    // ç¦æ­¢æ‹·è´
    FrameEncoder(const FrameEncoder&) = delete;
    FrameEncoder& operator=(const FrameEncoder&) = delete;
    
    /**
     * @brief å¯åŠ¨ç¼–ç çº¿ç¨‹
     */
    void start();
    
    /**
     * @brief åœæ­¢ç¼–ç çº¿ç¨‹
     */
    void stop();
    
    /**
     * @brief è·å–ç»Ÿè®¡ä¿¡æ¯
     */
    int64_t getEncodedCount() const { return encoded_count_; }
    int64_t getOutputFileSize() const;
    bool isRunning() const { return running_; }
    
    // Pybind11å›è°ƒå‡½æ•°ç±»å‹
    using ProgressCallback = std::function<void(int64_t, int64_t)>;
    using FinishedCallback = std::function<void(int64_t, const std::string&)>;
    using ErrorCallback = std::function<void(const std::string&)>;
    
    /**
     * @brief è®¾ç½®å›è°ƒå‡½æ•°
     */
    void setProgressCallback(ProgressCallback callback) {
        on_progress_ = callback;
    }
    void setFinishedCallback(FinishedCallback callback) {
        on_finished_ = callback;
    }
    void setErrorCallback(ErrorCallback callback) {
        on_error_ = callback;
    }
    
private:
    /**
     * @brief ç¼–ç å¾ªç¯ (åœ¨ç‹¬ç«‹çº¿ç¨‹ä¸­è¿è¡Œ)
     */
    void encodeLoop();
    
    /**
     * @brief å¤„ç†ä¸€å¸§
     */
    bool processFrame(const FrameData& frame);
    
    /**
     * @brief è°ƒç”¨Pythonå›è°ƒ
     */
    void notifyProgress();
    void notifyFinished();
    void notifyError(const std::string& error);
    
    // æ ¸å¿ƒç»„ä»¶
    std::shared_ptr<ThreadSafeQueue<FrameData>> queue_;
    std::unique_ptr<FFmpegWrapper> encoder_;
    std::unique_ptr<std::thread> thread_;
    EncoderConfig config_;
    
    // çŠ¶æ€æ ‡å¿—
    std::atomic<bool> running_{false};
    
    // ç»Ÿè®¡ä¿¡æ¯
    std::atomic<int64_t> encoded_count_{0};
    
    // Pythonå›è°ƒ
    ProgressCallback on_progress_;
    FinishedCallback on_finished_;
    ErrorCallback on_error_;
};
```

### ç¼–ç å™¨é…ç½®

```cpp
struct EncoderConfig {
    std::string output_path;        // è¾“å‡ºæ–‡ä»¶è·¯å¾„
    int width;                       // è§†é¢‘å®½åº¦
    int height;                      // è§†é¢‘é«˜åº¦
    int fps;                         // å¸§ç‡
    int bitrate;                     // ç ç‡ (bps)
    int crf;                         // è´¨é‡å‚æ•° (0-51, é»˜è®¤23)
    std::string preset;              // ç¼–ç é¢„è®¾ (ultrafast/fast/medium/slow)
    std::string codec;               // ç¼–ç å™¨ (libx264/h264_nvenc)
    
    // é»˜è®¤é…ç½®
    static EncoderConfig defaultConfig() {
        return {
            .output_path = "output.mp4",
            .width = 1920,
            .height = 1080,
            .fps = 60,
            .bitrate = 8000000,  // 8Mbps
            .crf = 23,
            .preset = "fast",
            .codec = "libx264"
        };
    }
};
```

### ç¼–ç æµç¨‹

```mermaid
sequenceDiagram
    participant Queue as ThreadSafeQueue
    participant Encoder as FrameEncoder
    participant Sws as SwsContext
    participant FFmpeg as FFmpegWrapper
    participant File as è¾“å‡ºæ–‡ä»¶
    
    Note over Encoder: å¯åŠ¨ç¼–ç çº¿ç¨‹
    Encoder->>FFmpeg: initialize(config)
    FFmpeg->>File: åˆ›å»ºæ–‡ä»¶,å†™å…¥å¤´éƒ¨
    
    loop ç¼–ç å¾ªç¯
        Encoder->>Queue: pop(frame, 100ms)
        
        alt é˜Ÿåˆ—éç©º
            Queue-->>Encoder: FrameData (BGRA)
            
            Encoder->>Sws: sws_scale(BGRA â†’ YUV420P)
            Sws-->>Encoder: AVFrame (YUV420P)
            
            Encoder->>FFmpeg: encodeFrame(yuv_frame)
            FFmpeg->>FFmpeg: avcodec_send_frame()
            FFmpeg->>FFmpeg: avcodec_receive_packet()
            FFmpeg->>File: av_interleaved_write_frame()
            
            Encoder->>Encoder: encoded_count_++
            
            alt æ¯30å¸§
                Encoder->>Encoder: notifyProgress()
            end
        else é˜Ÿåˆ—ä¸ºç©º
            Note over Encoder: è¶…æ—¶,ç»§ç»­ç­‰å¾…
        end
    end
    
    Note over Encoder: åœæ­¢ä¿¡å·
    Encoder->>FFmpeg: finalize()
    FFmpeg->>FFmpeg: flushç¼–ç å™¨
    FFmpeg->>File: av_write_trailer()
    Encoder->>Encoder: notifyFinished()
```

---

## è¯¦ç»†å®ç°è§£æ

### start() æ–¹æ³•

```cpp
void FrameEncoder::start() {
    if (running_) {
        return;  // å·²ç»åœ¨è¿è¡Œ
    }
    
    // 1ï¸âƒ£ åˆ›å»ºFFmpegç¼–ç å™¨
    encoder_ = std::make_unique<FFmpegWrapper>();
    
    // 2ï¸âƒ£ è®¾ç½®è¿è¡Œæ ‡å¿—
    running_ = true;
    
    // 3ï¸âƒ£ å¯åŠ¨ç¼–ç çº¿ç¨‹
    thread_ = std::make_unique<std::thread>(&FrameEncoder::encodeLoop, this);
    
    std::cout << "[FrameEncoder] Started" << std::endl;
}
```

### encodeLoop() - æ ¸å¿ƒç¼–ç å¾ªç¯

```cpp
void FrameEncoder::encodeLoop() {
    // 1ï¸âƒ£ åˆå§‹åŒ–ç¼–ç å™¨
    if (!encoder_->initialize(config_)) {
        notifyError("Failed to initialize encoder: " + encoder_->getLastError());
        return;
    }
    
    std::cout << "[FrameEncoder] Encoding started" << std::endl;
    
    // 2ï¸âƒ£ ä¸»å¾ªç¯
    while (running_) {
        FrameData frame;
        
        // 3ï¸âƒ£ ä»é˜Ÿåˆ—å–å¸§ (è¶…æ—¶100ms)
        if (!queue_->pop(frame, std::chrono::milliseconds(100))) {
            // è¶…æ—¶,ç»§ç»­ç­‰å¾…
            continue;
        }
        
        // 4ï¸âƒ£ å¤„ç†å¸§
        if (!processFrame(frame)) {
            notifyError("Failed to encode frame: " + encoder_->getLastError());
            break;
        }
        
        // 5ï¸âƒ£ æ›´æ–°ç»Ÿè®¡
        encoded_count_++;
        
        // 6ï¸âƒ£ æ¯30å¸§é€šçŸ¥ä¸€æ¬¡è¿›åº¦
        if (encoded_count_ % 30 == 0) {
            notifyProgress();
        }
    }
    
    // 7ï¸âƒ£ å®Œæˆç¼–ç 
    encoder_->finalize();
    
    std::cout << "[FrameEncoder] Encoding finished, total frames: " 
              << encoded_count_ << std::endl;
    
    // 8ï¸âƒ£ é€šçŸ¥å®Œæˆ
    notifyFinished();
}
```

### processFrame() - å¸§å¤„ç†

```cpp
bool FrameEncoder::processFrame(const FrameData& frame) {
    // ç›´æ¥è°ƒç”¨FFmpegWrapperç¼–ç 
    // (åƒç´ è½¬æ¢åœ¨FFmpegWrapperå†…éƒ¨å®Œæˆ)
    return encoder_->encodeFrame(frame);
}
```

---

## åƒç´ æ ¼å¼è½¬æ¢

### ä¸ºä»€ä¹ˆéœ€è¦æ ¼å¼è½¬æ¢?

````carousel
**é‡‡é›†æ ¼å¼: BGRA**

```
å±å¹•é‡‡é›†å™¨è¾“å‡º: BGRA (æ¯åƒç´ 4å­—èŠ‚)
- B: è“è‰²é€šé“
- G: ç»¿è‰²é€šé“
- R: çº¢è‰²é€šé“
- A: Alphaé€šé“ (é€æ˜åº¦)
```

**ç‰¹ç‚¹**:
- âœ… é‡‡é›†å™¨åŸç”Ÿæ ¼å¼
- âœ… æ— æŸ,åŒ…å«æ‰€æœ‰ä¿¡æ¯
- âŒ æ–‡ä»¶å¤§,ä¸é€‚åˆå­˜å‚¨

<!-- slide -->

**ç¼–ç æ ¼å¼: YUV420P**

```
H.264ç¼–ç å™¨è¾“å…¥: YUV420P
- Y: äº®åº¦ (Luma)
- U: è‰²åº¦è“ (Cb)
- V: è‰²åº¦çº¢ (Cr)
```

**ç‰¹ç‚¹**:
- âœ… å‹ç¼©ç‡é«˜ (1.5å­—èŠ‚/åƒç´ )
- âœ… H.264æ ‡å‡†æ ¼å¼
- âœ… äººçœ¼å‹å¥½ (äº®åº¦è‰²åº¦åˆ†ç¦»)
- âš ï¸ éœ€è¦è½¬æ¢

<!-- slide -->

**è½¬æ¢å¯¹æ¯”**

| æ ¼å¼ | æ¯åƒç´ å­—èŠ‚ | 1080på¸§å¤§å° | é€‚ç”¨åœºæ™¯ |
|------|----------|------------|---------|
| BGRA | 4å­—èŠ‚ | 8.3MB | é‡‡é›†ã€å¤„ç† |
| YUV420P | 1.5å­—èŠ‚ | 3.1MB | ç¼–ç ã€å­˜å‚¨ |

**æ€§èƒ½å½±å“**:
- è½¬æ¢è€—æ—¶: ~2ms/å¸§ (1080p)
- å†…å­˜èŠ‚çœ: 62.5%
- å¿…è¦æ€§: H.264è¦æ±‚
````

### SwsContext é…ç½®

```cpp
// åœ¨FFmpegWrapperä¸­
bool FFmpegWrapper::initialize(const EncoderConfig& config) {
    // ... å…¶ä»–åˆå§‹åŒ– ...
    
    // åˆ›å»ºåƒç´ æ ¼å¼è½¬æ¢ä¸Šä¸‹æ–‡
    sws_ctx_ = SwsContextPtr(
        sws_getContext(
            config.width, config.height, AV_PIX_FMT_BGRA,  // æºæ ¼å¼
            config.width, config.height, AV_PIX_FMT_YUV420P,  // ç›®æ ‡æ ¼å¼
            SWS_BILINEAR,  // è½¬æ¢ç®—æ³•
            nullptr, nullptr, nullptr
        ),
        [](SwsContext* ctx) { sws_freeContext(ctx); }
    );
    
    if (!sws_ctx_) {
        last_error_ = "Failed to create SwsContext";
        return false;
    }
    
    return true;
}
```

### è½¬æ¢ç®—æ³•å¯¹æ¯”

| ç®—æ³• | è´¨é‡ | é€Ÿåº¦ | é€‚ç”¨åœºæ™¯ |
|------|------|------|---------|
| `SWS_FAST_BILINEAR` | â­â­ | âš¡âš¡âš¡ | å®æ—¶å½•åˆ¶ âœ… |
| `SWS_BILINEAR` | â­â­â­ | âš¡âš¡ | å¹³è¡¡æ¨¡å¼ âœ… |
| `SWS_BICUBIC` | â­â­â­â­ | âš¡ | é«˜è´¨é‡ç¦»çº¿ |
| `SWS_LANCZOS` | â­â­â­â­â­ | ğŸŒ | ä¸“ä¸šåæœŸ |

> [!TIP]
> **æ¨èé…ç½®**: `SWS_BILINEAR`
> 
> åœ¨è´¨é‡å’Œæ€§èƒ½ä¹‹é—´å–å¾—è‰¯å¥½å¹³è¡¡,é€‚åˆ60fpså®æ—¶å½•åˆ¶ã€‚

### convertPixelFormat() å®ç°

```cpp
bool FFmpegWrapper::convertPixelFormat(const FrameData& src, AVFrame* dst) {
    // 1ï¸âƒ£ å‡†å¤‡æºæ•°æ®
    const uint8_t* src_data[1] = { src.data };
    int src_linesize[1] = { src.stride > 0 ? src.stride : src.width * 4 };
    
    // 2ï¸âƒ£ æ‰§è¡Œè½¬æ¢
    int ret = sws_scale(
        sws_ctx_.get(),
        src_data,           // æºæ•°æ®æŒ‡é’ˆ
        src_linesize,       // æºè¡Œå­—èŠ‚æ•°
        0,                  // èµ·å§‹è¡Œ
        src.height,         // é«˜åº¦
        dst->data,          // ç›®æ ‡æ•°æ®æŒ‡é’ˆ
        dst->linesize       // ç›®æ ‡è¡Œå­—èŠ‚æ•°
    );
    
    if (ret <= 0) {
        last_error_ = "sws_scale failed";
        return false;
    }
    
    return true;
}
```

#### æ€§èƒ½ä¼˜åŒ–æŠ€å·§

```cpp
// âœ… ä¼˜åŒ–1: å†…å­˜å¯¹é½
AVFrame* yuv_frame = av_frame_alloc();
yuv_frame->format = AV_PIX_FMT_YUV420P;
yuv_frame->width = width;
yuv_frame->height = height;
av_frame_get_buffer(yuv_frame, 32);  // 32å­—èŠ‚å¯¹é½,SIMDä¼˜åŒ–

// âœ… ä¼˜åŒ–2: å¤ç”¨SwsContext
// ä¸è¦æ¯å¸§éƒ½åˆ›å»º,åœ¨åˆå§‹åŒ–æ—¶åˆ›å»ºä¸€æ¬¡,é‡å¤ä½¿ç”¨

// âœ… ä¼˜åŒ–3: æ£€æŸ¥stride
int src_linesize = src.stride > 0 ? src.stride : src.width * 4;
// æœ‰äº›é‡‡é›†å™¨çš„stride != width * 4
```

---

## FFmpegç¼–ç æµç¨‹

### ç¼–ç å™¨åˆå§‹åŒ–

```cpp
bool FFmpegWrapper::initialize(const EncoderConfig& config) {
    // 1ï¸âƒ£ æŸ¥æ‰¾ç¼–ç å™¨
    const AVCodec* codec = avcodec_find_encoder_by_name(config.codec.c_str());
    if (!codec) {
        last_error_ = "Codec not found: " + config.codec;
        return false;
    }
    
    // 2ï¸âƒ£ åˆ›å»ºç¼–ç å™¨ä¸Šä¸‹æ–‡
    codec_ctx_ = AVCodecContextPtr(
        avcodec_alloc_context3(codec),
        [](AVCodecContext* ctx) { avcodec_free_context(&ctx); }
    );
    
    // 3ï¸âƒ£ é…ç½®ç¼–ç å™¨å‚æ•°
    codec_ctx_->width = config.width;
    codec_ctx_->height = config.height;
    codec_ctx_->time_base = {1, config.fps};
    codec_ctx_->framerate = {config.fps, 1};
    codec_ctx_->pix_fmt = AV_PIX_FMT_YUV420P;
    codec_ctx_->bit_rate = config.bitrate;
    
    // CRFè´¨é‡æ§åˆ¶
    av_opt_set(codec_ctx_->priv_data, "crf", std::to_string(config.crf).c_str(), 0);
    av_opt_set(codec_ctx_->priv_data, "preset", config.preset.c_str(), 0);
    
    // 4ï¸âƒ£ æ‰“å¼€ç¼–ç å™¨
    if (avcodec_open2(codec_ctx_.get(), codec, nullptr) < 0) {
        last_error_ = "Failed to open codec";
        return false;
    }
    
    // 5ï¸âƒ£ åˆ›å»ºè¾“å‡ºæ–‡ä»¶
    if (!createOutputFile(config.output_path)) {
        return false;
    }
    
    return true;
}
```

### ç¼–ç å‚æ•°è¯¦è§£

````carousel
**CRF (Constant Rate Factor)**

```cpp
// CRFèŒƒå›´: 0-51
// å€¼è¶Šå°,è´¨é‡è¶Šé«˜,æ–‡ä»¶è¶Šå¤§
av_opt_set(ctx->priv_data, "crf", "23", 0);
```

| CRF | è´¨é‡ | æ–‡ä»¶å¤§å° | é€‚ç”¨åœºæ™¯ |
|-----|------|---------|---------|
| 18 | æé«˜ | å¾ˆå¤§ | ä¸“ä¸šå­˜æ¡£ |
| 23 | é«˜ | é€‚ä¸­ | **æ¨è** âœ… |
| 28 | ä¸­ | è¾ƒå° | å¿«é€Ÿé¢„è§ˆ |

<!-- slide -->

**Preset (ç¼–ç é€Ÿåº¦)**

```cpp
// å½±å“ç¼–ç é€Ÿåº¦å’Œå‹ç¼©ç‡
av_opt_set(ctx->priv_data, "preset", "fast", 0);
```

| Preset | é€Ÿåº¦ | å‹ç¼©ç‡ | CPUå ç”¨ |
|--------|------|--------|---------|
| ultrafast | âš¡âš¡âš¡ | ä½ | 10% |
| fast | âš¡âš¡ | ä¸­ | 20% | **æ¨è** âœ… |
| medium | âš¡ | é«˜ | 30% |
| slow | ğŸŒ | å¾ˆé«˜ | 50% |

<!-- slide -->

**Bitrate (ç ç‡)**

```cpp
codec_ctx->bit_rate = 8000000;  // 8Mbps
```

| åˆ†è¾¨ç‡ | æ¨èç ç‡ | è´¨é‡ |
|--------|---------|------|
| 1080p60 | 8-12 Mbps | é«˜è´¨é‡ âœ… |
| 1080p30 | 4-6 Mbps | æ ‡å‡† |
| 720p60 | 4-6 Mbps | æ ‡å‡† |
````

### encodeFrame() å®ç°

```cpp
bool FFmpegWrapper::encodeFrame(const FrameData& frame_data) {
    // 1ï¸âƒ£ è½¬æ¢åƒç´ æ ¼å¼
    if (!convertPixelFormat(frame_data, yuv_frame_.get())) {
        return false;
    }
    
    // 2ï¸âƒ£ è®¾ç½®æ—¶é—´æˆ³
    yuv_frame_->pts = frame_count_++;
    
    // 3ï¸âƒ£ å‘é€å¸§åˆ°ç¼–ç å™¨
    int ret = avcodec_send_frame(codec_ctx_.get(), yuv_frame_.get());
    if (ret < 0) {
        last_error_ = "avcodec_send_frame failed";
        return false;
    }
    
    // 4ï¸âƒ£ æ¥æ”¶ç¼–ç åçš„æ•°æ®åŒ…
    while (ret >= 0) {
        AVPacket* pkt = av_packet_alloc();
        ret = avcodec_receive_packet(codec_ctx_.get(), pkt);
        
        if (ret == AVERROR(EAGAIN) || ret == AVERROR_EOF) {
            av_packet_free(&pkt);
            break;
        } else if (ret < 0) {
            av_packet_free(&pkt);
            last_error_ = "avcodec_receive_packet failed";
            return false;
        }
        
        // 5ï¸âƒ£ å†™å…¥æ–‡ä»¶
        pkt->stream_index = video_stream_->index;
        av_packet_rescale_ts(pkt, codec_ctx_->time_base, video_stream_->time_base);
        
        ret = av_interleaved_write_frame(format_ctx_.get(), pkt);
        av_packet_free(&pkt);
        
        if (ret < 0) {
            last_error_ = "av_interleaved_write_frame failed";
            return false;
        }
    }
    
    return true;
}
```

### finalize() - å®Œæˆç¼–ç 

```cpp
void FFmpegWrapper::finalize() {
    // 1ï¸âƒ£ Flushç¼–ç å™¨ (è¾“å‡ºç¼“å†²çš„å¸§)
    avcodec_send_frame(codec_ctx_.get(), nullptr);
    
    AVPacket* pkt = av_packet_alloc();
    while (avcodec_receive_packet(codec_ctx_.get(), pkt) == 0) {
        av_interleaved_write_frame(format_ctx_.get(), pkt);
        av_packet_unref(pkt);
    }
    av_packet_free(&pkt);
    
    // 2ï¸âƒ£ å†™å…¥æ–‡ä»¶å°¾éƒ¨
    av_write_trailer(format_ctx_.get());
    
    // 3ï¸âƒ£ å…³é—­æ–‡ä»¶
    if (format_ctx_ && format_ctx_->pb) {
        avio_closep(&format_ctx_->pb);
    }
    
    std::cout << "[FFmpegWrapper] Finalized" << std::endl;
}
```

---

## Pybind11å›è°ƒæœºåˆ¶

### å›è°ƒå‡½æ•°å®ç°

```cpp
void FrameEncoder::notifyProgress() {
    if (!on_progress_) {
        return;
    }
    
    try {
        // è·å–Python GIL
        py::gil_scoped_acquire acquire;
        
        // è°ƒç”¨Pythonå›è°ƒ
        on_progress_(
            encoded_count_.load(),
            encoder_->getOutputFileSize()
        );
    } catch (const std::exception& e) {
        std::cerr << "[FrameEncoder] Progress callback error: " << e.what() << std::endl;
    }
}

void FrameEncoder::notifyFinished() {
    if (!on_finished_) {
        return;
    }
    
    try {
        py::gil_scoped_acquire acquire;
        on_finished_(
            encoded_count_.load(),
            config_.output_path
        );
    } catch (const std::exception& e) {
        std::cerr << "[FrameEncoder] Finished callback error: " << e.what() << std::endl;
    }
}
```

### Pybind11ç»‘å®š

```cpp
PYBIND11_MODULE(video_analysis_cpp, m) {
    py::class_<FrameEncoder, std::shared_ptr<FrameEncoder>>(m, "FrameEncoder")
        .def(py::init<
            std::shared_ptr<ThreadSafeQueue<FrameData>>,
            const EncoderConfig&
        >())
        .def("start", &FrameEncoder::start)
        .def("stop", &FrameEncoder::stop)
        .def("get_encoded_count", &FrameEncoder::getEncodedCount)
        .def("get_output_file_size", &FrameEncoder::getOutputFileSize)
        .def("is_running", &FrameEncoder::isRunning)
        
        // å›è°ƒå‡½æ•°
        .def("set_progress_callback", &FrameEncoder::setProgressCallback)
        .def("set_finished_callback", &FrameEncoder::setFinishedCallback)
        .def("set_error_callback", &FrameEncoder::setErrorCallback);
    
    // ç¼–ç å™¨é…ç½®
    py::class_<EncoderConfig>(m, "EncoderConfig")
        .def(py::init<>())
        .def_readwrite("output_path", &EncoderConfig::output_path)
        .def_readwrite("width", &EncoderConfig::width)
        .def_readwrite("height", &EncoderConfig::height)
        .def_readwrite("fps", &EncoderConfig::fps)
        .def_readwrite("bitrate", &EncoderConfig::bitrate)
        .def_readwrite("crf", &EncoderConfig::crf)
        .def_readwrite("preset", &EncoderConfig::preset)
        .def_readwrite("codec", &EncoderConfig::codec)
        .def_static("default_config", &EncoderConfig::defaultConfig);
}
```

---

## æ€§èƒ½ä¼˜åŒ–ç­–ç•¥

### å†…å­˜ç®¡ç†ä¼˜åŒ–

```cpp
// âœ… ä½¿ç”¨æ™ºèƒ½æŒ‡é’ˆ + è‡ªå®šä¹‰åˆ é™¤å™¨
using AVFramePtr = std::unique_ptr<AVFrame, decltype(&av_frame_free)>;
using AVPacketPtr = std::unique_ptr<AVPacket, decltype(&av_packet_free)>;

AVFramePtr yuv_frame_(av_frame_alloc(), av_frame_free);
```

### ç¼–ç å‚æ•°è°ƒä¼˜

| å‚æ•° | ä½å»¶è¿Ÿ | å¹³è¡¡ | é«˜è´¨é‡ |
|------|--------|------|--------|
| **Preset** | ultrafast | fast âœ… | medium |
| **CRF** | 28 | 23 âœ… | 18 |
| **Bitrate** | 4Mbps | 8Mbps âœ… | 12Mbps |
| **CPUå ç”¨** | 10% | 20% | 35% |

### ç¡¬ä»¶åŠ é€Ÿ

```cpp
// ä½¿ç”¨NVIDIAç¡¬ä»¶ç¼–ç å™¨
EncoderConfig config;
config.codec = "h264_nvenc";  // æ›¿ä»£libx264
config.preset = "p4";  // NVENCé¢„è®¾

// æ€§èƒ½æå‡:
// - CPUå ç”¨: 20% â†’ 5%
// - ç¼–ç é€Ÿåº¦: 2x-3xæå‡
```

---

## å®æˆ˜ä½¿ç”¨æŒ‡å—

### C++å±‚ä½¿ç”¨

```cpp
#include "FrameEncoder.h"

int main() {
    // åˆ›å»ºé˜Ÿåˆ—
    auto queue = std::make_shared<ThreadSafeQueue<FrameData>>(30);
    
    // é…ç½®ç¼–ç å™¨
    EncoderConfig config = EncoderConfig::defaultConfig();
    config.output_path = "recording.mp4";
    config.width = 1920;
    config.height = 1080;
    config.fps = 60;
    
    // åˆ›å»ºç¼–ç å™¨
    auto encoder = std::make_shared<FrameEncoder>(queue, config);
    
    // è®¾ç½®å›è°ƒ
    encoder->setProgressCallback([](int64_t frames, int64_t size) {
        std::cout << "Encoded: " << frames << " frames, " 
                  << size / 1024 / 1024 << " MB" << std::endl;
    });
    
    // å¯åŠ¨
    encoder->start();
    
    // ... è¿è¡Œ ...
    
    // åœæ­¢
    encoder->stop();
    
    return 0;
}
```

### Pythonå±‚ä½¿ç”¨

```python
import video_analysis_cpp as vac

class VideoService:
    def __init__(self):
        self.queue = vac.ThreadSafeQueue(30)
        
        # é…ç½®ç¼–ç å™¨
        config = vac.EncoderConfig.default_config()
        config.output_path = "recording.mp4"
        config.fps = 60
        
        self.encoder = vac.FrameEncoder(self.queue, config)
        
        # è®¾ç½®å›è°ƒ
        self.encoder.set_progress_callback(self._on_progress)
        self.encoder.set_finished_callback(self._on_finished)
    
    def _on_progress(self, frames: int, file_size: int):
        """ç¼–ç è¿›åº¦å›è°ƒ"""
        mb = file_size / 1024 / 1024
        print(f"ğŸ“¹ Encoded: {frames} frames, {mb:.1f} MB")
        self.progress_signal.emit(frames, mb)
    
    def _on_finished(self, total_frames: int, output_path: str):
        """ç¼–ç å®Œæˆå›è°ƒ"""
        print(f"âœ… Encoding finished: {total_frames} frames")
        print(f"ğŸ“ Output: {output_path}")
        self.finished_signal.emit(output_path)
```

---

## æ€»ç»“

`FrameEncoder` æ˜¯è§†é¢‘æµå¤„ç†çš„æ¶ˆè´¹è€…æ ¸å¿ƒ,å…³é”®ç‰¹æ€§:

âœ… **é«˜æ•ˆç¼–ç **: H.264å®æ—¶ç¼–ç ,æ”¯æŒ60fps  
âœ… **æ ¼å¼è½¬æ¢**: BGRAâ†’YUV420P,SIMDåŠ é€Ÿ  
âœ… **FFmpegé›†æˆ**: å®Œæ•´çš„ç¼–ç æµç¨‹å°è£…  
âœ… **è·¨è¯­è¨€é€šä¿¡**: Pybind11å›è°ƒ + GILç®¡ç†  
âœ… **ç¡¬ä»¶åŠ é€Ÿ**: æ”¯æŒNVENCç­‰ç¡¬ä»¶ç¼–ç å™¨

**ä¸‹ä¸€æ­¥**: æ•´åˆç”Ÿäº§è€…å’Œæ¶ˆè´¹è€… [3.2.4 ç”Ÿäº§è€…-æ¶ˆè´¹è€…åä½œæœºåˆ¶](file:///d:/ç¼–ç¨‹/é¡¹ç›®/AiVideoAnalsysSystem/.agent/ç¬¬ä¸‰ç« /3.2.4_ç”Ÿäº§è€…æ¶ˆè´¹è€…åä½œ.md)
