# Mermaid 渲染架构重构方案

## 概述
当前 Mermaid 渲染使用 Playwright 的 `sync_api`。在后台线程（如 [MarkdownWorker](file:///d:/%E7%BC%96%E7%A8%8B/%E9%A1%B9%E7%9B%AE/AiVideoAnalsysSystem/python/viewmodels/history_viewmodel.py#14-27)）中调用时，会因为 Playwright 无法跨线程切换而导致 `cannot switch to a different thread` 崩溃。为了保证 UI 流畅且能够生成完美的渲染结果，我们需要将渲染逻辑限制在它自己的专用线程中。

## 方案设计

### 1. 专用渲染线程 (Render Thread)
- 创建一个专用的渲染线程类，该线程持有 Playwright 实例。
- 使用信号/槽或阻塞式队列来接收渲染请求。
- 确保所有 Playwright 调用都在该线程内部完成。

### 2. MarkdownService 集成
- `MarkdownService` 将持有该渲染器线程的引用。
- 提供同步等待的方法（用于后台工作线程）或信号（用于 UI 线程）。

## 拟议更改

### [Component] Markdown Service Refactoring

#### [MODIFY] [markdown_service.py](file:///d:/%E7%BC%96%E7%A8%8B/%E9%A1%B9%E7%9B%AE/AiVideoAnalsysSystem/python/services/markdown_service.py)
- 定义 `MermaidRenderer` 类（基于 `QObject` 和专用线程）。
- 修改 `MarkdownService` 在初始化时启动渲染线程。
- 使用事件等待机制，让后台 Worker 线程可以同步等待渲染结果，而不会导致线程冲突。

### [Component] Initialization Hook

#### [MODIFY] [history_viewmodel.py](file:///d:/%E7%BC%96%E7%A8%8B/%E9%A1%B9%E7%9B%AE/AiVideoAnalsysSystem/python/viewmodels/history_viewmodel.py)
- 确保 `MarkdownService` 在适当的时机（通常是主线程初始化时）被创建。

## 验证计划
- 使用现有的分析脚本触发分析。
- 观察日志，确认 Mermaid 渲染成功且没有线程冲突警告。
- 检查生成的结果中是否有正确的 SVG 图像。
