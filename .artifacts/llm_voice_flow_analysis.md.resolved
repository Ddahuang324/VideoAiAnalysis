# LLM_Voice_Flow é¡¹ç›®æŠ€æœ¯ä¼˜åŠ¿åˆ†æä¸å­¦ä¹ å»ºè®®

> **æ–‡æ¡£ç›®æ ‡**: å¯¹æ¯”åˆ†æ LLM_Voice_Flow å’Œ AiVideoAnalsysSystem ä¸¤ä¸ªé¡¹ç›®,æ€»ç»“å‰è€…åœ¨ C++ å·¥ç¨‹å®è·µå’Œæ¨¡å‹æ¡†æ¶è®¾è®¡ä¸Šçš„ä¼˜åŠ¿,ä¸ºå½“å‰é¡¹ç›®æä¾›æ”¹è¿›æ–¹å‘ã€‚

---

## ä¸€ã€é¡¹ç›®æ¦‚è§ˆå¯¹æ¯”

### 1.1 AiVideoAnalsysSystem (å½“å‰é¡¹ç›®)

**æ ¸å¿ƒåŠŸèƒ½**: AI è§†é¢‘åˆ†æç³»ç»Ÿ
- **ScreenRecorder æ¨¡å—**: å±å¹•/éŸ³é¢‘é‡‡é›† + å®æ—¶ç¼–ç 
- **KeyFrame æ¨¡å—**: å…³é”®å¸§æ£€æµ‹(è¿åŠ¨/åœºæ™¯/æ–‡æœ¬)

**æŠ€æœ¯æ ˆ**:
- **æ¨ç†å¼•æ“**: ONNX Runtime
- **è§†é¢‘å¤„ç†**: FFmpeg (ç¼–è§£ç )
- **å›¾åƒå¤„ç†**: OpenCV
- **è¯­è¨€ç»‘å®š**: pybind11 (C++ â†” Python)
- **æ„å»ºç³»ç»Ÿ**: CMake
- **æµ‹è¯•æ¡†æ¶**: Google Test

**æ¶æ„ç‰¹ç‚¹**:
- åˆ†å±‚è®¾è®¡: CaptureLayer â†’ ProcessLayer
- é™æ€åº“ + Python ç»‘å®š
- å•æœºå¤„ç†æµç¨‹

### 1.2 LLM_Voice_Flow (å‚è€ƒé¡¹ç›®)

**æ ¸å¿ƒåŠŸèƒ½**: ç«¯åˆ°ç«¯è¯­éŸ³å¯¹è¯ç³»ç»Ÿ
- **Voice æ¨¡å—**: å®æ—¶è¯­éŸ³è¯†åˆ« (ASR)
- **LLM æ¨¡å—**: å¤§è¯­è¨€æ¨¡å‹æ¨ç†
- **TTS æ¨¡å—**: æ–‡æœ¬è½¬è¯­éŸ³åˆæˆ

**æŠ€æœ¯æ ˆ**:
- **æ¨ç†å¼•æ“**: 
  - sherpa-onnx (ASR)
  - RKNN-LLM (LLM ç¡¬ä»¶åŠ é€Ÿ)
  - è‡ªå®šä¹‰ TTS å¼•æ“ (çº¯ C++)
- **è¿›ç¨‹é€šä¿¡**: ZeroMQ
- **æ•°å­¦åº“**: Eigen 3.4.0
- **éŸ³é¢‘**: ALSA (Linux)
- **NLP**: cppjieba, WeText

**æ¶æ„ç‰¹ç‚¹**:
- å¾®æœåŠ¡æ¶æ„: ç‹¬ç«‹è¿›ç¨‹ + æ¶ˆæ¯é˜Ÿåˆ—
- å®æ—¶æµå¼å¤„ç†
- ç¡¬ä»¶åŠ é€Ÿä¼˜åŒ–

---

## äºŒã€æ ¸å¿ƒæŠ€æœ¯ä¼˜åŠ¿å¯¹æ¯”

### 2.1 â­ è¿›ç¨‹é—´é€šä¿¡æ¶æ„ (ZeroMQ)

#### **LLM_Voice_Flow çš„å®ç°**

```mermaid
graph LR
    A[Voice ASR<br/>ç‹¬ç«‹è¿›ç¨‹] -->|ZMQ REQ/REP<br/>tcp://localhost:xxxx| B[LLM æ¨ç†<br/>ç‹¬ç«‹è¿›ç¨‹]
    B -->|ZMQ REQ/REP<br/>tcp://localhost:7777| C[TTS åˆæˆ<br/>ç‹¬ç«‹è¿›ç¨‹]
    C -->|ZMQ PUB/SUB<br/>tcp://*:6677| A
    
    style A fill:#e1f5ff
    style B fill:#fff4e1
    style C fill:#ffe1f5
```

**å…³é”®ä»£ç ç¤ºä¾‹**:

```cpp
// LLM æ¨¡å— (llm_demo.cpp)
zmq_component::ZmqServer server;  // æ¥æ”¶ ASR æ–‡æœ¬
zmq_component::ZmqClient client("tcp://localhost:7777");  // å‘é€åˆ° TTS

// TTS æ¨¡å— (main.cpp)
zmq_component::ZmqServer server("tcp://*:7777");  // æ¥æ”¶ LLM æ–‡æœ¬
zmq_component::ZmqServer status_server("tcp://*:6677");  // çŠ¶æ€åé¦ˆ
```

**ä¼˜åŠ¿åˆ†æ**:

| ç»´åº¦ | LLM_Voice_Flow (ZeroMQ) | AiVideoAnalsysSystem (å½“å‰) |
|------|-------------------------|------------------------------|
| **è¿›ç¨‹éš”ç¦»** | âœ… ç‹¬ç«‹è¿›ç¨‹,å´©æºƒä¸å½±å“å…¶ä»–æ¨¡å— | âŒ å•è¿›ç¨‹,ä¸€å¤„å´©æºƒå…¨å±€å½±å“ |
| **å¯æ‰©å±•æ€§** | âœ… å¯åˆ†å¸ƒå¼éƒ¨ç½²(è·¨æœºå™¨) | âš ï¸ ä»…æ”¯æŒå•æœº |
| **çƒ­æ›´æ–°** | âœ… å¯ç‹¬ç«‹é‡å¯æŸä¸ªæ¨¡å— | âŒ éœ€é‡å¯æ•´ä¸ªç¨‹åº |
| **è¯­è¨€æ— å…³** | âœ… æ”¯æŒå¤šè¯­è¨€æ··åˆ(C++/Python) | âš ï¸ é€šè¿‡ pybind11 ç»‘å®š |
| **è´Ÿè½½å‡è¡¡** | âœ… å¯å¤šå®ä¾‹ + è´Ÿè½½å‡è¡¡ | âŒ ä¸æ”¯æŒ |
| **è°ƒè¯•å‹å¥½** | âœ… å¯ç‹¬ç«‹æµ‹è¯•æ¯ä¸ªæ¨¡å— | âš ï¸ éœ€é›†æˆæµ‹è¯• |

> [!IMPORTANT]
> **å­¦ä¹ ä»·å€¼**: ZeroMQ æä¾›äº†**è§£è€¦ã€é«˜æ€§èƒ½ã€è·¨è¯­è¨€**çš„é€šä¿¡æ–¹æ¡ˆ,ç‰¹åˆ«é€‚åˆ:
> - å¤šæ¨¡å—ååŒ(å¦‚ ASR + LLM + TTS)
> - éœ€è¦ç‹¬ç«‹éƒ¨ç½²/æ›´æ–°çš„åœºæ™¯
> - åˆ†å¸ƒå¼ç³»ç»Ÿæ¶æ„

#### **å¯¹å½“å‰é¡¹ç›®çš„å¯ç¤º**

**åœºæ™¯ 1: ScreenRecorder + KeyFrame è§£è€¦**

å½“å‰æ¶æ„:
```cpp
// ç´§è€¦åˆè®¾è®¡
class ScreenRecorder {
    FrameEncoder encoder_;
    MotionDetector detector_;  // ç›´æ¥ä¾èµ–
};
```

æ”¹è¿›æ–¹æ¡ˆ (ZeroMQ):
```cpp
// ScreenRecorder è¿›ç¨‹
zmq::socket_t publisher(context, ZMQ_PUB);
publisher.bind("tcp://*:5555");
publisher.send(frame_data);  // å‘å¸ƒå¸§æ•°æ®

// KeyFrame åˆ†æè¿›ç¨‹
zmq::socket_t subscriber(context, ZMQ_SUB);
subscriber.connect("tcp://localhost:5555");
auto frame = subscriber.recv();  // è®¢é˜…å¸§æ•°æ®
detector.analyze(frame);
```

**æ”¶ç›Š**:
- ScreenRecorder å¯ç‹¬ç«‹è¿è¡Œ(ä¸ä¾èµ– AI æ¨¡å—)
- KeyFrame åˆ†æå¯éƒ¨ç½²åˆ° GPU æœåŠ¡å™¨
- æ”¯æŒå¤šä¸ªåˆ†æå™¨è®¢é˜…åŒä¸€è§†é¢‘æµ

---

### 2.2 â­ è‡ªå®šä¹‰æ¨ç†å¼•æ“ (åµŒå…¥å¼ä¼˜åŒ–)

#### **LLM_Voice_Flow çš„ TTS å¼•æ“**

**æ¶æ„è®¾è®¡**:

```mermaid
classDiagram
    class SynthesizerTrn {
        +infer(text, sid, lengthScale) int16_t*
        -TextEncoder textEncoder_
        -DurationPredictor durPredicator_
        -ResidualCouplingBlock flow_
        -Generator_base dec_
    }
    
    class TextEncoder {
        +forward(strIDs, strLen) MatrixXf
    }
    
    class DurationPredictor {
        <<abstract>>
        +forward(x, g, noiseScale) MatrixXf
    }
    
    class StochasticDurationPredictor
    class FixDurationPredictor
    
    class Generator_base {
        <<abstract>>
        +forward(z, g) MatrixXf
    }
    
    class Generator_hifigan
    class Generator_MS
    class Generator_Istft
    
    SynthesizerTrn --> TextEncoder
    SynthesizerTrn --> DurationPredictor
    SynthesizerTrn --> Generator_base
    DurationPredictor <|-- StochasticDurationPredictor
    DurationPredictor <|-- FixDurationPredictor
    Generator_base <|-- Generator_hifigan
    Generator_base <|-- Generator_MS
    Generator_base <|-- Generator_Istft
```

**æ ¸å¿ƒç‰¹ç‚¹**:

1. **çº¯ C++ å®ç°** (æ—  PyTorch/TensorFlow ä¾èµ–)
   ```cpp
   // ä½¿ç”¨ Eigen è¿›è¡ŒçŸ©é˜µè¿ç®—
   MatrixXf z_p = m_expand.array() + 
                  rand_gen(m_expand.rows(), m_expand.cols(), 0.0, 1.0).array() * 
                  logs_expand.array() * noiseScale;
   ```

2. **æ¨¡å‹æƒé‡åµŒå…¥äºŒè¿›åˆ¶**
   ```cpp
   SynthesizerTrn::SynthesizerTrn(float* modelData, int32_t modelSize) {
       // ç›´æ¥ä»å†…å­˜åŠ è½½æ¨¡å‹å‚æ•°
       synData->textEncoder_ = new TextEncoder(modelData, offset);
       synData->dec_ = new Generator_hifiGan(modelData, offset);
   }
   ```

3. **å¤šå£°ç å™¨æ”¯æŒ** (ç­–ç•¥æ¨¡å¼)
   ```cpp
   if (synData->decType_ == DEC_TYPE_HIFIGAN) {
       synData->dec_ = new Generator_hifiGan(modelData, offset);
   } else if (synData->decType_ == DEC_TYPE_ISTFT) {
       synData->dec_ = new Generator_Istft(modelData, offset);
   }
   ```

**å¯¹æ¯”å½“å‰é¡¹ç›®**:

| ç»´åº¦ | LLM_Voice_Flow | AiVideoAnalsysSystem |
|------|----------------|----------------------|
| **æ¨ç†æ¡†æ¶** | è‡ªå®šä¹‰ C++ å¼•æ“ | ONNX Runtime |
| **ä¾èµ–å¤§å°** | ä»… Eigen (~500KB) | ONNX Runtime (~100MB) |
| **å¯åŠ¨é€Ÿåº¦** | æå¿« (æ— æ¡†æ¶åˆå§‹åŒ–) | è¾ƒæ…¢ (éœ€åŠ è½½ ONNX) |
| **å†…å­˜å ç”¨** | ä½ (ç²¾ç¡®æ§åˆ¶) | é«˜ (æ¡†æ¶å¼€é”€) |
| **æ¨¡å‹æ ¼å¼** | è‡ªå®šä¹‰äºŒè¿›åˆ¶ | ONNX æ ‡å‡†æ ¼å¼ |
| **é€‚ç”¨åœºæ™¯** | åµŒå…¥å¼/è¾¹ç¼˜è®¾å¤‡ | é€šç”¨ AI åº”ç”¨ |

> [!TIP]
> **å­¦ä¹ ä»·å€¼**: å¯¹äº**å›ºå®šæ¨¡å‹æ¶æ„**çš„åœºæ™¯(å¦‚ VITS TTS),è‡ªå®šä¹‰å¼•æ“å¯ä»¥:
> - å‡å°‘ 90% çš„ä¾èµ–ä½“ç§¯
> - æå‡ 3-5 å€å¯åŠ¨é€Ÿåº¦
> - å®ç°æè‡´çš„å†…å­˜æ§åˆ¶

#### **å¯¹å½“å‰é¡¹ç›®çš„å¯ç¤º**

**åœºæ™¯: æ–‡æœ¬æ£€æµ‹æ¨¡å‹ä¼˜åŒ–**

å½“å‰æ–¹æ¡ˆ (ONNX Runtime):
```cpp
// éœ€è¦åŠ è½½å®Œæ•´çš„ ONNX Runtime
ONNXSession session("text_detector.onnx");
auto output = session.run(input);
```

æ½œåœ¨ä¼˜åŒ– (è‡ªå®šä¹‰å¼•æ“):
```cpp
// ä»…å®ç° CRNN æ ¸å¿ƒç®—æ³•
class CRNNTextDetector {
    void conv2d(const MatrixXf& input, MatrixXf& output);
    void lstm(const MatrixXf& input, MatrixXf& output);
    void ctc_decode(const MatrixXf& logits, string& text);
};
```

**é€‚ç”¨æ¡ä»¶**:
- âœ… æ¨¡å‹æ¶æ„å›ºå®š(ä¸é¢‘ç¹æ›´æ¢)
- âœ… éœ€è¦æè‡´æ€§èƒ½(åµŒå…¥å¼è®¾å¤‡)
- âŒ æ¨¡å‹é¢‘ç¹è¿­ä»£(å»ºè®®ä¿æŒ ONNX)

---

### 2.3 â­ å¹¶å‘ä¸æµå¼å¤„ç†

#### **LLM_Voice_Flow çš„åŒçº¿ç¨‹æµæ°´çº¿**

**TTS æ¨¡å—è®¾è®¡**:

```mermaid
sequenceDiagram
    participant Main as ä¸»çº¿ç¨‹
    participant Synth as åˆæˆçº¿ç¨‹
    participant Play as æ’­æ”¾çº¿ç¨‹
    participant Queue as åŒç¼“å†²é˜Ÿåˆ—
    
    Main->>Queue: push_text("ä½ å¥½ä¸–ç•Œ")
    Synth->>Queue: pop_text()
    Synth->>Synth: TTS æ¨ç†
    Synth->>Queue: push_audio(wav_data)
    Play->>Queue: pop_audio()
    Play->>Play: ALSA æ’­æ”¾
    Play->>Main: çŠ¶æ€åé¦ˆ
```

**å…³é”®ä»£ç **:

```cpp
// åŒç¼“å†²æ¶ˆæ¯é˜Ÿåˆ—
class DoubleMessageQueue {
    std::queue<std::string> text_queue_;
    std::queue<AudioMessage> audio_queue_;
    std::mutex text_mutex_;
    std::mutex audio_mutex_;
    std::condition_variable text_cv_;
    std::condition_variable audio_cv_;
};

// åˆæˆçº¿ç¨‹
void synthesis_worker(DoubleMessageQueue& queue, TTSModel& model) {
    while (true) {
        std::string text = queue.pop_text();  // é˜»å¡ç­‰å¾…
        int16_t* wavData = model.infer(text, audio_len);
        queue.push_audio(std::move(audio_data), audio_len);
    }
}

// æ’­æ”¾çº¿ç¨‹
void playback_worker(DoubleMessageQueue& queue, AudioPlayer& player) {
    while (true) {
        auto msg = queue.pop_audio();  // é˜»å¡ç­‰å¾…
        player.play(msg.data.get(), msg.length);
    }
}
```

**ä¼˜åŠ¿**:
- **æµæ°´çº¿å¹¶è¡Œ**: åˆæˆå’Œæ’­æ”¾åŒæ—¶è¿›è¡Œ
- **ä½å»¶è¿Ÿ**: è¾¹åˆæˆè¾¹æ’­æ”¾(é¦–å­—å»¶è¿Ÿ < 200ms)
- **èµ„æºéš”ç¦»**: æ’­æ”¾ä¸é˜»å¡åˆæˆ

**å¯¹æ¯”å½“å‰é¡¹ç›®**:

å½“å‰æ¶æ„ (ScreenRecorder):
```cpp
// é‡‡é›†çº¿ç¨‹
void FrameGrabberThread::run() {
    while (running_) {
        auto frame = grabber_->grabFrame();
        encoder_->encode(frame);  // åŒæ­¥ç¼–ç ,å¯èƒ½é˜»å¡
    }
}
```

æ”¹è¿›æ–¹æ¡ˆ:
```cpp
// é‡‡é›†çº¿ç¨‹
void CaptureThread::run() {
    while (running_) {
        auto frame = grabber_->grabFrame();
        frame_queue_.push(frame);  // éé˜»å¡
    }
}

// ç¼–ç çº¿ç¨‹
void EncodeThread::run() {
    while (running_) {
        auto frame = frame_queue_.pop();  // é˜»å¡ç­‰å¾…
        encoder_->encode(frame);
    }
}
```

**æ”¶ç›Š**:
- é‡‡é›†å¸§ç‡ç¨³å®š(ä¸å—ç¼–ç å½±å“)
- æ”¯æŒå¤šç¼–ç å™¨å¹¶è¡Œ(1080p + 720p)

---

### 2.4 â­ ç¡¬ä»¶åŠ é€Ÿä¸å¼‚æ„è®¡ç®—

#### **LLM_Voice_Flow çš„ RKNN-LLM**

**ç‰¹ç‚¹**:
- ä¸“ä¸º Rockchip NPU ä¼˜åŒ–
- æ”¯æŒ INT8 é‡åŒ–æ¨ç†
- CPU æ ¸å¿ƒç»‘å®šä¼˜åŒ–

```cpp
RKLLMParam param = rkllm_createDefaultParam();
param.extend_param.enabled_cpus_num = 2;
param.extend_param.enabled_cpus_mask = CPU0 | CPU2;  // ç»‘å®šç‰¹å®šæ ¸å¿ƒ
param.extend_param.embed_flash = 1;  // ä½¿ç”¨ Flash å­˜å‚¨åµŒå…¥å±‚
```

**å¯¹å½“å‰é¡¹ç›®çš„å¯ç¤º**:

å½“å‰é¡¹ç›®å¯è€ƒè™‘:
1. **Intel OpenVINO** (Intel CPU/GPU åŠ é€Ÿ)
2. **NVIDIA TensorRT** (NVIDIA GPU åŠ é€Ÿ)
3. **DirectML** (Windows é€šç”¨ GPU åŠ é€Ÿ)

ç¤ºä¾‹ (OpenVINO):
```cpp
// æ›¿æ¢ ONNX Runtime
#include <openvino/openvino.hpp>

ov::Core core;
auto model = core.read_model("model.xml");
auto compiled = core.compile_model(model, "GPU");  // GPU åŠ é€Ÿ
auto infer_request = compiled.create_infer_request();
```

---

## ä¸‰ã€å·¥ç¨‹å®è·µä¼˜åŠ¿æ€»ç»“

### 3.1 æ¨¡å—åŒ–è®¾è®¡å¯¹æ¯”

| è®¾è®¡ç»´åº¦ | LLM_Voice_Flow | AiVideoAnalsysSystem |
|----------|----------------|----------------------|
| **æ¨¡å—è€¦åˆ** | æ¾è€¦åˆ (ZeroMQ) | ç´§è€¦åˆ (ç›´æ¥è°ƒç”¨) |
| **éƒ¨ç½²çµæ´»æ€§** | å¯åˆ†å¸ƒå¼ | å•æœºéƒ¨ç½² |
| **æ•…éšœéš”ç¦»** | è¿›ç¨‹çº§éš”ç¦» | æ— éš”ç¦» |
| **æŠ€æœ¯æ ˆæ··åˆ** | C++/Python è‡ªç”±æ··åˆ | éœ€ pybind11 ç»‘å®š |

### 3.2 æ€§èƒ½ä¼˜åŒ–å¯¹æ¯”

| ä¼˜åŒ–æ–¹å‘ | LLM_Voice_Flow | AiVideoAnalsysSystem |
|----------|----------------|----------------------|
| **æ¨ç†å¼•æ“** | è‡ªå®šä¹‰ + ONNX æ··åˆ | çº¯ ONNX Runtime |
| **ç¡¬ä»¶åŠ é€Ÿ** | NPU ä¸“ç”¨ä¼˜åŒ– | é€šç”¨ CPU æ¨ç† |
| **å¹¶å‘æ¨¡å‹** | å¤šçº¿ç¨‹æµæ°´çº¿ | å•çº¿ç¨‹/ç®€å•å¤šçº¿ç¨‹ |
| **å†…å­˜ç®¡ç†** | æ‰‹åŠ¨æ± åŒ– | ä¾èµ–æ¡†æ¶ |

### 3.3 å¯ç»´æŠ¤æ€§å¯¹æ¯”

| ç»´åº¦ | LLM_Voice_Flow | AiVideoAnalsysSystem |
|------|----------------|----------------------|
| **æµ‹è¯•éš”ç¦»** | å¯ç‹¬ç«‹æµ‹è¯•æ¯ä¸ªæœåŠ¡ | éœ€é›†æˆæµ‹è¯• |
| **æ—¥å¿—è¿½è¸ª** | åˆ†å¸ƒå¼æ—¥å¿— | å•è¿›ç¨‹æ—¥å¿— |
| **ç‰ˆæœ¬ç®¡ç†** | æ¨¡å—ç‹¬ç«‹ç‰ˆæœ¬ | æ•´ä½“ç‰ˆæœ¬ |

---

## å››ã€å…·ä½“å­¦ä¹ å»ºè®®

### 4.1 çŸ­æœŸæ”¹è¿› (1-2 å‘¨)

#### **å»ºè®® 1: å¼•å…¥ ZeroMQ è§£è€¦ ScreenRecorder å’Œ KeyFrame**

**å®æ–½æ­¥éª¤**:

1. **å®‰è£… ZeroMQ**
   ```cmake
   # CMakeLists.txt
   find_package(cppzmq REQUIRED)
   target_link_libraries(ai_video_core PUBLIC cppzmq)
   ```

2. **åˆ›å»ºé€šä¿¡å±‚**
   ```cpp
   // include/Infra/MessageBus.h
   class MessageBus {
   public:
       void publishFrame(const cv::Mat& frame);
       cv::Mat subscribeFrame();
   private:
       zmq::context_t context_;
       zmq::socket_t publisher_;
       zmq::socket_t subscriber_;
   };
   ```

3. **é‡æ„æ¨¡å—**
   ```cpp
   // ScreenRecorder è¿›ç¨‹
   MessageBus bus;
   while (recording_) {
       auto frame = grabber_->grabFrame();
       bus.publishFrame(frame);  // å‘å¸ƒè€Œéç›´æ¥å¤„ç†
   }
   
   // KeyFrame åˆ†æè¿›ç¨‹
   MessageBus bus;
   while (analyzing_) {
       auto frame = bus.subscribeFrame();
       detector_->detect(frame);
   }
   ```

**é¢„æœŸæ”¶ç›Š**:
- å½•å±å’Œåˆ†æå¯ç‹¬ç«‹è¿è¡Œ
- æ”¯æŒå¤šä¸ªåˆ†æå™¨è®¢é˜…
- å´©æºƒéš”ç¦»

---

#### **å»ºè®® 2: å®ç°åŒç¼“å†²é˜Ÿåˆ—ä¼˜åŒ–ç¼–ç æµç¨‹**

**å‚è€ƒ LLM_Voice_Flow çš„ DoubleMessageQueue**:

```cpp
// include/core/ScreenRecorder/ProcessLayer/DoubleBufferQueue.h
template<typename T>
class DoubleBufferQueue {
public:
    void push(T&& item) {
        std::lock_guard<std::mutex> lock(mutex_);
        queue_.push(std::forward<T>(item));
        cv_.notify_one();
    }
    
    T pop() {
        std::unique_lock<std::mutex> lock(mutex_);
        cv_.wait(lock, [this] { return !queue_.empty(); });
        T item = std::move(queue_.front());
        queue_.pop();
        return item;
    }
    
private:
    std::queue<T> queue_;
    std::mutex mutex_;
    std::condition_variable cv_;
};
```

**åº”ç”¨åœºæ™¯**:
```cpp
// é‡‡é›†çº¿ç¨‹ â†’ ç¼–ç çº¿ç¨‹
DoubleBufferQueue<cv::Mat> frame_queue;

// é‡‡é›†çº¿ç¨‹
void capture() {
    auto frame = grabber_->grabFrame();
    frame_queue.push(std::move(frame));
}

// ç¼–ç çº¿ç¨‹
void encode() {
    auto frame = frame_queue.pop();
    encoder_->encode(frame);
}
```

---

### 4.2 ä¸­æœŸæ”¹è¿› (1-2 æœˆ)

#### **å»ºè®® 3: æ¢ç´¢è‡ªå®šä¹‰æ¨ç†å¼•æ“ (é’ˆå¯¹å›ºå®šæ¨¡å‹)**

**é€‚ç”¨åœºæ™¯**: æ–‡æœ¬æ£€æµ‹æ¨¡å‹å·²ç¨³å®š,ä¸å†é¢‘ç¹æ›´æ¢

**å®æ–½è·¯å¾„**:

1. **å¯¼å‡º ONNX æ¨¡å‹ä¸ºæƒé‡æ–‡ä»¶**
   ```python
   import onnx
   import numpy as np
   
   model = onnx.load("text_detector.onnx")
   weights = {}
   for init in model.graph.initializer:
       weights[init.name] = numpy_helper.to_array(init)
   np.savez("weights.npz", **weights)
   ```

2. **å®ç° C++ æ¨ç†æ ¸å¿ƒ**
   ```cpp
   class CustomTextDetector {
       Eigen::MatrixXf conv2d(const Eigen::MatrixXf& input);
       Eigen::MatrixXf lstm(const Eigen::MatrixXf& input);
       std::string ctc_decode(const Eigen::MatrixXf& logits);
   };
   ```

3. **æ€§èƒ½å¯¹æ¯”æµ‹è¯•**
   ```cpp
   // å¯¹æ¯” ONNX Runtime vs è‡ªå®šä¹‰å¼•æ“
   Benchmark::run("ONNX", [&]() { onnx_session.run(input); });
   Benchmark::run("Custom", [&]() { custom_detector.infer(input); });
   ```

**é¢„æœŸæ”¶ç›Š**:
- å‡å°‘ 80MB+ ä¾èµ–
- æå‡ 2-3 å€æ¨ç†é€Ÿåº¦

---

#### **å»ºè®® 4: å¼•å…¥ç¡¬ä»¶åŠ é€Ÿ (OpenVINO/TensorRT)**

**æ–¹æ¡ˆå¯¹æ¯”**:

| æ–¹æ¡ˆ | é€‚ç”¨ç¡¬ä»¶ | é›†æˆéš¾åº¦ | æ€§èƒ½æå‡ |
|------|----------|----------|----------|
| **OpenVINO** | Intel CPU/GPU | ä¸­ | 3-5x |
| **TensorRT** | NVIDIA GPU | é«˜ | 5-10x |
| **DirectML** | é€šç”¨ GPU | ä½ | 2-3x |

**æ¨è**: OpenVINO (å…¼å®¹æ€§å¥½,æ˜“é›†æˆ)

```cmake
# CMakeLists.txt
find_package(OpenVINO REQUIRED)
target_link_libraries(ai_video_core PUBLIC openvino::runtime)
```

```cpp
// æ›¿æ¢ ONNXSession
class OpenVINOSession {
    ov::Core core_;
    ov::CompiledModel compiled_model_;
public:
    OpenVINOSession(const std::string& model_path) {
        auto model = core_.read_model(model_path);
        compiled_model_ = core_.compile_model(model, "GPU");
    }
};
```

---

### 4.3 é•¿æœŸæ”¹è¿› (3-6 æœˆ)

#### **å»ºè®® 5: å¾®æœåŠ¡æ¶æ„é‡æ„**

**ç›®æ ‡æ¶æ„**:

```mermaid
graph TB
    subgraph "é‡‡é›†æœåŠ¡"
        A[ScreenRecorder<br/>ç‹¬ç«‹è¿›ç¨‹]
    end
    
    subgraph "åˆ†ææœåŠ¡é›†ç¾¤"
        B1[MotionDetector<br/>å®ä¾‹1]
        B2[SceneDetector<br/>å®ä¾‹2]
        B3[TextDetector<br/>å®ä¾‹3]
    end
    
    subgraph "å­˜å‚¨æœåŠ¡"
        C[VideoWriter<br/>ç‹¬ç«‹è¿›ç¨‹]
    end
    
    A -->|ZMQ PUB| B1
    A -->|ZMQ PUB| B2
    A -->|ZMQ PUB| B3
    A -->|ZMQ PUSH| C
    
    B1 -->|ZMQ REQ| D[ç»“æœèšåˆæœåŠ¡]
    B2 -->|ZMQ REQ| D
    B3 -->|ZMQ REQ| D
```

**æ”¶ç›Š**:
- æ°´å¹³æ‰©å±• (å¤š GPU å¹¶è¡Œåˆ†æ)
- æ•…éšœè‡ªæ„ˆ (è¿›ç¨‹å´©æºƒè‡ªåŠ¨é‡å¯)
- çµæ´»éƒ¨ç½² (äº‘ç«¯/è¾¹ç¼˜æ··åˆ)

---

## äº”ã€å…³é”®æŠ€æœ¯æ·±åº¦å¯¹æ¯”

### 5.1 ZeroMQ vs pybind11

| ç»´åº¦ | ZeroMQ | pybind11 |
|------|--------|----------|
| **é€šä¿¡æ¨¡å¼** | è¿›ç¨‹é—´/ç½‘ç»œ | è¿›ç¨‹å†… (FFI) |
| **è¯­è¨€æ”¯æŒ** | 40+ è¯­è¨€ | C++ â†” Python |
| **æ€§èƒ½** | å¾®ç§’çº§å»¶è¿Ÿ | çº³ç§’çº§ (æ— åºåˆ—åŒ–) |
| **éƒ¨ç½²** | å¯åˆ†å¸ƒå¼ | å•æœº |
| **é€‚ç”¨åœºæ™¯** | å¾®æœåŠ¡æ¶æ„ | Python æ‰©å±• |

**ç»“è®º**: ä¸¤è€…äº’è¡¥,ä¸æ˜¯æ›¿ä»£å…³ç³»
- pybind11: ç”¨äº Python è°ƒç”¨ C++ æ ¸å¿ƒåº“
- ZeroMQ: ç”¨äº C++ æ¨¡å—é—´è§£è€¦

### 5.2 è‡ªå®šä¹‰å¼•æ“ vs ONNX Runtime

| ç»´åº¦ | è‡ªå®šä¹‰å¼•æ“ | ONNX Runtime |
|------|-----------|--------------|
| **å¼€å‘æˆæœ¬** | é«˜ (éœ€å®ç°ç®—å­) | ä½ (å¼€ç®±å³ç”¨) |
| **æ¨¡å‹å…¼å®¹** | ä»…æ”¯æŒç‰¹å®šæ¶æ„ | æ”¯æŒæ‰€æœ‰ ONNX æ¨¡å‹ |
| **æ€§èƒ½** | æè‡´ä¼˜åŒ– | é€šç”¨ä¼˜åŒ– |
| **ä¾èµ–å¤§å°** | < 1MB | ~100MB |
| **é€‚ç”¨åœºæ™¯** | åµŒå…¥å¼/å›ºå®šæ¨¡å‹ | é€šç”¨ AI åº”ç”¨ |

**å†³ç­–æ ‘**:
```
æ˜¯å¦éœ€è¦é¢‘ç¹æ›´æ¢æ¨¡å‹?
â”œâ”€ æ˜¯ â†’ ä½¿ç”¨ ONNX Runtime
â””â”€ å¦ â†’ æ˜¯å¦å¯¹ä½“ç§¯/æ€§èƒ½æåº¦æ•æ„Ÿ?
    â”œâ”€ æ˜¯ â†’ è€ƒè™‘è‡ªå®šä¹‰å¼•æ“
    â””â”€ å¦ â†’ ä½¿ç”¨ ONNX Runtime
```

---

## å…­ã€å®æ–½è·¯çº¿å›¾

### Phase 1: åŸºç¡€è§£è€¦ (2 å‘¨)
- [ ] é›†æˆ ZeroMQ
- [ ] å®ç° MessageBus é€šä¿¡å±‚
- [ ] é‡æ„ ScreenRecorder â†’ KeyFrame é€šä¿¡

### Phase 2: æ€§èƒ½ä¼˜åŒ– (1 æœˆ)
- [ ] å®ç°åŒç¼“å†²é˜Ÿåˆ—
- [ ] ä¼˜åŒ–ç¼–ç æµæ°´çº¿
- [ ] å¼•å…¥ OpenVINO åŠ é€Ÿ

### Phase 3: æ¶æ„å‡çº§ (2 æœˆ)
- [ ] å¾®æœåŠ¡åŒ–æ”¹é€ 
- [ ] åˆ†å¸ƒå¼éƒ¨ç½²æ”¯æŒ
- [ ] ç›‘æ§ä¸æ—¥å¿—ç³»ç»Ÿ

### Phase 4: æ·±åº¦ä¼˜åŒ– (3 æœˆ)
- [ ] è‡ªå®šä¹‰æ¨ç†å¼•æ“ (å¯é€‰)
- [ ] å¤š GPU å¹¶è¡Œåˆ†æ
- [ ] äº‘è¾¹ååŒæ¶æ„

---

## ä¸ƒã€æ€»ç»“

### 7.1 LLM_Voice_Flow çš„æ ¸å¿ƒä¼˜åŠ¿

1. **æ¶æ„è§£è€¦**: ZeroMQ å®ç°çš„å¾®æœåŠ¡æ¶æ„
2. **æ€§èƒ½æè‡´**: è‡ªå®šä¹‰ TTS å¼•æ“ + ç¡¬ä»¶åŠ é€Ÿ
3. **å¹¶å‘ä¼˜åŒ–**: åŒçº¿ç¨‹æµæ°´çº¿ + æ¶ˆæ¯é˜Ÿåˆ—
4. **å·¥ç¨‹æˆç†Ÿ**: å®Œå–„çš„é”™è¯¯å¤„ç†å’Œèµ„æºç®¡ç†

### 7.2 å¯¹ AiVideoAnalsysSystem çš„ä»·å€¼

| æ”¹è¿›æ–¹å‘ | ä¼˜å…ˆçº§ | é¢„æœŸæ”¶ç›Š |
|----------|--------|----------|
| **ZeroMQ è§£è€¦** | ğŸ”´ é«˜ | å¯æ‰©å±•æ€§ +80% |
| **åŒç¼“å†²é˜Ÿåˆ—** | ğŸŸ¡ ä¸­ | ååé‡ +30% |
| **ç¡¬ä»¶åŠ é€Ÿ** | ğŸŸ¡ ä¸­ | æ¨ç†é€Ÿåº¦ +300% |
| **è‡ªå®šä¹‰å¼•æ“** | ğŸŸ¢ ä½ | ä½“ç§¯ -90%, é€Ÿåº¦ +200% |

### 7.3 æœ€ç»ˆå»ºè®®

> [!IMPORTANT]
> **ä¼˜å…ˆçº§æ’åº**:
> 1. **ç«‹å³å®æ–½**: ZeroMQ è§£è€¦ (æ¶æ„åŸºç¡€)
> 2. **è¿‘æœŸå®æ–½**: åŒç¼“å†²é˜Ÿåˆ— + OpenVINO (æ€§èƒ½æå‡)
> 3. **é•¿æœŸè§„åˆ’**: å¾®æœåŠ¡æ¶æ„ + è‡ªå®šä¹‰å¼•æ“ (æˆ˜ç•¥å‡çº§)

---

## é™„å½•: å‚è€ƒèµ„æº

### A.1 ZeroMQ å­¦ä¹ èµ„æº
- [ZeroMQ Guide](https://zguide.zeromq.org/)
- [cppzmq GitHub](https://github.com/zeromq/cppzmq)

### A.2 è‡ªå®šä¹‰æ¨ç†å¼•æ“æ¡ˆä¾‹
- [NCNN](https://github.com/Tencent/ncnn) - è…¾è®¯ç§»åŠ¨ç«¯æ¨ç†æ¡†æ¶
- [MNN](https://github.com/alibaba/MNN) - é˜¿é‡Œè½»é‡çº§æ¨ç†å¼•æ“

### A.3 ç¡¬ä»¶åŠ é€Ÿå·¥å…·
- [OpenVINO](https://docs.openvino.ai/)
- [TensorRT](https://developer.nvidia.com/tensorrt)
- [DirectML](https://learn.microsoft.com/en-us/windows/ai/directml/)

---

**æ–‡æ¡£ç‰ˆæœ¬**: v1.0  
**ç”Ÿæˆæ—¶é—´**: 2025-12-26  
**ä½œè€…**: Antigravity AI Assistant
